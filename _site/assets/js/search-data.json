{
  "0": {
    "id": "0",
    "title": "ArduinoでFlashAir制御の概要",
    "content": "ArduinoでFlashAir制御の概要 FlashAirをSDメモリカードホスト機器から制御して、 無線LANのON/OFFやAPモード・STAモードの切り替え、 あるいはHTTP通信を行うことができます。 手ごろなマイコンボードとして人気の高い Arduino と組み合わせて、 FlashAirを制御してみましょう。 iSDIO iSDIOは、SDメモリカードの規格団体であるSDアソシエーションによって定められた、 FlashAirのような拡張機能付きSDメモリカードをSDメモリカードホスト機器からコントロールするための規格です。 より正確には、iSDIOとはコマンドやりとりの手順を定めたプロトコルであり、 コマンドの種類や引数などの詳細は、拡張機能の種類（アプリケーション）ごとに、 補遺（Addendum）で定められます。 たとえば、FlashAirは無線LAN内蔵カード向けの「Wireless LAN Addendum」に準拠しています。 iSDIOの仕様書は、一部が簡易版仕様書 (Simplified Specification) として公開されており、 Simplifed Specifications - SD Associationからダウンロードできます。 Arduino Arduinoは、製品プロトタイピングなどの用途でとても人気のあるマイコンボードです。 オープンハードウェアプラットフォームを謳って、設計や回路図が公開されており、 ユーザーがクローンを製造したり、改造して独自のArduino互換ボードを作ることが容易です。 Arduinoについては、 公式サイトをご覧ください。 準備 1. 開発環境の準備 本チュートリアルでは、作成したプログラムをArduino本体に書き込んで実行し、 ログや無線LANの状態を確認していきます。 下記の機器が必要です。 Arduino Uno R3 Arduino本体です。 Arduinoには様々なモデルがあり、CPU速度、メモリ容量、I/O数などに違いがあります。 本チュートリアルでは特に断りがない場合、Uno R3という最も基本的なモデルを使います。 Arduino IDE 1.0.5とPC Arduino用プログラムの編集、コンパイル、書き込みは、Arduino IDEを使います。 こちらからダウンロードしてインストールしましょう。 開発環境を動かすPC環境には、WindowsまたはMacが利用できます。 本チュートリアルでは、Windows版を使用して説明しています。 詳細はArduino IDEのドキュメントを参照してください。 Seeed Studio SD Card Shield v4 Arduino Uno R3にはSDメモリカードスロットがありませんので、オプションボードを利用します。 本チュートリアルでは、Seeed Studio SD Card Shield V4を使用します。 FlashAirは無線LAN機能の分通常のSDメモリカードよりも電力を必要とするので、このボードのように、Arduino本体とは独立した電源回路を持っているものの方が適しています。 SeeeduinoStorage for FlashAirを使用するのもお勧めです。 USB 2.0 ケーブル（Bコネクタが通常サイズのもの） ArduinoとPCをつなぐケーブルです。 電源供給、プログラムの書き込み、UART通信に使用します。 Arduino側となるBコネクタが通常サイズのものを用意してください。スマホ向けによく使われるマイクロBや、ミニBは使えません。 FlashAir 家電量販店やネット通販で購入できます。 手持ちのFlashAirを使う場合は、保存されているデータをバックアップしておきましょう。 2. 開発をよりスムーズにするために ###FlashAirの動作確認方法 FlashAirが動作していることを確認する方法があると便利です。 APモードのときは、スマートフォンの無線LAN設定画面のSSID一覧で、 FlashAirが正しく機能しているかを確認できます。 STAモードの場合はSSID一覧では確認できませんが、 ルータの画面でIPアドレスが割り当てられたことを確認する方法があります。 お使いのルータの、ログや状態を確認する方法を予習しておきましょう。 開発に必要な知識 Arduino用語について Arduinoでは独特の用語を使うことがあります。 スケッチ プログラムのことです。 シールド オプションボードのことです。 電子工作用語について FlashAirの制御は、SDメモリカードとの電気的な信号で行います。 そのため、SDメモリカード規格、SPI信号規格、などを理解しているとよいでしょう。",
    "url": "http://localhost:4000/docs/tutorials/arduino/1.html",
    "relUrl": "/docs/tutorials/arduino/1.html"
  },
  "1": {
    "id": "1",
    "title": "ステーションモードの利用",
    "content": "ステーションモードの利用 ステーション（STA）モードとは、FlashAirを無線LAN子機として使うモードです。 本チュートリアルでは、STAモードに設定する方法を解説します。 概要 アクセスポイントモード 通常、FlashAirはアクセスポイント（AP）モードになっており、いわゆる無線LAN親機として動作しています。 PCやスマートフォンなどのデバイスは、無線LAN子機としてFlashAirに接続します。 FlashAirに接続中は、他の無線LAN親機とは接続できません。 このため、インターネットにアクセスできなくなったりします。 ステーションモード FlashAirをSTAモードにすることで、FlashAirを既に存在するの無線LANの子機として動作させることができます。 デバイスはインターネットにアクセスできる無線LANに接続したまま、FlashAirにアクセスすることができるようになります。 設定方法 STAモードへ変更するには、FlashAirの動作モードや無線LAN親機の情報、FlashAirカードを識別する名前の設定などを行う必要があります。 変更には、CONFIGファイルを直接変更する方法と、config.cgiを利用する方法の2通りがあります。 変更する項目 以下の4つの情報を変更する必要があります。 括弧内は APIガイド / CONFIGファイルの対応するパラメータ名です。 動作モード (APPMODE) パラメータに5を指定し、インフラストラクチャ・モードのステーション動作に変更します。 無線LAN SSID (APPSSID) 接続先無線LANのSSIDを指定します。 無線LAN ネットワークパスワード (APPNETWORKKEY) 接続先無線LANのネットワークキーを指定します。 FlashAir識別名 (APPNAME) 接続無線LANの中でFlashAirカードを特定するための名前を指定します。 方法1: 設定ファイルを直接編集する /SD_WLAN/CONFIGをエディタ等で開き、前述のパラメータを編集します。 このフォルダは隠しフォルダとなっていますので、隠しフォルダを扱う事が出来るツールを使いましょう。 (Macの場合は /Volumes/(ボリュームラベル名)/SD_WLAN/CONFIGです。) パラメータが存在しない場合は新しく行を追加してください。 パラメータの順序は問いません。 編集後は、たとえば下記のようになります。 APPMODE=5 APPNAME=myflashair APPSSID=FOOSSID APPNETWORKKEY=password0123 CIPATH=/DCIM/100__TSB/FA000001.JPG VERSION=F19BAW3AW2.00.00 CID=02544d535730384708c00b7d7800d201 PRODUCT=FlashAir VENDOR=TOSHIBA MASTERCODE=18002d4ff0a2 方法2: config.cgiを利用する場合 FlashAir識別名(APPNAME)以外の項目については、 config.cgiを使用してネットワーク経由で変更することもできます。 設定変更にはマスターコードが必要になります。未設定ならば、事前に設定しておきましょう。 マスターコードを設定するためのCGI呼び出し例 http://flashair/config.cgi?MASTERCODE=18002d4ff0a2 変更するためのCGI呼び出し例 http://flashair/config.cgi?MASTERCODE=18002d4ff0a2&amp;APPMODE=5&amp;APPSSID=FOOSSID&amp;APPNETWORKKEY=password0123 コマンドを発行するとFlashAirが再起動するため、通信が切断されます。 FlashAirへのアクセス方法 ステーションモードに設定されたFlashAirは、 同じ無線LAN親機に接続されたPCやスマートフォン等のデバイスからアクセスすることができます。 例えばウェブブラウザで、先ほど設定したFlashAir識別名(APPNAME)を用いて、下記のように指定します。 ブラウザユーティリティの画面が見えれば成功です。 http://myflashair/ Macの場合は、下記のようになります。 http://myflashair.local/ 重要: Androidの場合は、下記の使用上の注意をご覧ください。 使用上の注意 複数のFlashAirを同時に使用する場合 同一の無線LANネットワーク内で複数のFlashAirを使用する場合は、 FlashAir識別名（APPNAME）をすべて異なるものに設定してください。 対応プロトコルによる問題 FlashAirは、他のデバイスからFlashAirを識別するための仕組み(プロトコル)として、NetBIOS over TCP/IPとBonjourに対応しています(注)。 FlashAirにうまくアクセスできない場合、 接続に使用するデバイスまたは使用している無線LAN親機が、これらのプロトコルに対応しているか確認ください。 特に、Androidは通常これらのプロトコルに対応していません。 これらのプロトコルに対応してない場合は、代わりにIPアドレスを使うことでアクセスできます。 無線LAN親機がデバイスに割り当てたIPアドレスが 192.168.0.2の場合、以下のようにします。 http://192.168.0.2/ 重要: Bonjourのサービスアナウンスには対応していません。 ステーションモードでFlashAirに接続できない時 APPMODE=5に設定後、FlashAirに接続できない場合以下を確認してください。 FlashAirとルーターの距離は適切ですか? FlashAirとルーターの距離が離れすぎていると接続が不安定になることがあります。また、接続距離は障害物やネットワーク環境により変わります。FlashAirとルーターを近付ける、ルーターの置く場所を変える等お試しください。 カメラ等SDメモリカードスロット機器側から電源供給されていますか? FlashAirを入れた機器の自動電源OFF機能が働いている場合接続できません。自動電源機能をOFFにするか、自動電源OFFまでの時間を長くしてください。 ルーターに接続されていますか? ルーターとの接続が完了していない場合接続出来ません。ルーターの設定画面にFlashAirのMACアドレスが表示されているか確認し、接続されていない場合は、CONFIGファイルのAPPSSID、APPNETWORKKEYを確認してください。 Wifi周波数帯は対応規格内ですか? FlashAirの無線LAN機能は、2.4GHz帯の電波を使用します。2.4GHz帯以外のWifi接続を設定している場合は変更してください。 有効チャネルで接続されていますか? 有効チャネル：1ch （2,412MHz） から11ch （2,462MHz） の帯域を使用してください。 同じ名前のFlashAirが同一ネットワークに存在していませんか? 同一ネットワーク内でAPPNAMEは単一でなければなりません。複数のFlashAirを接続する場合はAPPNAMEを利用して個別にFlashAirを認識してアクセスする方法をご覧ください。 iSDIO機器共通の無線LAN設定を行う際、CONFIGに[WLANSD]が設定されていますか? iSDIO機器共通の無線LAN設定を行う場合は、CONFIGに[WLANSD]を追加する必要があります。詳しくはCONFIG記載例をご覧ください。 APモードで接続できますか? APPMODE=4にし、FlashAirを無線LAN親機として動作させてください。動作しない場合はFlashAir自体に問題が発生している可能性があります。 FlashAirをスマートフォンのテザリング機能で接続できますか? スマートフォンのテザリング機能を用いたらステーションモードで接続できたという場合は、ルーターに問題が発生している可能性があります。ルーターの設定をご確認ください。 参考 http://flashair/でFlashAirにアクセスするとリダイレクトループが発生することがあります。CONFIGでIPアドレスを設定してFlashAirへアクセスしてください。 IPアドレスを設定して個別にFlashAirを認識してアクセスする方法を参考に設定を行ってください。 FAQや東芝メモリのFAQも合わせてご確認ください。 FAQ 無線LAN搭載 SDメモリカード FlashAir™ に関するよくあるご質問（FAQ）",
    "url": "http://localhost:4000/docs/tutorials/advanced/1.html",
    "relUrl": "/docs/tutorials/advanced/1.html"
  },
  "2": {
    "id": "2",
    "title": "Android向けFlashAirアプリ開発の概要",
    "content": "Android向けFlashAirアプリ開発の概要 開発に必要な知識 FlashAirとの通信は、すべてHTTP通信によるCGIコマンドで行います。 そのため、CGIコマンドの挙動とHTTP通信する方法を理解しさえすれば、簡単なアプリは作れるようになります。 本チュートリアルでは、簡単なサンプルアプリを作りながら、各CGIコマンドの挙動を説明していきます。 チュートリアルを終えたら、あなたのアイデア次第。 クールなアプリや、FlashAirの面白い使い方をどんどん提案してください。 準備 1. Androidアプリ開発環境の準備 Androidアプリを開発するには、Googleが提供しているAndroid SDKを利用するのがもっとも基本的な方法となります。 また、作ったアプリをGoogle Playなどのアプリストアで公開する場合には、それぞれのストアへの登録が必要となります。 Android SDKのダウンロードはこちら、 詳しい開発情報はアプリ デベロッパー向けのドキュメント、 Google Playへの登録はAndroid Developersを、 それぞれご覧ください。 2. FlashAir実機の入手 作ったアプリを動かしてみるには、FlashAir SDメモリカードが必要になります。 家電量販店やネット通販で購入できます。 3. 補足: 開発をよりスムーズにするために ステーションモード デバイスがFlashAirと通信中の場合、無線LAN経由でインターネットへアクセスすることはできなくなるため、調べものなどが不便になります。 通常、FlashAirは無線LAN親機（アクセスポイント）として動作していますが、 FlashAirをステーション(STAモード)に設定すると、FlashAirは無線LAN子機（ステーション）として、他の無線LAN親機（アクセスポイント）に接続することができるようになります。 開発に使用しているマシンとFlashAirを同じ無線LAN親機に接続すると、 FlashAirにアクセスしながらインターネットへアクセスすることも出来るので、開発中はSTAモードが便利です。 詳しくは上級者向けチュートリアル / ステーションモードを参照してください。 無線LAN接続タイムアウト時間の変更 FlashAirは電力節約のため、しばらく通信がないと無線LANの電源を停止します。 開発中はしばしばそのようなことが発生するため、接続タイムアウトを大きな値に変更しておくと便利です。 詳しくはCONFIGリファレンス / 接続タイムアウト時間の設定を参照してください。 プロジェクトの作成 この節では、各チュートリアルで作成するAndroidプロジェクトに共通する部分の説明をします。 1. プロジェクトの作成 メニューの “File” → “New” → “Android Application Project” を選びます。 “Android Application Project”がない場合は、”Others…“を選び、隠れている選択肢をすべて表示させましょう。 2. プロジェクトの設定 プロジェクトの設定をしていきます。各自、ご自由に変更してかまいません。 ここでは、チュートリアルで使用する設定を解説します。 Application NameとProject Nameは、FlashAirTutorial1などとします。 Package Nameは、”com.fixstars.flashair.tutorial”とします。 それ以外は、 デフォルトの設定を使用します。 プロジェクトを作成するフォルダなどを作成します。 デフォルトの設定を使用します。 アイコンの設定をします。 デフォルトの設定を使用します。 自動生成するActivityの種類を指定します。 “Blank Activity” を使用します。 Activityの名前などを指定します。 デフォルトの設定を使用します。 Finishをクリックすると、シンプルなAndroidアプリのソースコードが自動生成されます。 各チュートリアルでは、この状態からはじめていきます。",
    "url": "http://localhost:4000/docs/tutorials/android/1.html",
    "relUrl": "/docs/tutorials/android/1.html"
  },
  "3": {
    "id": "3",
    "title": "MbedでAPモード起動",
    "content": "MbedでAPモード起動 FlashAirをiSDIOで制御することで、SDホストから無線LANのON/OFFや共有メモリの読み書きを行うことが可能です。本チュートリアルでは、クラウドで開発可能なマイコンボードMbedを使い、iSDIOドライバAPIを使用してFlashAirを制御し、APモードの設定を行います。 サンプル環境 HW：Airio-Base Airio-Baseの基本的な使い方はこちらのTips「Airio-Baseチュートリアル(MbedでLチカ)」を参照してください。 サンプルコード実行手順 こちらより、FlashAir_iSDIO_sampleをインポートしてください。 コンパイル」を押して、バイナリをダウンロードしてください。 Airio-BaseとPCを接続し、ISPボタンを押しながらRESETボタンを押して離すと、PCのエクスプローラに「CRP_DISABLED」という名前のドライブが表示されます。 ドライブ内の「firmware.bin」を削除し、ダウンロードしたバイナリを書き込みます。(firmware.binは上書きすることはできません。) 再度、RESETボタンを押して離すとプログラムが実行されます。 スマートフォンやPCなどで、「isdiotest」というSSIDが表示されるので、接続します。パスワードは「12345678」です。 正しく接続されれば成功です。 ライブラリ単体での利用 iSDIOライブラリ単体で使用する場合には、こちらをインポートしてお使いください。",
    "url": "http://localhost:4000/docs/tutorials/mbed/1.html",
    "relUrl": "/docs/tutorials/mbed/1.html"
  },
  "4": {
    "id": "4",
    "title": "Cordova向けFlashAirアプリ開発の概要",
    "content": "Cordova向けFlashAirアプリ開発の概要 Apache Cordovaは、オープンソースのモバイル開発フレームワークで、HTML、CSS、JavaScriptなどのウェブアプリケーション開発の技術でモバイルアプリケーションを開発することができます。 このシリーズでは、Cordovaを使ってFlashAirにアクセスするアプリを開発していきます。 第1回はCordovaの開発環境を構築し、デフォルトで用意されているHelloWorldアプリをAndroidやiOSデバイスで動かすところまで説明します。 準備 1. 開発環境の準備 Cordovaでアプリを開発するには、各モバイルプラットフォームを対象としているSDKをインストールする必要があります。 詳しくはこちらをご覧ください。 iOSアプリをAppStoreで公開する場合には、Apple Developer Licenseへの参加が必要になります。 詳しくは、Apple社のサイトをご覧ください。 AndroidアプリをGoogle Playなどのアプリストアで公開する場合には、それぞれのストアへの登録が必要となります。 Google Playへの登録はDistribute App | Android Developersをご覧ください。 2. FlashAir実機の入手 作ったアプリを動かしてみるには、FlashAir SDメモリカードが必要になります。 家電量販店やネット通販で購入できます。 3. 補足: 開発をよりスムーズにするために ステーションモード デバイスがFlashAirと通信中の場合、無線LAN経由でインターネットへアクセスすることはできなくなるため、調べものなどが不便になります。通常、FlashAirは無線LAN親機（アクセスポイント）として動作していますが、FlashAirをステーション(STAモード)に設定すると、FlashAirは無線LAN子機（ステーション）として、他の無線LAN親機（アクセスポイント）に接続することができるようになります。開発に使用しているマシンとFlashAirを同じ無線LAN親機に接続すると、FlashAirにアクセスしながらインターネットへアクセスすることも出来るので、開発中はSTAモードが便利です。 詳しくは上級者向けチュートリアル / ステーションモードを参照してください。 無線LAN接続タイムアウト時間の変更 FlashAirは電力節約のため、しばらく通信がないと無線LANの電源を停止します。 開発中はしばしばそのようなことが発生するため、接続タイムアウトを大きな値に変更しておくと便利です。 詳しくはCONFIGリファレンス / 接続タイムアウト時間の設定を参照してください。&lt;/dd&gt; Cordovaのインストール 1. Node.jsをインストールする Cordovaのインストールには、npmが必要になります。 npmはNode.jsと一緒にインストールされます。 Node.jsのインストーラは公式ページから入手できます。 インストール完了後、以下のコマンドが実行できるか確認してください。バージョン情報が返ってくれば正しくインストールされています。 &gt; npm -v 3.10.10 2. Cordovaをインストールする 次に以下のコマンドを実行して、Cordovaをインストールします。 &gt; npm install -g cordova インストール完了後、以下のコマンドが実行できるか確認してください。バージョン情報が返ってくれば正しくインストールされています。 &gt; cordova -v 6.5.0 HelloWorldアプリの作成と確認 1. Cordovaプロジェクトを作成する まず始めに、HelloWorldアプリのプロジェクトを作成します。 プロジェクトを作成したいディレクトリへ移動し、以下のコマンドを実行します。 &gt; cordova create sample com.fixstars.flashair.tutorial HelloWorld sampleはプロジェクトのデータを格納するディレクトリ名になります。 com.fixstars.flashair.tutorialはアプリの識別子になります。 HelloWorldは作成するアプリ名になります。 上記３箇所についてはそれぞれ名前を任意に設定することができます。 作成したプロジェクトの中身を確認すると以下の構成になっています。 sample ├─ hooks │ └─ README.md ├─ platforms ├─ plugins ├─ www │ ├─ css │ │ └─ index.css │ ├─ img │ │ └─ logo.png │ ├─ js │ │ └─ index.js │ └─ index.html └─ config.xml 実際にアプリを開発していく際には、wwwディレクトリ以下に、HTML、CSS、JavaScriptを記述して開発していきます。 2. browserプラットフォームを追加して、ローカル上のブラウザでアプリの動作確認を行う デバイスで動かす前にローカル上のブラウザで動作確認できるようにする為、browserプラットフォームを追加します。 追加方法は作成したプロジェクトのディレクトリ（上記例の場合、sample）へ移動し、以下のコマンドを実行します。 &gt; cordova platform add browser -save 追加後に以下のコマンドを実行することで、追加したプラットフォームとそのバージョンが確認できます。 &gt; cordova platform ls Installed platforms: browser 4.1.0 そして以下のコマンドを実行することで、その下にある画面のように、自動的にローカル上のブラウザが立ち上がりアプリの動作確認ができます。 &gt; cordova run browser HelloWorldアプリのビルドとデバイスへのインストール 1. PhoneGap Buildの利用について Cordovaにはローカル上でビルドできるようにbuildコマンドが用意されていますが、実行するにはAndroidプラットフォームでAndroid SDKが、iOSプラットフォームでXcodeがそれぞれ必要となります。また、Xcodeの実行にはMacが必要であり、それ以外の開発環境ではiOSプラットフォーム向けのビルドはできません。 そこでこのチュートリアルでは、Cordova (PhoneGap)アプリをクラウド上でビルドできるサービスである「Adobe ® PhoneGap™ Build」を利用していきます。 2. PhoneGap Buildのアカウントを作成する まず、PhoneGap Buildへアクセスしログインします。 尚、ログイン時に選択するプランは無料、有料、Adove Creative Cloud メンバーシップと3つありますが、いずれの場合もAdobe IDが必要になりますので、所有していない場合は作成してください。 3. iOSプラットフォームの証明書キーを登録する iOSプラットフォームは証明書キーが登録されていないとビルドされませんので、先に証明書キーの登録を行います。 登録は以下の画面の「Edit account」から行います。 「Edit account」画面へ切り替わった後は「Signing Keys」タブへ切り替えて、iOSプラットフォームの「add a key …」ボタンを押下します。 そして「title」に任意の名前を付けて、登録するp12形式ファイルとプロビジョニングファイルを選択します。 尚、p12形式ファイルとプロビジョニングプロファイルの作成にはApple Developer Programへの登録が必要になります。登録して用意してください。 最後に「submit key」ボタンを押下してください。すると、証明書キーの読み込みが始まります。 読み込み完了後、以下の画面のように登録した証明書キーの「default」のラジオボタンを選択し、「status」内の「certificate password」に先程登録したp12形式ファイルのパスワードを入力します。 そして、「submit key」ボタンを押下しパスワードが正しく認識されると、証明書キーの登録は完了です。 4. HelloWorldアプリをビルドする 証明書キーの登録が完了すると、いよいよアプリのビルドに移ります。まず、画面上部のAppsボタンを押下して最初のアプリの追加画面へ戻り、「+ new app」ボタンを押下します。 次に、「private」タブへ切り替えて「Upload a .zip file」を押下し、上記で作成したHelloWorldアプリのプロジェクトデータをアップロードするのですが、ここで一つ注意点があります。 PhoneGap Buildへアップロードするデータ形式は決まっており（詳細はAdobe PhoneGapの App Project Structureをご確認ください）、 HelloWorldアプリではwwwディレクトリとconfig.xmlファイルのみが必要となります。従って、新規に作成したディレクトリの中にwwwディレクトリとconfig.xmlファイルを入れzipファイル化し、そのzipファイルをプロジェクトデータとしてアップロードすることになります。 zipファイルのアップロード完了後、正しく読み込まれると以下の画面に切り替わりますので、「Ready to build」ボタンを押下します。 その後、各プラットフォーム毎に自動的にアプリのビルドが開始されます。 そしてビルドが成功すると以下のように各プラットフォームのボタンが青緑色の表示になります。 ※ビルドに失敗した場合は赤色の表示になります。 5. 各プラットフォームのデバイスにHelloWorldアプリをインストールして起動する ビルド完了後、上記の画面においてアプリ名を押下すると、以下の画面へ切り替わります。 各プラットフォームのデバイスへのインストールは、対象のデバイスでこの画面のQRコードを読み取るか、ブラウザでこの画面へアクセスし「Install」ボタンをタップすることで開始できます。 Androidデバイスの場合はapkファイルがダウンロードされるだけとなりますので、「設定」 &gt; 「セキュリティ」 &gt; 「提供元不明のアプリ」 の項目をONにした状態で、ダウンロードされたapkファイルをタップするとインストールが開始されます。 以下のようにインストール完了後、アプリをタップすると、ブラウザで確認したときと同じHelloWorldアプリの画面が表示されます。 Androidデバイスの場合 iOSデバイスの場合",
    "url": "http://localhost:4000/docs/tutorials/cordova/1.html",
    "relUrl": "/docs/tutorials/cordova/1.html"
  },
  "5": {
    "id": "5",
    "title": "インターネット同時接続モードの設定",
    "content": "インターネット同時接続モードの設定 本チュートリアルでは、RaspberryPi上でiSDIOドライバAPIを使用してFlashAirを制御し、 インターネット同時接続モードの設定を行います。 サンプル環境 HW：Raspberry Pi 3 Model B ＋ microSD-&gt;SD変換アダプタ OS：Raspbian (NOOBS ver.2.4.3) NW：インターネット接続が可能なアクセスポイント microSD変換アダプタを使用してRaspberry Pi 3のmicroSDスロットにFlashAirを上図のように接続します。 サンプルコード実行手順 事前準備としてFlashAirからRaspberryPiを起動できるよう準備します。 また、SD_WLANフォルダのCONFIGファイルにAPPMODE=0を記載してください。 こちらよりサンプルコード環境をダウンロードして、RaspberryPi上に展開します。 展開場所はどこでも構いません。 展開すると下記のような構成で展開されますので、ターミナルからsampleフォルダまで移動します。 iSDIO_tutorial_sample |-incフォルダ(iSDIOドライバAPI ヘッダ部) | |- isdio_api.h | |- isdio_wlan_api.h | |- isdioreg.h | └─ mmc.h | |-sampleフォルダ | |- iSDIO_tutorial_sample.c (本チュートリアルサンプルコード) | └─ Makefile | └─srcフォルダ(iSDIOドライバAPI ソース部) |- isdio_api.c |- isdio_wlan_api.c └─ isdioreg.c ターミナル上でmakeを実行します。meke成功でsampleフォルダ内に実行ファイルisdio_sampleが作成されます。 ただし、インターネットに接続するアクセスポイント名、パスワードは環境によって違いますので、こちらを参照して変更してください。 4.で作成されたisdio_sampleを実行します。 ただし、iSDIOドライバを使用するには管理者権限が必要となります。下記のように実行してください。 &gt; sudo ./isdio_sample ダウンロードしたサンプルコード(iSDIO_tutorial_sample.c)を解説していきます。 iSDIOドライバの初期化 FlashAirを使用するためiSDIOカード制御情報の初期化を行います。 iSDIO_tutorial_sample.c(一部参照) iSDIO_INFO_t *s_info; /* iSDIOカード制御情報ポインタ */ char *s_device = &quot;/dev/mmcblk0&quot; ; /* SDカードデバイス情報 */ /* iSDIO初期化 */ s_info = iSDIO_Init(s_device); printf(&quot; info=0x%p n&quot;, s_info); if (s_info != NULL) { printf(&quot;info-&gt;fno=%d n&quot;, s_info-&gt;fno); system(&quot;mount /dev/mmcblk0p1 /mnt&quot;); 33行目 iSDIOカード制御情報の先頭アドレスを取得するためのポインタを準備します。 iSDIOカード制御情報はiSDIO_Initの戻り値として取得し、各コマンドおよびレスポンスでハンドラとして使用します。 34行目 SDカードデバイス情報はFlashAirのデバイス情報が設定されるため環境によって変更してください。 53行目 FlashAirをmountするため、環境によって変更してください。 アクセスポイントの検索 FlashAirが認識できるアクセスポイントの検索を行います。 iSDIO_tutorial_sample.c(一部参照) /* 周りのアクセスポイントの情報を取得 */ result = iSDIO_WLAN_Scan(s_info, s_seq_id ++); if (result == E_iSDIO_OK) { /* iSDIOコマンド実行プロセスの完了を待つ */ timeout = 20000; /* Scanのタイムアウトは20秒なので、20000ms */ cmd_success = FALSE; /* WLAN_Scanレスポンス待ち */ cmd_success = response_wait(s_info, (s_seq_id-1), iSDIO_WLAN_SCAN, timeout); if (cmd_success == FALSE) { printf(&quot;WLAN_Scan response error !!! n&quot;); } else { 55行目 iSDIO_WLAN_Scanは非同期関数のため62行目でのレスポンス待ちが必要となります。 55行目のレスポンスはiSDIO_WLAN_Scanコマンド実行の成否となり、62行目のレスポンス待ちはiSDIO_WLAN_Scanコマンド実行結果の成否となります。 コマンド・レスポンスについてはこちらを参照。 また、引数のシーケンスIDは新しくコマンドを発行するたびにユニークな値を設定します。 そのため、シーケンスID使用後インクリメントを行っています。 62行目 レスポンスデータ取得時には、コマンドIDとシーケンスIDでどのコマンド実行時のレスポンスかを判断します。 そのため、iSDIO_WLAN_Scanコマンド実行時のシーケンスIDを設定するため現在のシーケンスIDから-1した値でレスポンス待ちを行っています。 インターネット同時接続モードの設定 FlashAirを使用してインターネット接続をしながら自身をアクセスポイントに設定します。 iSDIO_tutorial_sample.c(一部参照) uint8_t apssid[32] = &quot;myflashair&quot;; /* FlashAir（AP側） 無線LAN SSID */ uint8_t apnetworkKey[64] = &quot;password0123&quot;; /* FlashAir（AP側） 無線LAN ネットワークキー */ uint8_t brgssid[32] = &quot;LANSSID&quot;; /* インターネット（STA側） 無線LAN SSID */ uint8_t brgnetworkKey[64] = &quot;lanpassword0123&quot;; /* インターネット（STA側） 無線LAN ネットワークキー */ uint32_t encMode = iSDIO_WLAN_ENCMODE_WPA2_PSK_AND_AES; /* 動作モード=6 */ /* 周りにアクセスポイントがある場合 */ /* アクセスポイント名を取得して対象のSTAがあるか判別 */ for(lp=0;lp&lt;num;lp++) { memset(getssid,0x00,32); /* アクセスポイント名取得用バッファクリア */ /* 指定番号のアクセスポイント名を取得 */ result = iSDIO_WLAN_GetSSID(s_info, lp , getssid); if(result != E_iSDIO_OK) { printf(&quot;WLAN_GetSSID get error !!! n&quot;); exit(0); } printf(&quot;SSID#%d SSID=%s n&quot;,lp, getssid); if(strstr((const char *)getssid, (const char *)brgssid)) { /* 対象のSTAありでBridge設定*/ result = iSDIO_WLAN_Bridge(s_info, s_seq_id++, apssid, sizeof(apssid), apnetworkKey, sizeof(apnetworkKey), encMode, brgssid, sizeof(brgssid), brgnetworkKey, sizeof(brgnetworkKey)); if(result != E_iSDIO_OK) { printf(&quot;Bridge Set error!!! n&quot;); exit(0); } break; } } 93行目 FlashAir自身がアクセスポイントとなるためのSSIDとそのレングス長を設定します。 94行目 アクセスポイントのネットワークキーとそのレングス長を設定します。 95行目 アクセスポイントの動作モードを設定します。インターネット同時接続モード場合は動作モード=6固定となります。 96行目 インターネットと接続しているステーション側のSSIDとそのレングス長を設定します。 97行目 インターネットと接続しているステーション側のネットワークキーとそのレングス長を設定します。 注意点 iSDIO_WLAN_BridgeはFlashAirがDisconnect状態でないと機能しません。 FlashAirがすでに別の機器接続状態の場合は、まずはiSDIO_WLAN_Disconnectを実行してください。 接続状態を知りたい場合は、iSDIO_WLAN_Check_WLANConnectを実行すると、引数connectに接続状態が出力されます。 レスポンス待ち処理 非同期コマンドの結果を待つ、レスポンス待ち処理について説明しておきます。 iSDIO_tutorial_sample.c(一部参照) /* コマンドレスポンス待ちサンプル関数 */ bool_t response_wait(iSDIO_INFO_t *s_info, uint32_t seq_id, uint32_t cmd_id, int32_t timeout) { iSDIO_CommandResponseStatus_t *status; int32_t timeout_cnt = timeout / 10; // ms / 10 bool_t cmd_success = FALSE; /* コマンドレスポンスステータスが実行中から抜けるかタイムアウトするまでループする */ do { status = iSDIO_ReadCommandResponseStatus(s_info); if ((status-&gt;response_status != iSDIO_COMMAND_PROCESSING) &amp;&amp; (status-&gt;cmd_id==cmd_id)) { if (status-&gt;response_status == iSDIO_PROCESS_SUCCEEDED) { cmd_success = TRUE; } break; printf(&quot;res_wait=%d n&quot;,status-&gt;response_status); } sleep(10); // 10ms待つ timeout_cnt --; } while (timeout_cnt &gt; 0); return cmd_success; } 160行目 FlashAirのレジスタ情報Command Response Statusを読み出す内部関数。 コマンドのレスポンスステータスを取得します。 161行目 レスポンスステータスが処理中ではなく、実施したコマンドのレスポンスであるならレスポンス正常でレスポンス待ちを抜け、戻り値にTRUEを返しています。 168-170行目 レスポンスステータスがまだ処理中の場合のタイムアウト処理。 このサンプルでは10ms単位でレスポンスステータスの確認を行い、引数のtimeout時間分レスポンス待ちを行っています。 タイムアウトの場合は戻り値にFALSEを返しています。 実行結果 実行してみましょう。 &gt; sudo ./isdio_sample dev/mmcblk0 open success info=0x27268 info-&gt;fno=1 SSID#1 SSID=LANSSID WLAN_Bridge set success WLAN_BridgeGetInfoByRegister get response success 2-4行目 FlashAirを正常に認識した場合のみ成功のログ表示とFlashAirのデバイスハンドルIDが表示されます。 5行目 SSIDが見つかった順番とアクセスポイント名は該当のアクセスポイントが見つかるか、Scanで発見されたアクセスポイント数分表示されます。 最後に表示されたものが該当のアクセスポイントとなります。 発見できなかった場合はエラーログが表示されます。 6行目 インターネット同時接続モードの設定が成功した場合のみ成功のログ表示がされます。 接続失敗の場合はエラーログが表示されます。 7行目 ブリッジ情報の取得が成功した場合のみ成功のログ表示がされます。 インターネットにつながっていないPC・スマートフォンなどから「myflashair」というSSIDに繋ぎ、http://flashair/にアクセスできることを確認してください。 また、インターネットに接続できることを確認してください。 情報取得失敗の場合はエラーログが表示されます。 コマンド・レスポンスについて 非同期となるコマンドは下記となります。 iSDIO_WLAN_Scan iSDIO_WLAN_Connect iSDIO_WLAN_Establish iSDIO_WLAN_WiFiDirect iSDIO_WLAN_StartWPS iSDIO_WLAN_StartWPSAP iSDIO_WLAN_Disconnect iSDIO_WLAN_SetCurrentTime iSDIO_WLAN_Abort iSDIO_WLAN_ReadResponse iSDIO_WLAN_SetPowerSaveMode iSDIO_WLAN_SetCannel iSDIO_WLAN_SendHTTPMessageByRegister iSDIO_WLAN_SendHTTPFileByRegister iSDIO_WLAN_SendHTTPSSLMessageByRegister iSDIO_WLAN_SendHTTPSSLFileByRegister iSDIO_WLAN_SendHTTPMessageByFile iSDIO_WLAN_SendHTTPFileByFile iSDIO_WLAN_SendHTTPSSLMessageByFile iSDIO_WLAN_SendHTTPSSLFileByFile iSDIO_WLAN_Request iSDIO_WLAN_SetCertificate iSDIO_WLAN_SetCertificateByFile iSDIO_WLAN_StartP2PSender iSDIO_WLAN_StartP2PReceiver iSDIO_WLAN_GetFile iSDIO_WLAN_ReadIDList iSDIO_WLAN_SelectMAC iSDIO_WLAN_DeselectMAC iSDIO_WLAN_SetID iSDIO_WLAN_Bridge iSDIO_WLAN_BridgeGetByRegister 同期となるコマンドは下記となります。 iSDIO_Init iSDIO_WLAN_WriteSharedMemory iSDIO_WLAN_ReadSharedMemory iSDIO_WLAN_GetFlashAirVersion iSDIO_WLAN_GetSSIDs iSDIO_WLAN_GetSSID iSDIO_WLAN_GetStatusData iSDIO_WLAN_GetResponseData iSDIO_WLAN_GetVersion iSDIO_WLAN_SetWaitResponseTime iSDIO_WLAN_Check_WLANConnect iSDIO_WLAN_Check_WLAN iSDIO_WLAN_Get_WLAN_Status サンプルコード環境一式 iSDIO_tutorial_sample.zip (24KB)",
    "url": "http://localhost:4000/docs/tutorials/raspberrypi/1.html",
    "relUrl": "/docs/tutorials/raspberrypi/1.html"
  },
  "6": {
    "id": "6",
    "title": "FlashAir Lua機能の概要",
    "content": "FlashAir Lua機能の概要 FlashAir W-03から、 FlashAirでのLuaスクリプト実行がサポートされました！ 本チュートリアルシリーズでは、 FlashAirのLua機能の基本的な使い方について学んでいきます。 Luaって何？ Luaは、高速、軽量、かつパワフルなスクリプト言語です。 (http://www.lua.org/about.htmlより) LuaとFlashAir Lua機能により FlashAir様々な新しいプログラマビリティがもたらされます。 たとえば、 外部サーバーへのファイルアップロード、 データのダウンロード、 HTMLの動的生成、 などの高度な機能が実現できます。 FlashAirのLua機能は、いくつかの制限もあります。 利用できるライブラリの制限事項については、 Lua APIガイドをご覧ください。 必要な知識 Lua言語の知識は 必須というわけではありませんが、 知っていれば役に立ちます。 基礎を学びたいならば、 Luaチュートリアルが利用できます(http://lua-users.org/wiki/TutorialDirectory 英語). 準備 1. 開発ツール Luaのプログラミングにはテキストエディタがあればよいですが、 お望みならば統合環境もあります。 詳しくはlua-usersのサイトをご覧ください。 作成したプログラムを実行するには、 SDメモリカードスロットを備えたPC (SDメモリカードホスト機器) を使用してスクリプトをFlashAirにコピーする必要があります。 そうすれば、スクリプトをHTTPリクエスト (つまりウェブブラウザでhttp://flashair/myfile.lua を開く) や、FlashAirの起動/書き込みイベント、で実行することができます。 チュートリアル２で詳しく見ていきます。 2. FlashAir！ このチュートリアルで作成するアプリケーションは、 FlashAirカードが必要です。 ネットや家電量販店で購入できます。 3. 補足: 開発をよりスムーズにするために ステーションモード デバイスがFlashAirと通信中の場合、無線LAN経由でインターネットへアクセスすることはできなくなるため、調べものなどが不便になります。通常、FlashAirは無線LAN親機（アクセスポイント）として動作していますが、FlashAirをステーション(STAモード)に設定すると、FlashAirは無線LAN子機（ステーション）として、他の無線LAN親機（アクセスポイント）に接続することができるようになります。開発に使用しているマシンとFlashAirを同じ無線LAN親機に接続すると、FlashAirにアクセスしながらインターネットへアクセスすることも出来るので、開発中はSTAモードが便利です。 詳しくは上級者向けチュートリアル / ステーションモードを参照してください。&lt;/dd&gt; 無線LAN接続タイムアウト時間の変更 FlashAirは電力節約のため、しばらく通信がないと無線LANの電源を停止します。 開発中はしばしばそのようなことが発生するため、接続タイムアウトを大きな値に変更しておくと便利です。 詳しくはCONFIGリファレンス / 接続タイムアウト時間の設定を参照してください。",
    "url": "http://localhost:4000/docs/tutorials/lua/1.html",
    "relUrl": "/docs/tutorials/lua/1.html"
  },
  "7": {
    "id": "7",
    "title": "ウェブブラウザ向けFlashAirアプリ開発の概要",
    "content": "ウェブブラウザ向けFlashAirアプリ開発の概要 FlashAirに保存されているファイルを、そのFlashAirに無線LAN接続された PC、スマートフォンなどから、ウェブブラウザで見ることができます。 ウェブブラウザに表示される画面は、ブラウザユーティリティというプログラムがFlashAir APIなどを使って生成したものです。 ブラウザユーティリティを作成する方法を学びましょう。 ブラウザユーティリティ ブラウザユーティリティとは、FlashAirに接続したPCやスマートフォンから、 ウェブブラウザでFlashAirのコンテンツを見る場合に表示される画面のことで、 HTML、CSS、JavaScriptの各ファイルから構成されています。 独自のブラウザユーティリティを作成することで、 ウェブブラウザでFlashAirコンテンツを見る場合のデザインを変えたり、 画像処理などの独自の機能を追加することができます。 本チュートリアルでは、ブラウザユーティリティの作成する方法を解説していきます。 準備 1. 開発環境の準備 ブラウザユーティリティの開発では、HTML、JavaScript、CSSを編集して、結果をウェブブラウザで確認することが主な作業となります。 使いやすいテキストエディタとウェブブラウザを用意しましょう。 それ以外に、特別な開発用ソフトウェアは必要ありません。 本チュートリアルでは、人気のあるWebコンテンツ用ライブラリである jQueryと Bootstrap を使っていきます。詳しい情報は、それぞれのサイトなどをご覧ください。 JavaScriptが動作している様子を確認できるFirefoxのウェブ開発ツールがあると非常に便利です。 開発中は開発者ツールを備えた本格的なウェブブラウザが使えるPCを、無線LANでFlashAirに接続して使用すると効率的でしょう。 作ったプログラムを実行するには、PCなどのSDメモリカードスロットを持つ機器（SDメモリカードホスト機器）を用いて、FlashAirにプログラムを書き込む必要があります。 開発中は頻繁に行うことになりますので、編集する機器とSDメモリカードホスト機器は同じ方がよいでしょう。 注意: iOSやAndroidのアプリ開発では、作成したプログラムを実行するには、iOSまたはAndroidのデバイス実機にインストールします。 しかし、ブラウザユーティリティの場合、作成したプログラムを実行するには、FlashAirに書き込む点に注意しましょう。 これは、ブラウザがFlashAirからブラウザユーティリティを都度取得して実行する仕組みであるからです。 2. FlashAir実機の入手 作ったユーティリティを動かしてみるには、FlashAir SDメモリカードが必要になります。 家電量販店やネット通販で購入できます。 3. バックアップの作成 最初にバックアップを取っておきましょう。 FlashAirの /SD_WLAN/フォルダ以下のファイルをすべて保存します。 ブラウザユーティリティがうまく動かなくなっても、バックアップした状態に戻せば、いつでももとの状態に戻せます。 このフォルダは隠しフォルダとなっていますので、隠しフォルダを扱う事が出来るツールを使いましょう。 4. 補足: 開発をよりスムーズにするために ステーションモード デバイスがFlashAirと通信中の場合、無線LAN経由でインターネットへアクセスすることはできなくなるため、調べものなどが不便になります。 通常、FlashAirは無線LAN親機（アクセスポイント）として動作していますが、 FlashAirをステーション(STAモード)に設定すると、FlashAirは無線LAN子機（ステーション）として、他の無線LAN親機（アクセスポイント）に接続することができるようになります。 開発に使用しているマシンとFlashAirを同じ無線LAN親機に接続すると、 FlashAirにアクセスしながらインターネットへアクセスすることも出来るので、開発中はSTAモードが便利です。 詳しくは上級者向けチュートリアル / ステーションモードを参照してください。 無線LAN接続タイムアウト時間の変更 FlashAirは電力節約のため、しばらく通信がないと無線LANの電源を停止します。 開発中はしばしばそのようなことが発生するため、接続タイムアウトを大きな値に変更しておくと便利です。 詳しくはCONFIGリファレンス / 接続タイムアウト時間の設定を参照してください。 開発に必要な知識 FlashAirとの通信は、すべてHTTP通信によるCGIコマンドで行います。 そのため、HTTP通信とCGIの基礎、およびFlashAir CGIの挙動を理解していることが必要です。 また、デザインのためのHTML、CSS、Javascriptなどの知識も必要になります。 本チュートリアルでは、FlashAirのCGIコマンドについて解説しながら簡単なブラウザユーティリティを作っていきます。 チュートリアルを終えたら、あとは開発者の皆さんのアイデア次第です。 クールなブラウザユーティリティを作成し、友達にも使ってもらいましょう！",
    "url": "http://localhost:4000/docs/tutorials/web/1.html",
    "relUrl": "/docs/tutorials/web/1.html"
  },
  "8": {
    "id": "8",
    "title": "iOS向けFlashAirアプリ開発の概要",
    "content": "iOS向けFlashAirアプリ開発の概要 開発に必要な知識 FlashAirとの通信は、すべてHTTP通信によるCGIコマンドで行います。 そのため、CGIコマンドの挙動とHTTP通信する方法を理解しさえすれば、簡単なアプリは作れるようになります。 本チュートリアルでは、簡単なサンプルアプリを作りながら、各CGIコマンドの挙動を説明していきます。 チュートリアルを終えたら、あなたのアイデア次第。 クールなアプリや、FlashAirの面白い使い方をどんどん提案してください。 準備 1. 開発環境の準備 一般に、iOSアプリを開発するためには、MacとXcodeが必要です。 また、作ったアプリをiOSデバイス実機でテストする場合や、AppStoreで公開する場合には、Apple Developer Licenseへの 参加が必要になります。 詳しくは、 Apple社のサイトをご覧ください。 2. FlashAir実機の入手 作ったアプリを動かしてみるには、FlashAir SDメモリカードが必要になります。 家電量販店やネット通販で購入できます。 3. 補足: 開発をよりスムーズにするために ステーションモード デバイスがFlashAirと通信中の場合、無線LAN経由でインターネットへアクセスすることはできなくなるため、調べものなどが不便になります。 通常、FlashAirは無線LAN親機（アクセスポイント）として動作していますが、 FlashAirをステーション(STAモード)に設定すると、FlashAirは無線LAN子機（ステーション）として、他の無線LAN親機（アクセスポイント）に接続することができるようになりま。 開発に使用しているマシンとFlashAirを同じ無線LAN親機に接続すると、 FlashAirにアクセスしながらインターネットへアクセスすることも出来るので、開発中はSTAモードが便利です。 詳しくは上級者向けチュートリアル / ステーションモードを参照してください。 無線LAN接続タイムアウト時間の変更 FlashAirは電力節約のため、しばらく通信がないと無線LANの電源を停止します。 開発中はしばしばそのようなことが発生するため、接続タイムアウトを大きな値に変更しておくと便利です。 詳しくは CONFIGリファレンス / 接続タイムアウト時間の設定を参照してください。 プロジェクトの作成 この節では、各チュートリアルで作成するiOSプロジェクトに共通する部分の説明をします。 1. プロジェクトの作成 メニューの “File” → “New” → “Project” を選びます。 2. プロジェクトの設定 プロジェクトの設定をしていきます。各自、ご自由に変更してかまいません。 ここでは、チュートリアルで使用する設定を解説します。 1.の手順後に Choose a template for your new project 画面が表示されますので、 Single View Application を選択し、 Next を押下します。 Choose options for your new project 画面が表示されますので、 Product Nameは、FlashAirTutorial1などとします。 Include Unit Tests のチェックを外します。 あとは、デフォルトの設定を使用します。 プロジェクトを作成するフォルダを選択し、Create を押下します。 Storyboards を使用したシンプルなiOSアプリのソースコードが自動生成されます。 各チュートリアルでは、この状態からはじめていきます。",
    "url": "http://localhost:4000/docs/tutorials/ios/1.html",
    "relUrl": "/docs/tutorials/ios/1.html"
  },
  "9": {
    "id": "9",
    "title": "Luaスクリプトをバイトコードにコンパイル",
    "content": "Luaスクリプトをバイトコードにコンパイル このチュートリアルでは、Luaスクリプトをバイトコードにコンパイルする方法をご紹介いたします。バイトコードでコンパイルすることにより、FlashAir内に保存したLuaスクリプトを難読化することが出来ます。 はじめに FlashAirにFlashAirでLuaを実行するで使用したHelloWorld.luaを設置します。 FlashAirでLuaを実行するを参考に、Luaスクリプト実行方法をCONFIGファイルに指定します。 コンパイル LuaスクリプトをバイトコードにコンパイルするLuaスクリプトを作成します。Lua標準関数の string.dumpを使用します。 /CompileToByteCode.lua function luac_func(filename) local targets = filename local chunk = assert(loadfile(filename)) local out = assert(io.open(targets..&quot;.out&quot;, &quot;wb&quot;)) out:write(string.dump(chunk)) out:close() end luac_func(&quot;HelloWorld.lua&quot;) このスクリプトを実行した後カードを抜き差しすると、HelloWorld.lua.outファイルが作成されます。 バイトコード化したLuaファイルを実行する ファイル名が異なるまま動作させると、requireなどが正しく動作しない場合があるため、元になったファイルHelloWorld.luaのファイル名を_HelloWorld.luaに変更し、HelloWorld.lua.outを元のファイル名のHelloWorld.luaに変更して実行します。 また、バイトコード化したファイルを呼び出すLuaスクリプトを作成します。Lua標準関数の dofileを使用することも可能です。 /ExecuteByteCode.lua dofile(&quot;/HelloWorld.lua&quot;) このスクリプトを保存しカードを抜き差しした後実行すると、バイトコード化した HelloWorld.luaの実行結果が表示されます。出力はFlashAirでLuaを実行すると同様になります。 バイトコード化したファイル内の関数やオブジェクトを使用する バイトコード化したLuaファイルを異なるLuaファイルから呼び出してみます。 まずは、tableオブジェクトを返すLuaスクリプトを作成します。 /ReturnTable.lua local function _foo() print(&quot;Hello World!&quot;) end return { foo=_foo } 他ファイル内の関数やオブジェクトを使用する場合はLua標準関数の requireを使用し、ファイルを読み込みます。呼び出し側のLuaスクリプトも作成します。 /CallByteCode.lua local script = require &quot;ReturnTable&quot; script.foo() ReturnTable.luaをコンパイルし、バイトコード化します。カードを抜き差しした後CallByteCode.luaを実行すると「Hello World!」が表示されます。 サンプルコード リポジトリを見る（GitHub） このサイトのサンプルコードは二条項BSDライセンスで提供されています。",
    "url": "http://localhost:4000/docs/tutorials/lua/10.html",
    "relUrl": "/docs/tutorials/lua/10.html"
  },
  "10": {
    "id": "10",
    "title": "コンテンツリストの取得",
    "content": "コンテンツリストの取得 第2回では、FlashAirのコンテンツリストを取得するアプリを作成します。command.cgiを使用します。 事前準備 1. プロジェクトを作成する まずは作成するアプリのプロジェクトを作成します。 第1回の HelloWorldアプリのプロジェクト作成のように、プロジェクトを作成したいディレクトリへ移動し、以下のコマンドを実行します。 &gt; cordova create cordovatutorial2 com.fixstars.flashair.tutorial CordovaTutorial2 またプロジェクト作成後、browserプラットフォームの追加も行います。 2. jQueryを追加する 開発時のJavaScriptのコード量を減らす目的で、jQueryを導入します。 jQueryは公式ページからダウンロードできます。 最新版のjQueryファイルをダウンロードして、先程作成したプロジェクト内の/www/js以下に保存しましょう。 ※ このチュートリアルではjquery-3.1.1.min.jsファイルをjQueryファイルとして利用しています。 アプリのトップ画面作成 1. index.htmlを編集する プロジェクト内のwwwディレクトリ以下にあるindex.htmlファイルは、アプリの起動後最初に表示される画面になります。 まずはこの画面の内容について以下のように編集します。 /www/index.html &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;default-src &#39;self&#39; data: gap: https://ssl.gstatic.com &#39;unsafe-eval&#39;; style-src &#39;self&#39; &#39;unsafe-inline&#39;; edia-src *; script-src &#39;self&#39; &#39;unsafe-inline&#39;&quot;&gt; &lt;meta name=&quot;format-detection&quot; content=&quot;telephone=no&quot;&gt; &lt;meta name=&quot;msapplication-tap-highlight&quot; content=&quot;no&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;user-scalable=no, initial-scale=1, maximum-scale=1, minimum-scale=1, width=device-width&quot;&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;Cordova Tutorial&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;css/load.css&quot;&gt; &lt;/head&gt; &lt;body onload=&quot;onLoad()&quot;&gt; &lt;div id=&quot;header&quot; class=&quot;pos-center&quot;&gt; &lt;div id=&quot;head-left&quot;&gt;&lt;/div&gt; &lt;h1 id=&quot;head-center&quot;&gt;Cordova Tutorial&lt;/h1&gt; &lt;div id=&quot;head-right&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;p class=&quot;pos-center&quot;&gt;&lt;button type=&quot;button&quot; onclick=&quot;location.href=&#39;tutorial2.html&#39;&quot;&gt;２．コンテンツリストの取得&lt;/button&gt;&lt;/p&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;cordova.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;js/load.js&quot;&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 22行目 Cordovaのデフォルトで設定されているCSPに対し、script-src &#39;self&#39; &#39;unsafe-inline&#39;を追加しています。 追加することで18行目にある&lt;button&gt;タグのonclick属性などのインラインスクリプトが有効になります。 26行目 文字コードでUTF-8を使用することを記述しています。 28行目 トップ画面でロードするCSSを記述しています。デフォルトで設定されているindex.cssの代わりにload.cssをロードしています。load.cssの内容は後述します。 30行目 画面読み込み時に処理するonLoad()関数を追加しています。onLoad()関数の内容は後述します。 31-35行目 画面のヘッダー部について記述しています。 36行目 タップされたらtutorial2.htmlの画面へ遷移するボタンを追加しています。コンテンツリストの取得はtutorial2.htmlの画面で行います。 37-38行目 トップ画面でロードするJavaScriptを記述しています。 デフォルトで設定されているindex.jsの代わりにload.jsをロードしています。load.jsの内容は後述します。（同じくデフォルトで設定されているcordova.jsは変更ありません） 2. load.cssを作成する トップ画面のデザインを以下のload.cssで設定します。作成したCSSファイルは、プロジェクトの/www/cssディレクトリ以下に配置してください。 /www/css/load.css * { -webkit-tap-highlight-color: rgba(0,0,0,0); } body { -webkit-touch-callout: none; -webkit-text-size-adjust: none; -webkit-user-select: none; background-attachment: fixed; font-family: &#39;HelveticaNeue-Light&#39;, &#39;HelveticaNeue&#39;, Helvetica, Arial, sans-serif; font-size: 4vw; height: 100%; margin: 0px; padding: 0px; width: 100%; } .pos-center{ text-align: center; vertical-align: middle; } button{ outline: none; font-size: 4vw; } #header{ display: -webkit-box; } #head-left{ -webkit-box-ordinal-group: 1; width: 15%; margin: 0; border-top: solid; border-bottom: solid; border-right: solid; border-width: 0.1vw; } #head-center { -webkit-box-ordinal-group: 2; -webkit-box-flex: 1; width: 70%; margin: 0; border-top: solid; border-bottom: solid; border-right: solid; border-width: 0.1vw; } #head-right{ -webkit-box-ordinal-group: 3; width: 15%; margin: 0; border-top: solid; border-bottom: solid; border-width: 0.1vw; } #lof{ overflow-wrap:break-word; word-wrap:break-word; } 3. load.jsを作成する トップ画面でロードするload.jsを以下の内容で作成します。作成したJSファイルは、プロジェクトの/www/jsディレクトリ以下に配置してください。 /www/js/load.js function onLoad() { document.addEventListener(&quot;deviceready&quot;, onDeviceReady, false); } function onDeviceReady() { document.addEventListener(&quot;backbutton&quot;, onBackKeyDown, false); } function onBackKeyDown() { navigator.app.exitApp(); } 1-3行目 Cordovaが完全にロードされた後に発火するdevicereadyイベントについて記述しています。コールバック関数はonDeviceReadyです。devicereadyイベントの詳細はCordova公式ページのdevicereadyをご覧ください。 5-7行目 バックボタンを押したときに発火するbackbuttonイベントについて記述しています。 コールバック関数はonBackKeyDownです。このイベントはバックボタンが存在するAndroidプラットフォームでは有効ですが、バックボタンが存在しないiOSプラットフォームでは無効となります。backbuttonイベントの詳細はCordova公式ページのbackbuttonをご覧ください。 9-11行目 onBackKeyDown関数が呼び出されたら、アプリを終了するようにしています。 4. Statusbarプラグインを使用してステータスバーを調整する トップ画面の作成は完了しましたが、この状態でビルドを行うと、デバイスのOSバージョンによっては画面上部のステータスバー（時間やバッテリー残量などを表示）と index.htmlで記述したWebViewのコンテンツが被る場合があります。 このステータスバーの設定は、Cordovaで用意されているStatusbarプラグインで変更できます。方法については、まずプロジェクト内で以下のコマンドを実行して、Statusbarプラグインを追加します。 &gt; cordova plugin add cordova-plugin-statusbar -save すると、以下のようにconfig.xmlファイルの&lt;widget&gt;タグ内の最後に、Statusbarプラグインが追加したことを示すコード&lt;plugin name=&quot;cordova-plugin-statusbar&quot; spec=&quot;~2.2.1&quot; /&gt; が記述されるので、続けて以下のコードを追記します。 /config.xml &lt;plugin name=&quot;cordova-plugin-statusbar&quot; spec=&quot;~2.2.2&quot; /&gt; &lt;preference name=&quot;StatusBarOverlaysWebView&quot; value=&quot;false&quot; /&gt; &lt;preference name=&quot;StatusBarStyle&quot; value=&quot;default&quot; /&gt; &lt;/widget&gt; StatusBarOverlaysWebView WebView上にステータスバーを置く（true）か否（false）かを設定します。今回は置かない（被せない）のでfalseを設定します。 StatusBarStyle ステータスバーのスタイルを設定します。今回はdefaultを設定します。 5. 実行結果 ビルドを行うと、以下のようにトップ画面が表示されるようになります。 Androidデバイスの場合 iOSデバイスの場合 コンテンツリストの取得画面の作成 1. tutorial2.htmlの作成 続いて、コンテンツリストの取得画面を作成します。デザインはトップ画面を引き継いでいます。 /www/tutorial2.html &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;default-src &#39;self&#39; data: gap: http://flashair https://ssl.gstatic.com &#39;unsafe-eval&#39;; style-src &#39;self&#39; unsafe-inline&#39;; media-src *; script-src &#39;self&#39; &#39;unsafe-inline&#39;&quot;&gt; &lt;meta name=&quot;format-detection&quot; content=&quot;telephone=no&quot;&gt; &lt;meta name=&quot;msapplication-tap-highlight&quot; content=&quot;no&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;user-scalable=no, initial-scale=1, maximum-scale=1, minimum-scale=1, width=device-width&quot;&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;Tutorial2&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;css/load.css&quot;&gt; &lt;/head&gt; &lt;body onload=&quot;onLoad()&quot;&gt; &lt;div id=&quot;header&quot; class=&quot;pos-center&quot;&gt; &lt;div id=&quot;head-left&quot;&gt;&amp;lt;&lt;br&gt;Back&lt;/div&gt; &lt;h1 id=&quot;head-center&quot;&gt;GetList&lt;/h1&gt; &lt;div id=&quot;head-right&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;p class=&quot;pos-center&quot;&gt;&lt;button onclick=&quot;getFlashAirInfo()&quot;&gt;FlashAirのファイル情報をGET&lt;/button&gt;&lt;/p&gt; &lt;p class=&quot;pos-center&quot;&gt;&amp;lt;ファイル数&amp;gt;&lt;br&gt; &lt;span id=&quot;nof&quot;&gt;0&lt;/span&gt;&lt;/p&gt; &lt;p class=&quot;pos-center&quot;&gt;&amp;lt;コンテンツリスト&amp;gt;&lt;br&gt; &lt;span id=&quot;lof&quot;&gt;WLANSD_FILELIST&lt;/span&gt;&lt;/p&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;cordova.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;js/jquery-3.1.1.min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;js/tutorial2.js&quot;&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 4行目 CSPのdefault-srcに対し、http://flashairを追加し、FlashAirへのアクセスを有効にしています。 12行目 トップ画面同様、画面読み込み時に処理するonLoad()関数を追加しています。onLoad()関数の内容は後述します。 13-17行目 画面のヘッダー部について記述しています。 トップ画面との違いは左側にバックボタンを設置しています。 18行目 タップされたらFlashAirのファイル数とコンテンツリストの情報（共にルート階層）を取得するボタンを追加しています。取得した情報はそれぞれ20行目と22行目の部分に表示します。 23-25行目 コンテンツリストの取得画面でロードするJavaScriptを記述しています。tutorial2.jsについては後述します。 また、事前準備で追加したjQueryファイルも使用します。 2. tutorial2.jsの作成 コンテンツリストの取得画面でロードするtutorial2.jsを以下の内容で作成します。作成したJSファイルは、プロジェクトの/www/jsディレクトリ以下に配置してください。 /www/js/tutorial2.js function onLoad() { document.addEventListener(&quot;deviceready&quot;, onDeviceReady, false); } function onDeviceReady() { document.addEventListener(&quot;backbutton&quot;, onBackKeyDown, false); $(&quot;#head-left&quot;).click(function(){ onBackKeyDown(); }); } function onBackKeyDown() { location.href = &quot;index.html&quot;; } function getFlashAirInfo(){ var wlansd = new Array(); $.ajax({ type: &quot;GET&quot;, url: &quot;http://flashair/command.cgi?op=101&amp;DIR=/&quot;, success: function(res){ $(&quot;#nof&quot;).html(res); }, error: function(xhr){ alert(&quot;Status: &quot; + xhr.status); } }); $.ajax({ type: &quot;GET&quot;, url: &quot;http://flashair/command.cgi?op=100&amp;DIR=/&quot;, success: function(res){ wlansd = res.split(/ n/g); wlansd.shift(); wlansd.pop(); $(&quot;#lof&quot;).html(&quot;&quot;); $.each(wlansd, function(){ var file = this; var fileobj = $(&quot;&lt;div&gt;&lt;/div&gt;&quot;); $(&quot;#lof&quot;).append( fileobj.append( file ) ); }); }, error: function(xhr){ alert(&quot;Status: &quot; + xhr.status); } }); } 5-10行目 画面のヘッダー左部に設置したバックボタンをタップした場合もonBackKeyDown関数が呼び出されるように設定しています。 12-14行目 load.jsと異なり、トップ画面へ戻るように設定しています。 16-52行目 FlashAirのファイル数とコンテンツリストの情報を取得して表示します。 それぞれcommand.cgi?op=101とcommand.cgi?op=100をAjaxでGETリクエストすることで、情報を取得します。 ※ 補足: Ajaxを使用したアプリのbrowserプラットフォームでの確認について 3. 実行結果 ビルドを行うと、以下のようにコンテンツリストの取得画面が表示されます。 またFlashAirへ無線LAN接続していれば、「FlashAirのファイル情報をGET」ボタンをタップすることで、接続しているFlashAirのファイル情報が表示されます。 Androidデバイスの場合 iOSデバイスの場合 補足 Ajaxを使用したアプリのbrowserプラットフォームでの確認について 今回のチュートリアルのようにAjaxを使用したアプリをbrowserプラットフォームで確認しようとした場合、同一生成元ポリシー（Same-Origin Policy）の制限に引っかかり、エラーが出力されます。こちらについてはGoogle Chromeの「–disable-web-security」オプションを利用することで回避することができます。 設定方法はプロジェクト内の/platforms/browser/cordova/node_modules/cordova-serve/src/browser.jsを開き、OSによってそれぞれ以下の場所に「–disable-web-security」オプションを追加します。 注意 「–disable-web-security」オプションはブラウザのウェブセキュリティをオフにするものですので、今回のようにアクセス先が決まっていて、アクセスしても問題ないと分かっている時以外は使用しないでください。 /platforms/browser/cordova/node_modules/cordova-serve/src/browser.js function getBrowser(target, dataDir) { dataDir = dataDir || &#39;temp_chrome_user_data_dir_for_cordova&#39;; var chromeArgs = &#39; --user-data-dir=/tmp/&#39; + dataDir + &#39; --disable-web-security&#39;; // Darwin（Mac）やLinuxの場合はここに追加 var browsers = { &#39;win32&#39;: { &#39;ie&#39;: &#39;iexplore&#39;, &#39;chrome&#39;: &#39;chrome --user-data-dir=%TEMP% &#39; + dataDir + &#39; --disable-web-security&#39;, // Windowsの場合はここに追加 &#39;safari&#39;: &#39;safari&#39;, サンプルコード リポジトリを見る（GitHub） このサンプルコードはApache License, Version 2.0で提供されています。 「cordova_tutorial_02」ディレクトリは、zipファイルで圧縮してPhoneGap Buildへアップロードすることでビルドできます。 ビルド方法はHelloWorldアプリをビルドするをご確認ください。 Cordovaプロジェクトで確認する場合は、「cordova_tutorial_02」ディレクトリ内のデータをプロジェクト内へ上書きコピーしてください。",
    "url": "http://localhost:4000/docs/tutorials/cordova/2.html",
    "relUrl": "/docs/tutorials/cordova/2.html"
  },
  "11": {
    "id": "11",
    "title": "コンテンツリストの取得",
    "content": "コンテンツリストの取得 このチュートリアルではコンテンツリストの取得方法について学びます。 今回使用するCGIはcommand.cgiのファイルリストの取得とファイル数の取得です。 指定したフォルダに存在するファイルの情報を取得して、結果を画面に表示するアプリケーションを作成します。 このチュートリアルでは、 StoryBoardsを使用してアプリケーションを作成していきます。 StoryBoardsを使用した開発方法については、ここでは詳しく説明しませんので、初心者の方はapple developerサイトや実際のサンプルコードを確認しながらチュートリアルを進めてみてください。 それではさっそく作ってみましょう。 画面レイアウトの作成 今回作成するアプリケーションの画面レイアウトです。 Get List がタップされると、labelCount にファイル数、textViewList にファイルリストが表示されるように作ります。 以下の部品を配置します。 Round Rect Button(UIButton) Get List : コンテンツリストを取得 Label(UILabel) labelCount : ファイル数の取得結果を表示 Text View(UITextView) textViewList : ファイルリストの取得結果を表示 UIButtonのpushイベントを実装する必要があるので、FSViewControllerに定義を追加します(追加する処理については後述します)。 レイアウト要素は FSViewController.h に宣言します。 FSViewController.h #import &lt;UIKit/UIKit.h&gt; @interface FSViewController : UIViewController @property (strong, nonatomic) IBOutlet UILabel *labelCount; @property (strong, nonatomic) IBOutlet UITextView *textViewList; - (IBAction)buttonPush:(id)sender; @end コードの作成 ファイルリストの取得 ファイルリストの取得は、command.cgiにop=100を与えることで実現します。 取得対象のフォルダを指定する必要があるので、ここではDCIMフォルダを指定します。 CGIの実行には、NSString stringWithContentsOfURLを使用しています。 この関数は、指定されたエンコーディングの文字列（ここではUTF-8）と、発生した例外を返します。 FSViewController.m [Part 1] #import &quot;FSViewController.h&quot; @interface FSViewController () @end @implementation FSViewController - (void)viewDidLoad { [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. self.labelCount.text = @&quot;&quot;; self.textViewList.text = @&quot;&quot;; } - (void)didReceiveMemoryWarning { [super didReceiveMemoryWarning]; // Dispose of any resources that can be recreated. } - (IBAction)buttonPush:(id)sender { NSError *error = nil; self.labelCount.text = @&quot;&quot;; self.textViewList.text = @&quot;&quot;; // Get file list // Make url NSURL *url100 = [NSURL URLWithString:@&quot;http://flashair/command.cgi?op=100&amp;DIR=/DCIM&quot;]; // Run cgi NSString *dirStr = [NSString stringWithContentsOfURL:url100 encoding:NSUTF8StringEncoding error:&amp;error]; if ([error.domain isEqualToString:NSCocoaErrorDomain]){ NSLog(@&quot;error100 %@ n&quot;,error); return; } // Display results self.textViewList.text = dirStr; 26-27行目使用するURLです。op=100&amp;DIR=/DCIMを設定します。 29-30行目CGIが実行されます。返される文字のエンコードは、ここでは UTF-8 を使用します。encoding:NSUTF8StringEncodingを指定しています。 36行目返された文字列（各ファイル情報）を、textViewListに設定しています。 ファイル数の取得 ファイル数の取得は、command.cgiにop=101を与えることで実現します。 取得対象のフォルダは、ファイルリストの取得と同じDCIMフォルダを指定します。 FSViewController.m [Part 2] // Make url NSURL *url101 = [NSURL URLWithString:@&quot;http://flashair/command.cgi?op=101&amp;DIR=/DCIM&quot;]; // Run cgi NSString *cntStr = [NSString stringWithContentsOfURL:url101 encoding:NSUTF8StringEncoding error:&amp;error]; if ([error.domain isEqualToString:NSCocoaErrorDomain]) { NSLog(@&quot;error101 %@ n&quot;,error); return; } // Display results self.labelCount.text =[@&quot;Count=&quot; stringByAppendingString:cntStr]; } 2-3行目使用するURLです。op=101&amp;DIR=/DCIMを設定します。 12行目返された文字列（ファイル数）を、labelCountに設定しています。 実行結果 プログラムが出来上がったら、確認をしてみましょう。 Get List をタップするとファイル数、ファイルリストが表示されます。 以上で、コンテンツリストの取得 に関する解説はおわりです。 サンプルコード ios_tutorial_02.zip (21KB) このサイトのサンプルコードは二条項BSDライセンスで提供されています。",
    "url": "http://localhost:4000/docs/tutorials/ios/2.html",
    "relUrl": "/docs/tutorials/ios/2.html"
  },
  "12": {
    "id": "12",
    "title": "コンテンツリストの取得",
    "content": "コンテンツリストの取得 このチュートリアルではコンテンツリストの取得方法について学びます。 使用するCGIは command.cgi です。 GetList ボタンをクリック（タップ）すると、FlashAirの現在のコンテンツがリストに表示されるように作成します。 このようにレイアウトを設定します: 重要: Android application は、デフォルトの状態ではインターネットにアクセスすることができません。 そのため、設定ファイル AndroidManifest.xml を変更し、権限を与える必要があります。 パス: [Project_Folder]/AndroidManifest.xml AndroidManifest.xml に以下のコードを追加してください: &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt; ここでは、説明のために _AndroidManifest.xml_の内容を記していますが、追加は Permissionsタブの画面から行うようにしてください。 ではまず、 activity_main.xml を記述して、レイアウトを決定します。 このファイルは、layout フォルダに配置されています。 パス: [Project_Folder]/res/layout/activity_main.xml レイアウトの作成 Button を１つと、 TextView を２つ設定します。 TextView の text要素 には、デフォルト値を設定しておきます。 FlashAir のコンテンツを取得したら内容を置き換えます。 activity_main.xml に以下のように記述してください: activity_main.xml &lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:paddingBottom=&quot;@dimen/activity_vertical_margin&quot; android:paddingLeft=&quot;@dimen/activity_horizontal_margin&quot; android:paddingRight=&quot;@dimen/activity_horizontal_margin&quot; android:paddingTop=&quot;@dimen/activity_vertical_margin&quot; android:orientation=&quot;vertical&quot; tools:context=&quot;.MainActivity&quot; &gt; &lt;Button android:id=&quot;@+id/button1&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:cacheColorHint=&quot;#00000000&quot; android:text=&quot;Get List&quot; android:textColor=&quot;@android:color/white&quot; android:textSize=&quot;20sp&quot; /&gt; &lt;TextView android:id=&quot;@+id/textView0&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:gravity=&quot;center_horizontal&quot; android:scaleType=&quot;centerInside&quot; android:text=&quot;# of items will be here&quot; android:textAlignment=&quot;center&quot; android:textAppearance=&quot;?android:attr/textAppearanceLarge&quot; android:textSize=&quot;20sp&quot; /&gt; &lt;TextView android:id=&quot;@+id/textView1&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;fill_parent&quot; android:text=&quot;List of contents will be here&quot; android:textAppearance=&quot;?android:attr/textAppearanceLarge&quot; android:textSize=&quot;20sp&quot; /&gt; &lt;/LinearLayout&gt; コンテンツリストの作成 次に、 MainActivity.java を修正します。自動生成された直後は、このように記述されています: MainActivity.java import android.os.Bundle; import android.app.Activity; import android.view.Menu; public class MainActivity extends Activity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); } @Override public boolean onCreateOptionsMenu(Menu menu) { // Inflate the menu; this adds items to the action bar if it is present getMenuInflater().inflate(R.menu.main, menu); return true; } } 初期化 ボタンがクリックされた場合の処理を行うため、OnClickListenerインターフェースをクラス宣言に追加します。 以降、必要になったImport文は、適宜追加してください。 MainActivity.java (1) public class MainActivity extends Activity implements OnClickListener { ボタンの定義 onCreate(Bundle savedInstanceState) を編集します。 Buttonがクリックされたらコンテンツリストを取得するように、以下のように設定します: MainActivity.java (2) @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button button = (Button)findViewById(R.id.button1); getWindow().setTitleColor(Color.rgb(65, 183, 216)); button.getBackground().setColorFilter(Color.rgb(65, 183, 216), PorterDuff.Mode.SRC_IN); button.setOnClickListener(this); } onCreateOptionsMenu(Menu menu) の関数はそのまま残します: MainActivity.java (3) @Override public boolean onCreateOptionsMenu(Menu menu) { // Inflate the menu; this adds items to the action bar if it is present getMenuInflater().inflate(R.menu.main, menu); return true; } ファイル数の取得・表示 前の手順で作成したクリックリスナーを Buttonに設定し、 Buttonがタップされた際に、ファイル数とファイルリストを取得し表示するようにします。 ファイル数を取得するためには、以下のコマンドを使用します。 ファイル数は、command.cgiにop=101 とフォルダパスを指定することで取得できます。 コマンド: http://flashair/command.cgi?op=101&amp;DIR=/DCIM コマンドが返す情報: &lt;NumberofItems&gt; コマンドの実行には、URLConnectionを使用しています。 URLConnectionを使用する一連の処理は、 FlashAirRequest.java にまとめます。 CGIコマンドを実行し結果の文字列を返す、 getString()を作成します。 FlashAirRequest.java public class FlashAirRequest { static public String getString(String command) { String result = &quot;&quot;; try{ URL url = new URL(command); URLConnection urlCon = url.openConnection(); urlCon.connect(); InputStream inputStream = urlCon.getInputStream(); BufferedReader bufreader = new BufferedReader(new InputStreamReader(inputStream, &quot;UTF-8&quot;)); StringBuffer strbuf = new StringBuffer(); String str; while ((str = bufreader.readLine()) != null) { if(strbuf.toString() != &quot;&quot;) strbuf.append(&quot; n&quot;); strbuf.append(str); } result = strbuf.toString(); }catch(MalformedURLException e) { Log.e(&quot;ERROR&quot;, &quot;ERROR: &quot; + e.toString()); e.printStackTrace(); } catch(IOException e) { Log.e(&quot;ERROR&quot;, &quot;ERROR: &quot; + e.toString()); e.printStackTrace(); } return result; } } 次に、 FlashAirRequest.java を使用する側の処理を作成します。 UIが長い間操作を受け付けない状態にならない（ブロックしない）よう、通信処理は AsyncTaskを使用して別スレッドで行います。 MainActivity.java (4) @Override public void onClick(View view) { switch ( view.getId() ) { case R.id.button1 : // Fetch number of items in directory and display in a TextView new AsyncTask&lt;String, Void, String&gt;(){ @Override protected String doInBackground(String... params) { return FlashAirRequest.getString(params[0]); } @Override protected void onPostExecute(String fileCount) { TextView textView = (TextView)findViewById(R.id.textView0); textView.setText(&quot;Items Found: &quot; + fileCount); } }.execute(&quot;http://flashair/command.cgi?op=101&amp;DIR=/DCIM&quot;); 9行目 FlashAirRequest.java に実装したgetString()を使用してCGIコマンドを実行し、その結果を返しています。 13-14行目 doInBackground()の戻り値をonPostExecute()で受け取り、前の手順で設定した_activity_main.xml_ のTextView のうちの１つ目にファイル数を表示しています。 ファイルリストの取得・表示 ファイルリストを取得するためには、以下のコマンドを使用します。 ファイルリストは、command.cgi にop=100 とフォルダパスを指定することで取得できます。 コマンド: http://flashair/command.cgi?op=100&amp;DIR=/DCIM コマンドが返す情報:&lt;Directory&gt;,&lt;Filename&gt;,&lt;Size&gt;,&lt;Attribute&gt;,&lt;Date&gt;,&lt;Time&gt; 同じく、作成した FlashAirRequest.java を使用してコマンドを実行します。 MainActivity.java (5) // Get a file list from FlashAir new AsyncTask&lt;String, Void, String&gt;(){ @Override protected String doInBackground(String... params) { return FlashAirRequest.getString(params[0]); } @Override protected void onPostExecute(String text) { TextView textView1 = (TextView)findViewById(R.id.textView1); textView1.setText(text); } }.execute(&quot;http://flashair/command.cgi?op=100&amp;DIR=/DCIM&quot;); break; } } } // End MainActivity class 5行目 FlashAirRequest.java に実装したgetString()を使用してCGIコマンドを実行し、その結果を返しています。 9-10行目 doInBackgroundの戻り値をonPostExecute()で受け取り、前の手順で設定した_activity_main.xml_ のTextView のうちの2つ目にファイルリストを表示しています。 実行結果 command.cgi の op=100 は指定したフォルダの以下の情報を返します: &lt;Directory&gt;,&lt;Filename&gt;,&lt;Size&gt;,&lt;Attribute&gt;,&lt;Date&gt;,&lt;Time&gt; 作成したリストでは、コマンドが返す情報すべてを表示しています: サンプルコード android_tutorial_02.zip (528KB) このサイトのサンプルコードは二条項BSDライセンスで提供されています。",
    "url": "http://localhost:4000/docs/tutorials/android/2.html",
    "relUrl": "/docs/tutorials/android/2.html"
  },
  "13": {
    "id": "13",
    "title": "FlashAirへのアップロード",
    "content": "FlashAirへのアップロード 本チュートリアルでは、 upload.cgiを使用してCGI経由でFlashAirにファイルをアップロード（書き込み）する方法を解説します。 概要 画像などのファイルをFlashAirにアップロードするには upload.cgiを使用します。 このチュートリアルでは、 ウェブ向けチュートリアル / コンテンツリストの取得2 をベースとして、 ファイルをアップロードする方法を解説します。 jQueryも引き続き利用しています。 注意本機能を誤って使用すると、FlashAirのファイルシステムを破壊してデータを失う恐れがあります。 PCなどのSDメモリカードホスト機器はSDメモリカードの内容(FAT)をキャッシュしている場合がありますが、本CGIで行った変更をSDメモリカードホスト機器が認識する方法がありません。そのため、本CGIとSDメモリカードホスト機器から同時に変更を行うとFAT不整合が起こる可能性があります。CGIからの書き込み後は必ずカードをいったん抜いて再挿入するなどしてSDメモリカードホスト機器に再認識させてください。 事前準備 まず、アップロード手順を復習しておきましょう。 CONFIGファイルに、UPLOAD=1を書き込む FlashAirを再起動する FlashAirに無線LAN接続する WRITEPROTECTコマンドで、SDメモリカードホスト機器からの書き込みを禁止する UPDIRコマンドで、アップロード先フォルダを設定する FTIMEコマンドで、ファイルの作成日時を設定する upload.cgiにファイルをPOSTし、ファイルをアップロードする 以下、3番までが完了しているものとして解説していきます。 画面レイアウトの作成 ブラウザユーティリティ本体となるHTMLファイルを作成します。 コンテンツリストの取得1に、 アップロードするファイルを選択するためのテキストボックスおよびファイル選択画面を開くボタンと、 アップロード実行を指示するボタンを追加しています。 /SD_WLAN/List.htm (抜粋) upload&lt;br&gt; &lt;input type=&quot;file&quot; id=&#39;file&#39; name=&#39;file&#39;&gt;&lt;br&gt; &lt;button id=&quot;cmdUpload&quot;&gt;Upload&lt;/button&gt; コードの作成 ファイルをアップロードするには、upload.cgiに対してPOSTコマンドを発行し、 ファイル名とファイル本体を、マルチパート・フォームデータ形式で送信します。 今回は、フォームデータの作成に、XMLHttpRequest Level 2 (XHR2) のFormDataオブジェクトを利用します。 また、データを送る前に、書き込み禁止設定、アップロード先フォルダの設定、ファイルの日時の設定を行っておきます。 今回は、アップロード先フォルダとして現在表示されているフォルダを、日付には現在の日時を使用します。 V1: ファームウェア1.0系では長いファイル名のファイルを送ると、短い名前に変更されます。 送信が終わったら、ファイルリストを読み込み直して、ファイルがアップロードされたことがわかるようにしてみましょう。 実際に見ていきましょう。 main.jsにアップロードを行う関数を作成し追加します。 /SD_WLAN/js/main.js (抜粋) //UploadProcess function doUpload() { var path = makePath(&quot;.&quot;); var cgi = &quot;/upload.cgi&quot;; var timestring; var dt = new Date(); var year = (dt.getFullYear() - 1980) &lt;&lt; 9; var month = (dt.getMonth() + 1) &lt;&lt; 5; var date = dt.getDate(); var hours = dt.getHours() &lt;&lt; 11; var minites = dt.getMinutes() &lt;&lt; 5; var seconds = Math.floor(dt.getSeconds() / 2); timestring = &quot;0x&quot; + (year + month + date).toString(16) + (hours + minites + seconds).toString(16); $.get(cgi + &quot;?WRITEPROTECT=ON&amp;UPDIR=&quot; + path + &quot;&amp;FTIME=&quot; + timestring, function() { var uploadFile = $(&#39;#file&#39;)[0].files[0]; var fd = new FormData(); fd.append(&quot;file&quot;, uploadFile); $.ajax({ url: cgi, type: &quot;POST&quot;, data: fd, processData: false, contentType: false, success: function(html){ if ( html.indexOf(&quot;SUCCESS&quot;) ) { alert(&quot;success&quot;); getFileList(&quot;.&quot;); }else{ alert(&quot;error&quot;); } } }); }); return false; } 6行目-13行目 ファイルの日付を作成しています。 日付、時刻をそれぞれ16ビットの16進数として作成し、合わせて32ビットの1つの値として渡します。 詳しくはAPIガイド / upload.cgiを参照してください。 14行目 書き込み禁止と保存先フォルダ、ファイル日時の各パラメータを設定しています。 ファイル本体の送信がパラメータの送信完了前に行われないように、設定が成功した場合のコールバック関数の中で行います。 15-17行目 マルチパート・フォームデータ形式のデータを作成している部分です。 ファイル選択用テキストボックスからファイル名を読み取り、FormDataに設定しています。 18-31行目 データをPOSTする部分です。processData(21行目)は、FormDataの内容がURLクエリ文字列として展開されてしまうのを避けるため、falseにする必要があります。contentType(22行目)は、falseを与えておくとFormDataから読み取って自動的に適切に設定されます。 詳細はjQueryのドキュメントを参照してください） 23-30行目 ファイル本体の送信が成功すると、コールバック関数が呼ばれてフォルダのファイルリストを再読み込みします。 Document Readyメソッドに、送信開始ボタンをクリックした時のイベントを登録する処理を追加します。 /SD_WLAN/js/main.js (抜粋) $(&quot;#cmdUpload&quot;).click(function(e) { doUpload(); return false; }); 実行結果 コードをFlashAirに置いたら、FlashAirに無線LAN接続したPCまたはスマートフォンのブラウザで確認してみましょう。 例えば、以下のような画面が表示されるでしょう。 サンプルコード advanced_tutorial_02.zip (4KB) このサイトのサンプルコードは二条項BSDライセンスで提供されています。 使用上の注意 重要 アクセス制限不備の脆弱性について アップロード機能とインターネット同時接続機能が同時に有効な場合、FlashAirに記録されているファイルやデータを改ざんされたり、任意の Lua スクリプトを実行されたりする可能性があります。 インターネット同時接続機能を同時に有効にする場合は、ウェブサーバへの接続時に認証を要求するよう、下記のCONFIGパラメータを設定してください。 HTTPDMODE — 認証方法 HTTPDUSER — Basic認証のユーザ名 HTTPDPASS — Basic認証のパスワード、Digest認証のハッシュ値 脆弱性に関してはFAQもあわせて参照ください。",
    "url": "http://localhost:4000/docs/tutorials/advanced/2.html",
    "relUrl": "/docs/tutorials/advanced/2.html"
  },
  "14": {
    "id": "14",
    "title": "FlashAirでLuaを実行する",
    "content": "FlashAirでLuaを実行する このチュートリアルでは、 基本的なスクリプトの実行方法をみていきます。 Luaスクリプトの実行方法には下記の3種類があります。 FlashAir起動時に実行する FlashAirへのファイル書き込み時に実行する FlashAirへのHTTPアクセス時に実行する それではさっそく”Hello World”プログラムを実行してみましょう。まずは簡単なluaスクリプトを作成しておきます。 /HelloWorld.lua print(&quot;Hello World!&quot;) local file = io.open(&quot;Hello.txt&quot;, &quot;a&quot;) file:write(&quot;Hello There! n&quot;) file:close() このスクリプトは、 Hello World! と出力し、 Hello.txtファイルに、 Hello There! という文字列を追加します。 FlashAir起動時に実行する 作成したLuaスクリプトをFlashAirのルートフォルダに保存します。 /SD_WLAN/CONFIGファイルに、LUA_RUN_SCRIPTパラメータを追加します。スクリプトのファイルパスを指定します。引数には、スクリプトのファイルパスを絶対パスで指定します。 LUA_RUN_SCRIPT=/HelloWorld.lua FlashAirをSDメモリカードスロットから一旦取り出し、再度挿入します。 以降、起動５秒後に指定したLuaスクリプトが実行されます。 FlashAirをSDメモリカードスロットから一旦取り出し、再度挿入後、Hello.txtファイルを開きます。 Hello.txtファイルに、 Hello There! という文字列が表示されます。 FlashAirへのファイル書き込み時に実行する 作成したLuaスクリプトをFlashAirのルートフォルダに保存します。 /SD_WLAN/CONFIGファイルに、LUA_SD_EVENTパラメータを追加します。スクリプトのファイルパスを指定します。引数には、スクリプトのファイルパスを絶対パスで指定します。 LUA_SD_EVENT=/HelloWorld.lua FlashAirをSDメモリカードスロットから一旦取り出し、再度挿入します。 以降、SDメモリカードの書き込みが発生した場合に指定したLuaスクリプトが実行されます。ファイルをFlashAirにコピーしたり、FlashAirに保存されたファイルを編集してみましょう。 FlashAirをSDメモリカードスロットから一旦取り出し、再度挿入後、Hello.txtファイルを開きます。 Hello.txtファイルに、 Hello There! という文字列が表示されます。すでに実行済みの場合は、文字列が追加されます。 LUA_RUN_SCRIPTとLUA_SD_EVENTを併用する LUA_RUN_SCRIPTとLUA_SD_EVENTを併用することができます。LUA_RUN_SCRIPTの動作が終了するまでLUA_SD_EVENTは無視されます。LUA_RUN_SCRIPTが実行終了した後LUA_SD_EVENTが実行可能になります。 LUA_RUN_SCRIPTはFlashAirへの電源投入の5秒後に実行されます。LUA_SD_EVENTはデータの書き込み終了後500ms後に実行されます。 FlashAirへのHTTPアクセス時に実行する HTTPリクエストに対する応答を標準出力に書き込むLuaスクリプトを作成します。出力にはHTTPレスポンスヘッダも含む必要があります。 作成したLuaスクリプトをFlashAirのルートフォルダに保存します。 FlashAirに無線LANで接続したPCのブラウザなどのクライアントプログラムから、スクリプトのファイルパスを指定します。 http://flashair/HelloWorld.lua スクリプトの標準出力がブラウザの画面に表示されます。 Hello.txtファイルに、 Hello There! という文字列が表示されます。すでに実行済みの場合は、文字列が追加されます。 サンプルコード リポジトリを見る（GitHub） このサイトのサンプルコードは二条項BSDライセンスで提供されています。",
    "url": "http://localhost:4000/docs/tutorials/lua/2.html",
    "relUrl": "/docs/tutorials/lua/2.html"
  },
  "15": {
    "id": "15",
    "title": "APIリファレンス",
    "content": "APIリファレンス WLAN APIs コマンドID コマンド名 機能 0x0001 iSDIO_WLAN_Scan 接続可能な無線LANの探索をします。 0x0002 iSDIO_WLAN_Connect ステーションとしての無線LANの接続をします。 0x0003 iSDIO_WLAN_Establish アクセスポイントとしての無線LAN接続の確立をします。 0x0005 iSDIO_WLAN_StartWPS ステーションとしてのWPSによる無線LAN接続設定の開始をします。 0x0007 iSDIO_WLAN_Disconnect 無線LANを切断します。 Common APIs コマンドID コマンド名 機能 0x0011 iSDIO_WLAN_SetCurrentTime FlashAirの日時設定を行います。 0x0015 iSDIO_WLAN_SetChannel アクセスポイントのチャンネル番号の設定を行います。 Server Upload APIs コマンド名 機能 iSDIO_WLAN_Request 各HTTPメッセージの送信を行います。 Original APIs コマンドID コマンド名 機能 0xE200 iSDIO_WLAN_Bridge ブリッジモードを起動します。 0xE201 iSDIO_WLAN_BridgeGetByRegister ブリッジモード情報を取得します。 Other APIs コマンド名 機能 iSDIO_WLAN_GetSSIDs アクセスポイント数を取得します。 iSDIO_WLAN_GetSSID アクセスポイント名を取得します。 iSDIO_WLAN_GetStatusData Status Registerの出力データを取得します。 iSDIO_WLAN_GetResponseData Response Data Register Portの出力データを取得します。 iSDIO_WLAN_GetVersion バージョン情報を取得します。 iSDIO_WLAN_SetWaitResponseTime Response待機のタイムアウト値を変更します。 iSDIO_WLAN_Check_WLANConnect WLAN接続をチェックします。 iSDIO_WLAN_Check_WLAN WLANのOn/Off状態をチェックします。 iSDIO_WLAN_Get_WLAN_Status Status Registerの”WLAN”データを取得します。 共有メモリ コマンド名 機能 iSDIO_WLAN_ReadSharedMemory Shared Memoryを読み込みます。 iSDIO_WLAN_WriteSharedMemory Shared Memoryへ書き込みます。 iSDIO_WLAN_GetFlashAirVersion CIDからFlashAirのバージョンと容量確認を行います。 iSDIO_WLAN_Scan 接続可能な無線LANを探索します。探索した結果はレスポンス取得を行う必要があります。 書式 int32_t iSDIO_WLAN_Scan( iSDIO_INFO_t *info, uint32_t seq_id ) 引数 [in] *info iSDIOカード制御情報へのポインタ [in] seq_id iSDIOコマンドシーケンスID 戻り値 E_iSDIO_OK 正常終了 その他 エラー発生 コマンドID 0x0001 iSDIO_WLAN_Connect ステーションとして指定されたアクセスポイントのSSID、ネットワークキーで無線LANを接続します。 書式 int32_t iSDIO_WLAN_Connect( iSDIO_INFO_t *info, uint32_t seq_id, uint8_t *ssid, uint16_t ssid_size, uint8_t *ntwk_key, uint32_t ntwk_key_size ) 引数 [in] *info iSDIOカード制御情報へのポインタ [in] seq_id iSDIOコマンドシーケンスID [in] *ssid 接続先アクセスポイントのSSID （最大32byte） [in] ssid_size 接続先アクセスポイントのSSIDのバイト数 [in] *ntwk_key ネットワークキー （最大64byte） [in] ntwk_key_size ネットワークキーのバイト数（0の場合は暗号化なし） 戻り値 E_iSDIO_OK 正常終了 E_iSDIO_INVALID_PARAM 不正パラメータ E_iSDIO_CMD_BUF_OVERFLOW コマンドバッファ不足 E_iSDIO_TIMEOUT タイムアウト発生 E_iSDIO_DEVICE_ERROR デバイスエラー E_iSDIO_UNKNOWN_ERROR 不明なエラー コマンドID 0x0002 iSDIO_WLAN_Establish アクセスポイントとして指定されたアクセスポイントのSSID、ネットワークキーで無線LAN接続を確立します。 書式 int32_t iSDIO_WLAN_Establish( iSDIO_INFO_t *info, uint32_t seq_id, uint8_t *ssid, uint16_t ssid_size, uint8_t *ntwk_key, uint32_t ntwk_key_size, iSDIO_WLAN_EcnMode_t encMode ) 引数 [in] *info iSDIOカード制御情報へのポインタ [in] seq_id iSDIOコマンドシーケンスID [in] *ssid 接続先アクセスポイントのSSID （最大32byte） [in] ssid_size 接続先アクセスポイントのSSIDのバイト数 [in] *ntwk_key ネットワークキー （最大64byte） [in] ntwk_key_size ネットワークキーのバイト数（0の場合は暗号化なし） [in] encMod 暗号モード iSDIO_WLAN_ENCMODE_NO_ENCRYPTION = 0x00 暗号化なし iSDIO_WLAN_ENCMODE_OPEN_SYSTEM_AND_WEP = 0x01 Open System and WEP iSDIO_WLAN_ENCMODE_SHARED_KEY_AND_WEP = 0x02 Shared Key and WEP iSDIO_WLAN_ENCMODE_WPA_PSK_AND_TKIP = 0x03 WPA-PSK and TKIP iSDIO_WLAN_ENCMODE_WPA_PSK_AND_AES = 0x04 WPA-PSK and AES iSDIO_WLAN_ENCMODE_WPA2_PSK_AND_TKIP = 0x05 WPA2-PSK and TKIP iSDIO_WLAN_ENCMODE_WPA2_PSK_AND_AES = 0x06 WPA2-PSK and AES 戻り値 E_iSDIO_OK 正常終了 E_iSDIO_INVALID_PARAM 不正パラメータ E_iSDIO_CMD_BUF_OVERFLOW コマンドバッファ不足 E_iSDIO_TIMEOUT タイムアウト発生 E_iSDIO_DEVICE_ERROR デバイスエラー E_iSDIO_UNKNOWN_ERROR 不明なエラー コマンドID 0x0003 iSDIO_WLAN_StartWPS ステーションとして、WPSによる無線LAN接続設定を開始します。 書式 int32_t iSDIO_WLAN_StartWPS( iSDIO_INFO_t *info, uint32_t seq_id, uint8_t *ssid, uint16_t ssid_size, iSDIO_WLAN_WPSMode_t wpsMode, uint8_t *pin, uint32_t pin_size ) 引数 [in] *info iSDIOカード制御情報へのポインタ [in] seq_id iSDIOコマンドシーケンスID [in] *ssid 接続先アクセスポイントのSSID （最大32byte） [in] ssid_size 接続先アクセスポイントのSSIDのバイト数 [in] wpsMode WPSモード iSDIO_WLAN_WPSMODE_WITH_PIN = 0x01 WPS with PIN iSDIO_WLAN_WPSMODE_WITH_PBC = 0x02 WPS with PBX [in] *pin PINコード （最大byte） [in] pin_size PINコードのバイト数 戻り値 E_iSDIO_OK 正常終了 E_iSDIO_INVALID_PARAM 不正パラメータ E_iSDIO_CMD_BUF_OVERFLOW コマンドバッファ不足 E_iSDIO_TIMEOUT タイムアウト発生 E_iSDIO_DEVICE_ERROR デバイスエラー E_iSDIO_UNKNOWN_ERROR 不明なエラー コマンドID 0x0005 注意点 wpsModeでiSDIO_WLAN_WPSMODE_WITH_PBCを指定する場合、ssid, pinにはNULL、ssid_size, pin_sizeには0を指定してください。 iSDIO_WLAN_Disconnect 無線LANを切断します。 書式 int32_t iSDIO_WLAN_Disconnect( iSDIO_INFO_t *info, uint32_t seq_id ) 引数 [in] *info iSDIOカード制御情報へのポインタ [in] seq_id iSDIOコマンドシーケンスID 戻り値 E_iSDIO_OK 正常終了 その他 エラー発生 コマンドID 0x0007 iSDIO_WLAN_SetCurrentTime FlashAirの日時設定を行います。 書式 int32_t iSDIO_WLAN_SetCurrentTime( iSDIO_INFO_t *info, uint32_t seq_id, iSDIO_WLAN_Date_t currentDate, iSDIO_WLAN_Time_t currentTime ) 引数 [in] *info iSDIOカード制御情報へのポインタ [in] seq_id iSDIOコマンドシーケンスID [in] currentDate 日付 typedef struct iSDIO_WLAN_Date_s { uint16_t day:5; //!&lt; 日 uint16_t month:4; //!&lt; 月 uint16_t year:7; //!&lt; 年(1980年からの経過年) } iSDIO_WLAN_Date_t; [in] currentTime 時間 typedef struct iSDIO_WLAN_Time_s { uint16_t second:5; //!&lt; 秒 uint16_t minute:6; //!&lt; 分 uint16_t hour:5; //!&lt; 時 } iSDIO_WLAN_Time_t; 戻り値 E_iSDIO_OK 正常終了 その他 エラー発生 コマンドID 0x0011 iSDIO_WLAN_SetChannel アクセスポイントのチャンネル番号の設定を行います。FlashAirが一部のチャンネルをサポートしていない場合、このコマンドは拒否されます。 Capability Registerの”Channel Support”を確認する必要があります。 iSDIO Capability Register for Wireless LANを参照してください。 書式 int32_t iSDIO_WLAN_SetChannel( iSDIO_INFO_t *info, uint32_t seq_id, uint8_t ch ) 引数 [in] *info iSDIOカード制御情報へのポインタ [in] seq_id iSDIOコマンドシーケンスID [in] ch チャンネル番号 0x00 自動 0x01 チャンネル1 … 0x0E チャンネル14 0x24 チャンネル36 … 0xA1 チャンネル161 戻り値 E_iSDIO_OK 正常終了 その他 エラー発生 コマンドID 0x0015 iSDIO_WLAN_Request 指定されたパラメータによって、各HTTPメッセージの送信を行います。 書式 int32_t iSDIO_WLAN_Request( iSDIO_INFO_t *info, uint32_t seq_id, iSDIO_WLAN_httpType_t host_type, uint8_t *hostname, uint32_t hostname_size, iSDIO_WLAN_MessageType_t msg_type, uint8_t *message, uint32_t message_size, uint8_t *apnd_filename, uint32_t apnd_filename_size, iSDIO_WLAN_HeaderRemoval_t headerRemoval ) 引数 [in] *info iSDIOカード制御情報へのポインタ [in] seq_id iSDIOコマンドシーケンスID [in] host_type ホストタイプ HTTP通信 iSDIO_WLAN_HTTP(0x00) HTTPS通信 iSDIO_WLAN_HTTPSSL [in] *hostname ホスト名 host_typeがHTTP通信の場合は、HTTPリクエストメッセージが送信されHTTPレスポンスメッセージを受信するホスト名を意味します。 プロキシサーバが使用される場合を除いて、ポート番号は80が使われます。 host_typeがHTTPS通信の場合は、SSL経由でHTTPメッセージをリクエストする以外は、HTTP通信と同じです。 プロキシサーバが使用される場合を除いて、ポート番号は443が使われます。 [in] hostname_size ホスト名のバイト数 [in] msg_type メッセージタイプ レジスタから読み出し iSDIO_WLAN_MSG_REGISTER(0x00) ファイルから読み出し iSDIO_WLAN_MSG_FILE(0x01) [in] *message メッセージ(ファイル名) HTTPリクエストラインとHTTPメッセージヘッダー、HTTPメッセージボディで構成されるHTTPリクエストメッセージを意味します。 メッセージの格納先はレジスタまたはファイルから取得するので、msg_typeで格納場所を指定します。 レジスタ指定の場合は格納先のアドレスを指定、ファイル指定の場合は、ファイル格納先のパスとファイル名を指定します。 [in] message_size メッセージ(ファイル名)のバイト数 [in] *apnd_filename 添付ファイル名 [in] apnd_filename_size 添付ファイル名のバイト数 [in] headerRemoval ヘッダ付加情報 HTTPヘッダ有り iSDIO_WLAN_WITH_HEADER(0x00) HTTPヘッダ無し iSDIO_WLAN_ONLY_BODY(0x01) 戻り値 E_iSDIO_OK 正常終了 その他 エラー発生 備考 指定されたパラメータによって、各HTTPメッセージの送信を行います。パラメータは下記の組み合わせのみ有効です。 レジスタから読み込んだHTTPメッセージを送信 (処理詳細はiSDIO_WLAN_SendHTTPMessageByRegisterを参照) host_type iSDIO_WLAN_HTTP *hostname ホスト名が格納されているバッファの先頭アドレス hostname_size ホスト名のデータ長 msg_type iSDIO_WLAN_MSG_REGISTER *message メッセージが格納されているバッファの先頭アドレス message_size メッセージデータ長 *apnd_filename NULL apnd_filename_size 0 headerRemoval 設定不要 レジスタから読み込んだHTTPメッセージをファイル付きで送信 (処理詳細はiSDIO_WLAN_SendHTTPFileByRegisterを参照) host_type iSDIO_WLAN_HTTP *hostname ホスト名が格納されているバッファの先頭アドレス hostname_size ホスト名のデータ長 msg_type iSDIO_WLAN_MSG_REGISTER *message メッセージが格納されているバッファの先頭アドレス message_size メッセージデータ長 *apnd_filename サーバに送信するファイルのパス apnd_filename_size apnd_filenameのデータ長 headerRemoval 設定不要 SSLありで、レジスタから読み込んだHTTPメッセージを送信 (処理詳細はiSDIO_WLAN_SendHTTPSSLMessageByRegisterを参照) host_type iSDIO_WLAN_HTTPSSL *hostname ホスト名が格納されているバッファの先頭アドレス hostname_size ホスト名のデータ長 msg_type iSDIO_WLAN_MSG_REGISTER *message メッセージが格納されているバッファの先頭アドレス message_size メッセージデータ長 *apnd_filename NULL apnd_filename_size 0 headerRemoval 設定不要 SSLありで、レジスタから読み込んだHTTPメッセージをファイル付きで送信 (処理詳細はiSDIO_WLAN_SendHTTPSSLFileByRegisterを参照) host_type iSDIO_WLAN_HTTPSSL *hostname ホスト名が格納されているバッファの先頭アドレス hostname_size ホスト名のデータ長 msg_type iSDIO_WLAN_MSG_REGISTER *message メッセージが格納されているバッファの先頭アドレス message_size メッセージデータ長 *apnd_filename サーバに送信するファイルのパス apnd_filename_size apnd_filenameのデータ長 headerRemoval 設定不要 ファイルから読み込んだHTTPメッセージを送信 (処理詳細はiSDIO_WLAN_SendHTTPMessageByFileを参照) host_type iSDIO_WLAN_HTTP *hostname ホスト名が格納されているバッファの先頭アドレス hostname_size ホスト名のデータ長 msg_type iSDIO_WLAN_MSG_FILE *message 送信メッセージファイルのパス message_size パスのデータ長 *apnd_filename NULL apnd_filename_size 0 headerRemoval iSDIO_WLAN_WITH_HEADER or iSDIO_WLAN_ONLY_BODY ファイルから読み込んだHTTPメッセージをファイル付きで送信 (処理詳細はiSDIO_WLAN_SendHTTPFileByFileを参照) host_type iSDIO_WLAN_HTTP *hostname ホスト名が格納されているバッファの先頭アドレス hostname_size ホスト名のデータ長 msg_type iSDIO_WLAN_MSG_FILE *message 送信メッセージファイルのパス message_size パスのデータ長 *apnd_filename サーバに送信するファイルのパス apnd_filename_size apnd_filenameのデータ長 headerRemoval iSDIO_WLAN_WITH_HEADER or iSDIO_WLAN_ONLY_BODY SSLありで、ファイルから読み込んだHTTPメッセージを送信 (処理詳細はiSDIO_WLAN_SendHTTPSSLMessageByFileを参照) host_type iSDIO_WLAN_HTTPSSL *hostname ホスト名が格納されているバッファの先頭アドレス hostname_size ホスト名のデータ長 msg_type iSDIO_WLAN_MSG_FILE *message 送信メッセージファイルのパス情報 message_size パスのデータ長 *apnd_filename NULL apnd_filename_size 0 headerRemoval iSDIO_WLAN_WITH_HEADER or iSDIO_WLAN_ONLY_BODY SSLありで、ファイルから読み込んだHTTPメッセージをファイル付きで送信 (処理詳細はiSDIO_WLAN_SendHTTPSSLFileByFileを参照) host_type iSDIO_WLAN_HTTPSSL *hostname ホスト名が格納されているバッファの先頭アドレス hostname_size ホスト名のデータ長 msg_type iSDIO_WLAN_MSG_FILE *message 送信メッセージファイルのパス情報 message_size パスのデータ長 *apnd_filename サーバに送信するファイルのパス apnd_filename_size apnd_filenameのデータ長 headerRemoval iSDIO_WLAN_WITH_HEADER or iSDIO_WLAN_ONLY_BODY 注意事項 SSLありの場合は、本API実行前にiSDIO_WLAN_SetCertificateまたはiSDIO_WLAN_SetCertificateByFileでルート認証を設定することを推奨します。 ルート認証を設定せずに本APIを実行した場合、ルート認証によるサーバ証明書を認証しないまま、FlashAirはコマンドを実行します。 iSDIO_WLAN_Bridge ブリッジモードを起動します。 brgssidで指定されたSTAに接続し、その後apssidを使用したAPを起動します。 書式 int32_t iSDIO_WLAN_Bridge( iSDIO_INFO_t *info, uint32_t seq_id, uint8_t *apssid, uint8_t *apnetworkKey, iSDIO_WLAN_EcnMode_t encMode, uint8_t *brgssid, uint8_t *brgnetworkKey ) 引数 [in] *info iSDIOカード制御情報へのポインタ [in] seq_id iSDIOコマンドシーケンスID [in] *apssid AirNetから接続するためのSSID （最大32byte） [in] *apnetworkKey AirNetから接続するためのネットワークキー（最大64byte） [in] encMode 暗号モード ブリッジモードでは、下記が設定値となります。 iSDIO_WLAN_ENCMODE_WPA_PSK_AND_TKIP(0x03) iSDIO_WLAN_ENCMODE_WPA2_PSK_AND_AES(0x06) [in] *brgssid TopNetへ接続するためのSSID（最大32byte） [in] *brgnetworkKey TopNetへ接続するためのネットワークキー（最大64byte） 戻り値 E_iSDIO_OK 正常終了 E_iSDIO_INVALID_PARAM 不正パラメータ E_iSDIO_CMD_BUF_OVERFLOW コマンドバッファ不足 E_iSDIO_TIMEOUT タイムアウト発生 E_iSDIO_DEVICE_ERROR デバイスエラー E_iSDIO_UNKNOWN_ERROR 不明なエラー コマンドID 0xE200 注意事項 BridgeはDisconnect状態でないと実行できません。 FlashAirが別の機器につながっている場合は、まずiSDIO_WLAN_Disconnectを実行してください。 Disconnect後、再度Bridgeを実行するには6秒後に実行してください。 iSDIO_WLAN_BridgeGetByRegister ブリッジモード情報を取得します。取得したブリッジモード情報はResponse Data Register Portの出力データに設定されます。 書式 int32_t iSDIO_WLAN_BridgeGetByRegister( iSDIO_INFO_t *info, uint32_t seq_id ) 引数 [in] *info iSDIOカード制御情報へのポインタ [in] seq_id iSDIOコマンドシーケンスID 戻り値 E_iSDIO_OK 正常終了 その他 エラー発生 コマンドID 0xE201 備考 ブリッジモード情報の構造は以下となります。 typedef struct iSDIO_WLAN_BridgeListItem_s { uint32_t status; uint8_t appssid[32+4]; uint8_t appnetworkKey[64+4]; uint8_t ipaddr[4]; uint8_t subnetMask[4]; uint8_t defGateWay[4]; uint8_t prefDnsServer[4]; uint8_t altDnsServer[4]; uint8_t brgssid[32+4]; uint8_t brgnetworkKey[64+4]; uint8_t brgIpaddr[4]; uint8_t brgsunetMask[4]; uint8_t brgdefGateWay[4]; uint8_t brgprefDnsServer[4]; uint8_t brgaltDnsServer[4]; } iSDIO_WLAN_BridgeListItem_t; 注意事項 本APIはブリッジモード情報をResponse Data Register Portに出力するためのものです。実際にブリッジモード情報を取得する場合はResponseData Register Portを読み出す必要があります。 iSDIO_WLAN_GetSSIDs Scanしたアクセスポイント数を取得します。 書式 int32_t iSDIO_WLAN_GetSSIDs( iSDIO_INFO_t *info, uint8_t *num ) 引数 [in] *info iSDIOカード制御情報へのポインタ [out] *num アクセスポイント数 iSDIO_WLAN_Scan実行時のアクセスポイント数が取得されます。 戻り値 E_iSDIO_OK 正常終了 注意事項 iSDIO_WLAN_Scanのレスポンス取得後に実行する必要があります。 それ以外の状態で実施してもアクセスポイント数は正しく取得できません。 iSDIO_WLAN_GetSSID Scanした指定番号に対応するアクセスポイント名を取得します。 書式 int32_t iSDIO_WLAN_GetSSID( iSDIO_INFO_t *info, uint8_t number, uint8_t *ssid ) 引数 [in] *info iSDIOカード制御情報へのポインタ [in] number 指定番号(有効範囲は0～(Max-1)) 指定番号オーバーの場合は、戻り値が不正パラメータとなります。 [out] *ssid アクセスポイント名を格納するバッファの先頭アドレス SSIDは最大32byteのため、最低32byteのバッファを準備してください。 iSDIO_WLAN_Scan実行時の指定番号のアクセスポイント名が取得されます。 戻り値 E_iSDIO_OK 正常終了 その他 エラー発生 注意事項 iSDIO_WLAN_Scanのレスポンス取得後に実行する必要があります。 それ以外の状態で実施してもアクセスポイント数は正しく取得できません。 iSDIO_WLAN_GetStatusData Status Registerの出力データを取得します。引数getbufで指定されたアドレスに現在のStatus Registerの情報が格納されます。 書式 int32_t iSDIO_WLAN_GetStatusData( iSDIO_INFO_t *info, uint8_t *getbuf ) 引数 [in] *info iSDIOカード制御情報へのポインタ [out] *getbuf 取得バッファポインタ StatusRegisterの出力データを格納するため512バイトのバッファが必要です。 戻り値 E_iSDIO_OK 正常終了 その他 エラー発生 iSDIO_WLAN_GetResponseData Response Data Register Portの出力データを取得します。引数getbufで指定されたアドレスに現在のResponse Data Register Portの情報が格納されます。 書式 int32_t iSDIO_WLAN_GetResponseData( iSDIO_INFO_t *info, uint8_t *getbuf ) 引数 [in] *info iSDIOカード制御情報へのポインタ [out] *getbuf 取得バッファポインタ Response Data Register Portの出力データを格納するため512byteのバッファが必要です。 戻り値 E_iSDIO_OK 正常終了 その他 エラー発生 iSDIO_WLAN_GetVersion Status Registerに格納されているバージョン情報(0x005f0-0x005ff)を読み出します。 書式 int32_t iSDIO_WLAN_GetVersion( iSDIO_INFO_t *info, uint8_t *getbuf ) 引数 [in] *info iSDIOカード制御情報へのポインタ [out] *getbuf 取得バッファポインタバージョン情報を格納するために16byteのバッファが必要です。 戻り値 E_iSDIO_OK 正常終了 その他 エラー発生 iSDIO_WLAN_SetWaitResponseTime Response待機のタイムアウト値を変更します。タイムアウト値はmsで設定します。 書式 void iSDIO_WLAN_SetWaitResponseTime( uint32_t time ) 引数 [in] time Response待機のタイムアウト値(ms) 戻り値 なし iSDIO_WLAN_Check_WLANConnect WLAN接続をチェックします。接続状態は、Status Registerの0506h(bit7)のConnectedで判断します。 書式 int32_t iSDIO_WLAN_Check_WLANConnect( iSDIO_INFO_t *info, iSDIO_WLAN_Connect_t *connect ) 引数 [in] *info iSDIOカード制御情報へのポインタ [out] connect 接続状態 WLAN接続状態 iSDIO_WLAN_CONNECTED(0x01) WLAN未接続状態 iSDIO_WLAN_NO_CONNECTION(0x00) 戻り値 E_iSDIO_OK 正常終了 その他 エラー発生 iSDIO_WLAN_Check_WLAN WLANのOn/Off状態をチェックします。接続状態は、Status Registerの0506h(bit6-5)のInfra-Directで判断します。 ※00:OFF、01/10:ON 書式 int32_t iSDIO_WLAN_Check_WLAN( iSDIO_INFO_t *info, iSDIO_WLAN_OnOFF_t *onoff ) 引数 [in] *info iSDIOカード制御情報へのポインタ [out] *onoff 無線LAN動作状態 WLAN On iSDIO_WLAN_ON(0x01) WLAN OFF iSDIO_WLAN_OFF(0x00) 戻り値 E_iSDIO_OK 正常終了 その他 エラー発生 iSDIO_WLAN_Get_WLAN_Status Status Registerの”WLAN”データを取得します。WLAN情報はStatus Registerの0506hを取得します。 書式 int32_t iSDIO_WLAN_Get_WLAN_Status( iSDIO_INFO_t *info, uint8_t *param ) 引数 [in] *info iSDIOカード制御情報へのポインタ [out] *param WLANデータ StatusRegisterのWLAN情報を格納するため1バイトのバッファが必要です。 戻り値 E_iSDIO_OK 正常終了 その他 エラー発生 iSDIO_WLAN_ReadSharedMemory Shared Memory（共有メモリ）からデータの読み込みを行います。 書式 int32_t iSDIO_WLAN_ReadSharedMemory( iSDIO_INFO_t *info, uint32_t addr, uint32_t len, uint8_t buf ) 引数 [in] *info iSDIOカード制御情報へのポインタ [in] addr 読み出しアドレス(0～2047) [in] len データ長（1～2048）byte [out] buf 読み出しデータ 戻り値 E_iSDIO_OK 正常終了 その他 エラー発生 iSDIO_WLAN_WriteSharedMemory Shared Memory（共有メモリ）へデータの書き込みを行います。 書式 int32_t iSDIO_WLAN_WriteSharedMemory( iSDIO_INFO_t *info, uint32_t addr, uint32_t len, uint8_t buf ) 引数 [in] *info iSDIOカード制御情報へのポインタ [in] addr 書き込みアドレス(0～2047) [in] len データ長（1～2048）byte [in] buf 書き込みデータ 戻り値 E_iSDIO_OK 正常終了 その他 エラー発生 iSDIO_WLAN_GetFlashAirVersion CIDからFlashAirのバージョンと容量確認を行います。 書式 int32_t iSDIO_WLAN_GetFlashAirVersion( iSDIO_INFO_t *info, uint8_t cardver, uint16_t cardsize ) 引数 [in] *info iSDIOカード制御情報へのポインタ [out] cardver カードバージョン [out] cardsize カード容量 戻り値 E_iSDIO_OK 正常終了 その他 エラー発生 備考 cardver、cardsizeとFlashAirのバージョンと容量の関係は以下の通りとなります。 cardver cardsize バージョンと容量 2 8 FlashAir W02 8G 2 16 FlashAir W02 16G 2 32 FlashAir W02 32G 3 8 FlashAir W03 8G 3 16 FlashAir W03 16G 3 32 FlashAir W03 32G 4 16 FlashAir W04 16G 4 32 FlashAir W04 32G 4 64 FlashAir W04 64G 255 0以外 バージョン不明でcardsize容量のFlashAir 255 0 バージョン、容量不明のFlashAir 0 0 FlashAirではない 注意 本関数はSDカードスロットが1スロットのシステムで、デバイスファイルが/dev/mmcblk0にある場合に使用可能です。",
    "url": "http://localhost:4000/docs/tutorials/raspberrypi/2.html",
    "relUrl": "/docs/tutorials/raspberrypi/2.html"
  },
  "16": {
    "id": "16",
    "title": "コンテンツリストの取得1",
    "content": "コンテンツリストの取得1 FlashAirに保存されたコンテンツのリストを取得する方法について学びます。 このチュートリアルでは、FlashAirのウェブサーバーから、HTMLに埋め込まれた形でリストを返す方法を使ってみましょう。 リストは、HTMLに埋め込まれたJavaScriptプログラムとして埋め込まれています。 画面に表示するにはそのデータを、別のJavaScriptでHTMLに加工する必要があります。 今回はjQueryを利用してJavaScriptのコード量を減らし、お手軽に作成しましょう。 コンテンツリストの埋め込み ブラウザのURL欄に、FlashAirのフォルダへのパスを入力すると、 FlashAirのウェブサーバーはHTML文書を返します。 このHTML文書は、SDメモリカードに保存されている /SD_WLAN/List.htmというファイルを元に生成されたものです。 このとき、 /SD_WLAN/List.htmにコメント文として埋め込まれた &lt;!--WLANSDJLST--&gt;が、 そのフォルダの内容を配列 wlansdに代入するJavaScriptのコードで置き換えられます。 http://flashair/ にアクセスした場合の結果は、例えば次のようになります。 置き換え前の /SD_WLAN/List.htmの一部 wlansd = new Array(); &lt;!--WLANSDJLST--&gt; 置き換え後 (ファームウェアバージョン1.xの場合) wlansd = new Array(); wlansd[0]=&quot;,DCIM,0,16,16602,18432&quot;; wlansd[1]=&quot;,FLASHAIR.EXE,7711563,32,16602,18432&quot;; wlansd[2]=&quot;,PRIVATE,0,16,17034,34163&quot;; 置き換え後 (ファームウェアバージョン2.0以上の場合) wlansd = new Array(); wlansd.push({&quot;r_uri&quot;:&quot;/&quot;, &quot;fname&quot;:&quot;DCIM&quot;, &quot;fsize:&quot;:0,&quot;attr&quot;:16,&quot;fdate&quot;:16602,&quot;ftime&quot;:18432}); wlansd.push({&quot;r_uri&quot;:&quot;/&quot;, &quot;fname&quot;:&quot;FLASHAIR.EXE&quot;, &quot;fsize:&quot;:7711563,&quot;attr&quot;:32,&quot;fdate&quot;:16602,&quot;ftime&quot;:18432}); wlansd.push({&quot;r_uri&quot;:&quot;/&quot;, &quot;fname&quot;:&quot;PRIVATE&quot;, &quot;fsize:&quot;:0,&quot;attr&quot;:16,&quot;fdate&quot;:17034,&quot;ftime&quot;:34163}); /SD_WLAN/List.htmに、このコメント文を含むJavaScriptのコードを挿入し、 ファイルのリストを表示させてみましょう。 事前準備 jQueryをダウンロードします。 ダウンロードしたファイルは jquery-x.yy.z,min.js（ x、 yy、 zには数字が入ります）というファイル名になっています。 しかし、FlashAirのファームウェアがバージョン1.00系の場合、長いファイル名を使用できませんので、 バージョン名部分を省略して短い名前に変更し、 /SD_WLAN/js/jquery.jsとして保存しましょう。 画面レイアウトの作成 ブラウザユーティリティ本体となるHTMLファイルを作成します。 画面に表示される要素はほとんどありませんが、重要な２つの仕事をしています。 １つは別のファイルとして作成されたJavaScriptをロードすること、 もう１つは、そのJavaScriptが画面要素を書き込むための &lt;div&gt;タグを用意することです。 作成したファイルは必ず、FlashAirの /SD_WLAN/List.htmに保存してください。 /SD_WLAN/List.htm &lt;!doctype html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;FlashAir&lt;/title&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;/SD_WLAN/js/jquery.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;/SD_WLAN/js/main.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; wlansd = new Array(); &lt;!--WLANSDJLST--&gt; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;header&quot;&gt; &lt;h1&gt;header&lt;/h1&gt; &lt;/div&gt; &lt;hr&gt; &lt;div id=&quot;list&quot;&gt; &lt;/div&gt; &lt;hr&gt; &lt;div id=&quot;footer&quot;&gt; footer &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 6,7行目 jquery.jsと、次に作成するmain.jsをロードしています。 9行目 配列を宣言し、10行目のコメント文で差し込まれる代入文に備えます。 18行目 listというid属性を持つdivタグを宣言しています。この中にフォルダのファイルリストが挿入されます。 コードの作成 差し込まれたフォルダリストを解析して、読みやすい形でHTMLに挿入する作業を、JavaScriptで記述します。 FlashAirのファームウェアバージョンによってデータの差し込み方法が異なるため、 バージョンを判定して、バージョン２の形式に統一するヘルパー関数( isV1()と convertFileList())を使用しています。 作成したファイルは好きな名前をつけて構いません。 本チュートリアルではFlashAirの /SD_WLAN/js/main.jsというファイルとして作成することにします。 /SD_WLAN/js/main.js // JavaScript Document // Judge the card is V1 or V2. function isV1(wlansd) { if ( wlansd.length == undefined || wlansd.length == 0 ) { // List is empty so the card version is not detectable. Assumes as V2. return false; } else if ( wlansd[0].length != undefined ) { // Each row in the list is array. V1. return true; } else { // Otherwise V2. return false; } } // Convert data format from V1 to V2. function convertFileList(wlansd) { for (var i = 0; i &lt; wlansd.length; i++) { var elements = wlansd[i].split(&quot;,&quot;); wlansd[i] = new Array(); wlansd[i][&quot;r_uri&quot;] = elements[0]; wlansd[i][&quot;fname&quot;] = elements[1]; wlansd[i][&quot;fsize&quot;] = Number(elements[2]); wlansd[i][&quot;attr&quot;] = Number(elements[3]); wlansd[i][&quot;fdate&quot;] = Number(elements[4]); wlansd[i][&quot;ftime&quot;] = Number(elements[5]); } } // Callback Function for sort() function cmptime(a, b) { if( a[&quot;fdate&quot;] == b[&quot;fdate&quot;] ) { return a[&quot;ftime&quot;] - b[&quot;ftime&quot;]; }else{ return a[&quot;fdate&quot;] - b[&quot;fdate&quot;]; } } // Show file list function showFileList(path) { // Clear box. $(&quot;#list&quot;).html(&#39;&#39;); // Output a link to the parent directory if it is not the root directory. if ( path != &quot;/&quot; ) { // Make parent path var parentpath = path; if ( parentpath[parentpath.length - 1] != &#39;/&#39; ) { parentpath += &#39;/&#39;; } parentpath += &#39;..&#39;; // Make a link to the parent path. $(&quot;#list&quot;).append( $(&quot;&lt;div&gt;&lt;/div&gt;&quot;).append( $(&#39;&lt;a href=&quot;&#39; + parentpath + &#39;&quot; class=&quot;dir&quot;&gt;..&lt;/a&gt;&#39;) ) ); } $.each(wlansd, function() { var file = this; // Skip hidden file. if( file[&quot;attr&quot;] &amp; 0x02 ) { return; } // Make a link to directories and files. var filelink = $(&#39;&lt;a&gt;&lt;/a&gt;&#39;).attr(&#39;href&#39;,file[&quot;r_uri&quot;]+&#39;/&#39;+file[&quot;fname&quot;]); var caption = file[&quot;fname&quot;]; var fileobj = $(&quot;&lt;div&gt;&lt;/div&gt;&quot;); // Append a file entry or directory to the end of the list. $(&quot;#list&quot;).append( fileobj.append( filelink.append( caption ) ) ); }); } // Document Ready $(function() { if ( isV1(wlansd) ) { convertFileList(wlansd); } wlansd.sort(cmptime); showFileList(location.pathname); }); 4-15行目 データ形式がV1かどうかを判定するヘルパー関数です。V1であればtrueを返します。 17-28行目 データ形式を、V1形式からV2形式に変換するヘルパー関数です。 30-36行目 データを日付と時間で整列するための関数です。 38-69行目 差し込まれたファイルリストの各行に対して、アンカー(&lt;a&gt;)とボックス(&lt;div&gt;)を生成し、 HTML中に用意した表示位置($(&quot;#list&quot;))に追加しています。 71-77行目 本ファイルが読み込まれたときに自動的に呼び出されて、処理を実行する部分です。 V1だった場合はデータ形式を変換し(72-74行目)、日付でリストをソートして(75行目)、 ファイルリストを表示する関数(76行目) を呼び出しています。 実行結果 コードをFlashAirに置いたら、FlashAirに無線LAN接続したPCまたはスマートフォンのブラウザで確認してみましょう。 例えば、以下のような画面が表示されるでしょう。 文字の大きさなどはCSSなどで工夫してみてください。 サンプルコード web_tutorial_02.zip (4KB) このサイトのサンプルコードは二条項BSDライセンスで提供されています。",
    "url": "http://localhost:4000/docs/tutorials/web/2.html",
    "relUrl": "/docs/tutorials/web/2.html"
  },
  "17": {
    "id": "17",
    "title": "iSDIO拡張コマンドの作成",
    "content": "iSDIO拡張コマンドの作成 本チュートリアルでは、FlashAirの操作に先立ち、 iSDIOのコマンドを発行するために必要なルーチンを作成していきます。 重要な改訂 (2014-09-29)： Sd2CardExt::readExt() 関数に、ダミーデータ送信を追加。 (2017-11-02)： Sd2CardExt::readExt() 関数に、CMD17使用方法を追加。 Sd2CardExt::writeExt() 関数に、CMD24使用方法を追加。 iSDIOコマンドについて iSDIO規格は、コマンドやりとりの手順を定めたプロトコルであり、 コマンドの発行自体は、SD規格の Function Extension Commands (class 11)に規定されている、 拡張レジスタの読み書きを行うコマンド CMD48 (READ_EXTR_SINGLE)および CMD49 (WRITE_EXTR_SINGLE)を利用します(*1)。 注意点: SDIO規格のCMD52、CMD53を利用する方法もありますが、本チュートリアルでは扱いません。 CMD48/49は、次のような３種類のモードがあります。 レジスタ: アドレスと長さで指定したメモリ領域に対する読み書き。ステータスなど小さなデータに利用。 データポート: 512バイト固定のメモリブロックに対する読み書き。データなど大きなデータに利用。 マスク書き込み (CMD49のみ): あるアドレスの1バイトの一部のビットの変更。ステータスリセットなどに利用。 どのモードを使えばよいかは、iSDIO Wireless LAN Simplified Addendumによって、 あるアドレス領域はレジスタモード、あるアドレス領域はデータポートモード、 などと定められており、それに従う必要があります。 ArduinoにCMD48/49を追加する Arduino IDEには、標準でSDメモリカードのライブラリが含まれています。 このライブラリは、大きく分けて以下のモジュールからなります。 SDメモリカードにSPIで通信するクラス(Sd2Card) SDメモリカードのFATファイルシステムにアクセスするクラス(SdFat) 上記をまとめてSDメモリカードのファイルを読み書きするクラス(SD) 本チュートリアルでは、ファイル読み書きは行わないので、 SDメモリカードへのコマンド発行を担当しているSd2Cardクラスのみを利用することにします。 ただし、Sd2CardクラスはCMD48/49には対応していないため、これらの対応を追加していきたいと思います。 ディレクトリ構成 Arduino IDEをインストールすると、ユーザーの「ドキュメント」ディレクトリにArduinoというフォルダが出来ているはずです。 こちらの libraries ディレクトリに、iSDIO というディレクトリを作り、その中にファイルを作っていきます。 作成後のディレクトリ構成は下記のようになります。 &lt;Document&gt;/ +-- Arduino +-- libraries +-- iSDIO +-- iSdio.h *1 +-- iSdio.cpp *2 +-- utility +-- Sd2Card.h *1 +-- Sd2Card.cpp *1 +-- Sd2CardExt.h *2 +-- Sd2CardExt.cpp *2 +-- Sd2PinMap.h *1 +-- SdInfo.h *1 *1のファイルは、Arduino IDE付属のSDメモリカードライブラリ Program Files (x86) Arduino libraries SD utilityから、 コピーして下さい。なお、Sd2Card.hには、少し変更が必要です。 *2のファイルはこれから、作っていきます。 Sd2CardExtクラスの作成 Sd2Cardクラスを継承してCMD48/49を追加した、Sd2CardExtクラスを作っていきます。 CMD48/49自体はiSDIO規格ではなくSD規格の一部なので、このようなクラス名としました。 CMD48/49の実行は、前述した３つのモードごとに独立した関数としました (10行目～14行目)。 また、非公開関数として、各モードの共通処理を行う関数を作りました (16行目, 17行目)。 Sd2CardExt.h #ifndef Sd2CardExt_h #define Sd2CardExt_h #include &quot;Sd2Card.h&quot; class Sd2CardExt : public Sd2Card { public: Sd2CardExt(void) : Sd2Card() {} uint8_t readExtDataPort(uint8_t mio, uint8_t func, uint16_t addr, uint8_t* dst); uint8_t readExtMemory(uint8_t mio, uint8_t func, uint32_t addr, uint16_t count, uint8_t* dst); uint8_t writeExtDataPort(uint8_t mio, uint8_t func, uint16_t addr, const uint8_t* src); uint8_t writeExtMemory(uint8_t mio, uint8_t func, uint32_t addr, uint16_t count, const uint8_t* src); uint8_t writeExtMask(uint8_t mio, uint8_t func, uint32_t addr, uint8_t mask, const uint8_t* src); protected: uint8_t readExt(uint32_t arg, uint8_t* src, uint16_t count); uint8_t writeExt(uint32_t arg, const uint8_t* src, uint16_t count); }; #endif // Sd2CardExt_h なお、Sd2Cardクラスを継承するために、Sd2Card.hにも少々変更が必要です。 Sd2Card.h 変更前: ... private: uint32_t block_; uint8_t chipSelectPin_; uint8_t errorCode_; ... 変更後: ... protected: uint32_t block_; uint8_t chipSelectPin_; uint8_t errorCode_; ... まず、CMD48/49に関連した定数を追加します。 Sd2CardExt.cpp (その1) #include &lt;Arduino.h&gt; #include &quot;Sd2CardExt.h&quot; uint8_t const CMD48 = 0x30; uint8_t const CMD49 = 0x31; uint8_t const SD_CARD_ERROR_CMD48 = 0x80; uint8_t const SD_CARD_ERROR_CMD49 = 0x81; 次に、ArduinoのSPIハードウェアを利用してデータの送信・受信を行う関数を用意します。 この関数はSd2Cardモジュールに含まれているものと同じですが、 頻繁に利用するため、インライン関数としてコピーしています。 Sd2CardExt.cpp (その2) /** Send a byte to the card */ inline void spiSend(uint8_t b) { SPDR = b; while (!(SPSR &amp; (1 &lt;&lt; SPIF))); } /** Receive a byte from the card */ inline uint8_t spiReceive(void) { spiSend(0xFF); return SPDR; } そして、CMD48/49を実際に発行する共通関数として、 readExt()関数および writeExt()関数を、 Sd2Cardクラスに含まれるCMD17/24用の関数である readData()関数および writeBlock()関数を流用して作成します。 CMD48/49の信号送受信のタイミングは、一般のメモリアクセス用コマンドCMD17/24と同一ですが、 コマンド番号と引数が違うほか、CMD48/49の読み書きは常に512バイト単位となります。 512バイト未満の読み書きの場合は、ダミーデータを追加して必ず512バイトにします。 なお、 readExt()関数で、 chipSelectHigh()のあとに、ダミーデータを1バイト分送信しています。 これは、FlashAirにクロックを与えて、コマンドの処理開始を保証するためのものです。 Sd2CardExt.cpp (その3) /** Perform Extention Read. */ uint8_t Sd2CardExt::readExt(uint32_t arg, uint8_t* dst, uint16_t count) { uint16_t i; // send command and argument. if (cardCommand(CMD48, arg) &amp;&amp; cardCommand(CMD17, arg)) { error(SD_CARD_ERROR_CMD48); goto fail; } // wait for start block token. if (!waitStartBlock()) { goto fail; } // receive data for (i = 0; i &lt; count; ++i) { dst[i] = spiReceive(); } // skip dummy bytes and 16-bit crc. for (; i &lt; 514; ++i) { spiReceive(); } chipSelectHigh(); spiSend(0xFF); // dummy clock to force FlashAir finish the command. return true; fail: chipSelectHigh(); return false; } /** Perform Extention Write. */ uint8_t Sd2CardExt::writeExt(uint32_t arg, const uint8_t* src, uint16_t count) { uint16_t i; uint8_t status; // send command and argument. if (cardCommand(CMD49, arg) &amp;&amp; cardCommand(CMD24, arg)) { error(SD_CARD_ERROR_CMD49); goto fail; } // send start block token. spiSend(DATA_START_BLOCK); // send data for (i = 0; i &lt; count; ++i) { spiSend(src[i]); } // send dummy bytes until 512 bytes. for (; i &lt; 512; ++i) { spiSend(0xFF); } // dummy 16-bit crc spiSend(0xFF); spiSend(0xFF); // wait a data response token status = spiReceive(); if ((status &amp; DATA_RES_MASK) != DATA_RES_ACCEPTED) { error(SD_CARD_ERROR_WRITE); goto fail; } // wait for flash programming to complete if (!waitNotBusy(SD_WRITE_TIMEOUT)) { error(SD_CARD_ERROR_WRITE_TIMEOUT); goto fail; } chipSelectHigh(); return true; fail: chipSelectHigh(); return false; } 最後に、３つの読み書きモードに対応する関数を追加します。 モードに合わせた引数を作成し、読み書きするデータサイズと一緒に readExt()と writeExt()に渡します。 mioは、メモリ領域とI/O領域のどちらを指定するかのフラグです。 iSDIOでは常にI/O領域を指定します。 funcは、機能番号です。 iSDIOでは機能番号0は、一般情報エリアとして予約されているため、 実際の機能は1から始まります。 例えば、FlashAirの無線LAN機能は、1になります。 addrは、アドレスです。 アドレス空間は、512バイトごとに「ページ」という単位に分かれており、 レジスタモードの場合はページの一部のみを読み書きできますが、 データポートモードの場合はあるページ全体を一度に読み書きします。 また、ページをまたがったアクセスはできません。 countは、アクセスするバイト数です。 データポートモードの場合は、0を指定しなければなりません。 詳細は、 SD Specifications Part 1 Physical Layer Simplified Specificationの 5.7.2節を参照してください。 Sd2CardExt.cpp (その4) uint8_t Sd2CardExt::readExtDataPort(uint8_t mio, uint8_t func, uint16_t addr, uint8_t* dst) { uint32_t arg = (((uint32_t)mio &amp; 0x1) &lt;&lt; 31) | (mio ? (((uint32_t)func &amp; 0x7) &lt;&lt; 28) : (((uint32_t)func &amp; 0xF) &lt;&lt; 27)) | (((uint32_t)addr &amp; 0x1FE00) &lt;&lt; 9); return readExt(arg, dst, 512); } uint8_t Sd2CardExt::readExtMemory(uint8_t mio, uint8_t func, uint32_t addr, uint16_t count, uint8_t* dst) { uint32_t offset = addr &amp; 0x1FF; if (offset + count &gt; 512) count = 512 - offset; if (count == 0) return true; uint32_t arg = (((uint32_t)mio &amp; 0x1) &lt;&lt; 31) | (mio ? (((uint32_t)func &amp; 0x7) &lt;&lt; 28) : (((uint32_t)func &amp; 0xF) &lt;&lt; 27)) | ((addr &amp; 0x1FFFF) &lt;&lt; 9) | ((count - 1) &amp; 0x1FF); return readExt(arg, dst, count); } uint8_t Sd2CardExt::writeExtDataPort(uint8_t mio, uint8_t func, uint16_t addr, const uint8_t* src) { uint32_t arg = (((uint32_t)mio &amp; 0x1) &lt;&lt; 31) | (mio ? (((uint32_t)func &amp; 0x7) &lt;&lt; 28) : (((uint32_t)func &amp; 0xF) &lt;&lt; 27)) | (((uint32_t)addr &amp; 0x1FE00) &lt;&lt; 9); return writeExt(arg, src, 512); } uint8_t Sd2CardExt::writeExtMemory(uint8_t mio, uint8_t func, uint32_t addr, uint16_t count, const uint8_t* src) { uint32_t arg = (((uint32_t)mio &amp; 0x1) &lt;&lt; 31) | (mio ? (((uint32_t)func &amp; 0x7) &lt;&lt; 28) : (((uint32_t)func &amp; 0xF) &lt;&lt; 27)) | ((addr &amp; 0x1FFFF) &lt;&lt; 9) | ((count - 1) &amp; 0x1FF); return writeExt(arg, src, count); } uint8_t Sd2CardExt::writeExtMask(uint8_t mio, uint8_t func, uint32_t addr, uint8_t mask, const uint8_t* src) { uint32_t arg = (((uint32_t)mio &amp; 0x1) &lt;&lt; 31) | (mio ? (((uint32_t)func &amp; 0x7) &lt;&lt; 28) : (((uint32_t)func &amp; 0xF) &lt;&lt; 27)) | (0x1 &lt;&lt; 26) | ((addr &amp; 0x1FFFF) &lt;&lt; 9) | mask; return writeExt(arg, src, 1); } パラメータ作成用ヘルパー関数の作成 iSDIO規格はコマンドやりとりの手順（プロトコル）を定めたものです。 iSDIOのコマンド発行は、 将来登場すると期待される多様なアプリケーションに対応できるよう、 スクリプトのような形で実行内容を渡す方法になっています。 スクリプトと言っても、言語ではなく数値の羅列ですので、プログラムをわかりやすくするために、ヘルパー関数を用意します。 put _xxx()は、バッファに値を書き込み、値のバイト数分だけポインタを進めて、新しいポインタを返すものです。 put _xxx_arg()は、スクリプトの引数専用で、値のサイズ、値、4バイト境界に合わせるためのパディング、を書き込みます。 書き込んだデータのバイト数分だけポインタを進めて、新しいポインタを返します。 put _command _header()および put _command _info _header()は、スクリプトのヘッダを作成するために利用します。 書き込んだデータのバイト数分だけポインタを進めて、新しいポインタを返します。 get _xxx()は、バッファから値を読み取ります。 詳しい使い方は、今後のチュートリアルで解説していきたいと思います。 ヘルパー関数 uint8_t* put_u8(uint8_t* p, uint8_t value); uint8_t* put_u16(uint8_t* p, uint16_t value); uint8_t* put_u32(uint8_t* p, uint32_t value); uint8_t* put_str(uint8_t* p, const char* value); uint8_t* put_u8_arg(uint8_t* p, uint8_t value); uint8_t* put_u16_arg(uint8_t* p, uint16_t value); uint8_t* put_u32_arg(uint8_t* p, uint32_t value); uint8_t* put_str_arg(uint8_t* p, const char* value); uint8_t* put_command_header(uint8_t* p, uint8_t num_commands, uint32_t command_bytes); uint8_t* put_command_info_header(uint8_t* p, uint16_t command_id, uint32_t sequence_id, uint16_t num_args); uint8_t get_u8(uint8_t* p); uint16_t get_u16(uint8_t* p); uint32_t get_u32(uint8_t* p); 利用方法 Arduino IDEを起動して、メニューから 「スケッチ」 &gt; 「ライブラリを使用」 &gt; 「Add Library …」を選び、 iSDIO フォルダを指定します。 一度この作業を行うと、次からはメニューに 「スケッチ」 &gt; 「ライブラリを使用」 &gt; 「iSDIO」 が現れます。 実行結果 今回はこのライブラリが正しくコンパイルできるところまで確かめてみましょう。 メニューの「ファイル」 &gt; 「新規ファイル」を選択し、新しいエディタを開きます。 次に、 「スケッチ」 &gt; 「ライブラリを使用」 &gt; 「iSDIO」 を選択します。 カードの初期設定を行う setup()関数および空の loop()関数を作成します。 arduino_tutorial_02.ino #include &lt;utility/Sd2CardExt.h&gt; const int chipSelectPin = 4; Sd2CardExt card; void setup() { // Initialize UART for message print. Serial.begin(9600); while (!Serial) { ; } // Initialize SD card. Serial.print(F(&quot; nInitializing SD card...&quot;)); if (card.init(SPI_HALF_SPEED, chipSelectPin)) { Serial.print(F(&quot;OK&quot;)); } else { Serial.print(F(&quot;NG&quot;)); abort(); } } void loop() { } そして、メニューの「スケッチ」 &gt; 「検証・コンパイル」で、エラーが出ないか確かめてください。 サンプルコード arduino_tutorial_02.zip (22KB) 本チュートリアルのサンプルコードはGPLv3および二条項BSDライセンスで提供されています。 詳細はダウンロードした各ファイルを参照してください。",
    "url": "http://localhost:4000/docs/tutorials/arduino/2.html",
    "relUrl": "/docs/tutorials/arduino/2.html"
  },
  "18": {
    "id": "18",
    "title": "APIリファレンス",
    "content": "APIリファレンス 利用できるAPIについて説明します。iSDIO解説ページも参照してください。 WLAN APIs コマンド名 機能 wlan_scan 近傍の接続可能な無線LANの検索をします。 wlan_connect STAモードで起動し、指定の無線LANに接続します。 wlan_establish APモードで起動します。 wlan_disconnect 無線LAN接続を切断します。 共有メモリ コマンド名 機能 read_shared_mem Shared Memoryを読み込みます。 write_shared_mem Shared Shared Memoryへ書き込みます。 wlan_scan 接続可能な無線LANの探索をします。 スキャン結果は、iSDIO Command Response Data をデータポートとして読み取る(readExtDataPort)ことにより取得します。 詳細は、SD Specifications Part E7 Wireless LAN Simplified Addendum Version 1.10に規定されています。 書式 uint8_t wlan_scan(uint32_t sequenceId); 引数 sequenceId uint32_t。iSDIOコマンドシーケンスID。 wlan_connect STAモードで起動し、指定の無線LANに接続します。 書式 uint8_t wlan_connect(uint32_t sequenceId, const uint8_t* ssid, const uint8_t* networkKey); 引数 sequenceId uint32_t。iSDIOコマンドシーケンスID。 ssid uint8_t。接続先アクセスポイントのSSID。 networkKey uint8_t。ネットワークキー。 wlan_establish APモードで起動します。 書式 uint8_t wlan_establish(uint32_t sequenceId, const uint8_t *ssid, const uint8_t *networkkey, const uint8_t encmode); 引数 sequenceId uint32_t。iSDIOコマンドシーケンスID。 ssid uint8_t。接続先アクセスポイントのSSID。 networkKey uint8_t。ネットワークキー。 encmode uint8_t。暗号モード。 wlan_disconnect 無線LAN接続を切断します。 書式 uint8_t wlan_disconnect(uint32_t sequenceId); 引数 sequenceId uint32_t。iSDIOコマンドシーケンスID。 read_shared_mem Shared Memoryを読み込みます。 書式 uint8_t read_shared_mem(uint32_t offset, uint8_t* dst, uint16_t length); 引数 offset uint32_t。共有メモリ領域先頭アドレスからのオフセット（０を指定すると先頭アドレスを使います）。 dst uint8_t。読み出したデータを格納するアドレス。 length uint16_t。読み出すデータ長。 write_shared_mem Shared Memoryへ書き込みます。 書式 uint8_t write_shared_mem(uint32_t offset, uint8_t* src, uint16_t length); 引数 offset uint32_t。共有メモリ領域先頭アドレスからのオフセット（０を指定すると先頭アドレスを使います）。 src&lt; uint8_t。書き込むデータを格納したアドレス。 length uint16_t。書き込むデータ長。",
    "url": "http://localhost:4000/docs/tutorials/mbed/2.html",
    "relUrl": "/docs/tutorials/mbed/2.html"
  },
  "19": {
    "id": "19",
    "title": "カードステータスの読み取り",
    "content": "カードステータスの読み取り 本チュートリアルでは、iSDIOコマンドを使って、FlashAirの無線LANステータスを読み取ってみます。 ステータス読み取りの概要 下記の図は、簡易版仕様書から引用したiSDIOレジスタのメモリ配置です。 iSDIOレジスタのメモリ配置 (SD Specifications Part E7 iSDIO Simplifed Specification Version 1.10より抜粋) iSDIOステータスは、アドレス0x400番地からはじまるページ(512バイト分の領域)を読み取ることで取得できます。 0x400～0x4FF番地はiSDIO共通ステータスです。 0x500～0x5FF番地はアプリケーションごとのステータスとなっており、 FlashAirの場合は、ここを読み取ることで無線LAN機能の各種情報が取得できます。 iSDIO共通ステータス (SD Specifications Part E7 iSDIO Simplifed Specification Version 1.10より抜粋) iSDIO無線LAN機能ステータス (SD Specifications Part E7 iSDIO Simplifed Specification Version 1.10より抜粋) ステータス読み取り関数の作成 0x400番地からの領域を読み取り、前述のステータスマップに従って、 読み取れた状態を表示する関数を作ります。 arduino_tutorial_03.ino (その1) uint8_t buffer[512]; void printByte(uint8_t value) { Serial.print(value &gt;&gt; 4, HEX); Serial.print(value &amp; 0xF, HEX); } void printBytes(uint8_t* p, uint32_t len) { for (int i = 0; i &lt; len; ++i) { printByte(p[i]); } } void printIPAddress(uint8_t* p) { Serial.print(p[0], DEC); Serial.print(&#39;.&#39;); Serial.print(p[1], DEC); Serial.print(&#39;.&#39;); Serial.print(p[2], DEC); Serial.print(&#39;.&#39;); Serial.print(p[3], DEC); } boolean iSDIO_status() { Serial.print(F(&quot; nRead iSDIO Status Register&quot;)); // Read iSDIO Status Register (E7 1.10 2.2.2.1) memset(buffer, 0, 0x200); if (!card.readExtMemory(1, 1, 0x400, 0x200, buffer)) { return false; } // Show values in the common status area. Serial.print(F(&quot; n == iSDIO Status Registers == &quot;)); Serial.print(F(&quot; n [0400h] Command Write Status: &quot;)); if (buffer[0x000] &amp; 0x01) Serial.print(F(&quot;CWU &quot;)); if (buffer[0x000] &amp; 0x02) Serial.print(F(&quot;CWA &quot;)); Serial.print(F(&quot; n [0420h] iSDIO Status: &quot;)); if (buffer[0x020] &amp; 0x01) Serial.print(F(&quot;CRU &quot;)); if (buffer[0x020] &amp; 0x02) Serial.print(F(&quot;ESU &quot;)); if (buffer[0x020] &amp; 0x04) Serial.print(F(&quot;MCU &quot;)); if (buffer[0x020] &amp; 0x08) Serial.print(F(&quot;ASU &quot;)); Serial.print(F(&quot; n [0422h] iSDIO Int Enable: &quot;)); if (buffer[0x022] &amp; 0x01) Serial.print(F(&quot;CRU_ENA &quot;)); if (buffer[0x022] &amp; 0x02) Serial.print(F(&quot;ESU_ENA &quot;)); if (buffer[0x022] &amp; 0x04) Serial.print(F(&quot;MCU_ENA &quot;)); if (buffer[0x022] &amp; 0x08) Serial.print(F(&quot;ASU_ENA &quot;)); Serial.print(F(&quot; n [0424h] Error Status: &quot;)); if (buffer[0x024] &amp; 0x01) Serial.print(F(&quot;CRE &quot;)); if (buffer[0x024] &amp; 0x02) Serial.print(F(&quot;CWE &quot;)); if (buffer[0x024] &amp; 0x04) Serial.print(F(&quot;RRE &quot;)); if (buffer[0x024] &amp; 0x08) Serial.print(F(&quot;APE &quot;)); Serial.print(F(&quot; n [0426h] Memory Status: &quot;)); if (buffer[0x026] &amp; 0x01) Serial.print(F(&quot;MEX &quot;)); if (buffer[0x026] &amp; 0x02) Serial.print(F(&quot;FAT &quot;)); for (int i = 0; i &lt; 8; ++i) { uint8_t addr = 0x40 + i * 0x14; Serial.print(F(&quot; n [04&quot;)); printByte(addr); Serial.print(F(&quot;h] Command Response Status #&quot;)); Serial.print(i + 1, DEC); Serial.print(F(&quot;: &quot;)); if (buffer[addr] &amp; 0x01) { Serial.print(F(&quot;id = &quot;)); Serial.print(get_u16(buffer + addr + 2), DEC); Serial.print(F(&quot;, sequence id = &quot;)); Serial.print(get_u32(buffer + addr + 4), DEC); Serial.print(F(&quot;, status = &quot;)); switch (buffer[addr + 8]) { case 0x00: Serial.print(F(&quot;Initial&quot;)); break; case 0x01: Serial.print(F(&quot;Command Processing&quot;)); break; case 0x02: Serial.print(F(&quot;Command Rejected&quot;)); break; case 0x03: Serial.print(F(&quot;Process Succeeded&quot;)); break; case 0x04: Serial.print(F(&quot;Process Terminated&quot;)); break; default: Serial.print(F(&quot;Process Failed &quot;)); Serial.print(buffer[addr + 8], HEX); break; } } else { Serial.print(F(&quot;Not registered&quot;)); } } // Show values in the application status area. Serial.print(F(&quot; n == Wireless LAN Status Registers ==&quot;)); Serial.print(F(&quot; n [0500h] DLNA Status: &quot;)); if (buffer[0x100] &amp; 0x01) Serial.print(F(&quot;ULR &quot;)); if (buffer[0x100] &amp; 0x02) Serial.print(F(&quot;DLU &quot;)); if (buffer[0x100] &amp; 0x04) Serial.print(F(&quot;CBR &quot;)); if (buffer[0x100] &amp; 0x08) Serial.print(F(&quot;CDR &quot;)); Serial.print(F(&quot; n [0501h] P2P Status: &quot;)); if (buffer[0x101] &amp; 0x01) Serial.print(F(&quot;ILU &quot;)); if (buffer[0x101] &amp; 0x02) Serial.print(F(&quot;FLU &quot;)); Serial.print(F(&quot; n [0502h] PTP Status: &quot;)); if (buffer[0x102] &amp; 0x01) Serial.print(F(&quot;RPO &quot;)); if (buffer[0x102] &amp; 0x02) Serial.print(F(&quot;RPD &quot;)); if (buffer[0x102] &amp; 0x04) Serial.print(F(&quot;RPC &quot;)); if (buffer[0x102] &amp; 0x08) Serial.print(F(&quot;CPI &quot;)); if (buffer[0x102] &amp; 0x10) Serial.print(F(&quot;DPI &quot;)); if (buffer[0x102] &amp; 0x20) Serial.print(F(&quot;CIL &quot;)); Serial.print(F(&quot; n [0504h] Application: &quot;)); Serial.print(buffer[0x104]); Serial.print(F(&quot; n [0506h] WLAN: &quot;)); if ((buffer[0x106] &amp; 0x01) == 0x00) Serial.print(F(&quot;No Scan, &quot;)); if ((buffer[0x106] &amp; 0x01) == 0x01) Serial.print(F(&quot;Scanning, &quot;)); if ((buffer[0x106] &amp; 0x06) == 0x00) Serial.print(F(&quot;No WPS, &quot;)); if ((buffer[0x106] &amp; 0x06) == 0x02) Serial.print(F(&quot;WPS with PIN, &quot;)); if ((buffer[0x106] &amp; 0x06) == 0x04) Serial.print(F(&quot;WPS with PBC, &quot;)); if ((buffer[0x106] &amp; 0x08) == 0x00) Serial.print(F(&quot;Group Client, &quot;)); if ((buffer[0x106] &amp; 0x08) == 0x08) Serial.print(F(&quot;Group Owner &quot;)); if ((buffer[0x106] &amp; 0x10) == 0x00) Serial.print(F(&quot;STA, &quot;)); if ((buffer[0x106] &amp; 0x10) == 0x10) Serial.print(F(&quot;AP, &quot;)); if ((buffer[0x106] &amp; 0x60) == 0x00) Serial.print(F(&quot;Initial, &quot;)); if ((buffer[0x106] &amp; 0x60) == 0x20) Serial.print(F(&quot;Infrastructure, &quot;)); if ((buffer[0x106] &amp; 0x60) == 0x40) Serial.print(F(&quot;Wi-Fi Direct, &quot;)); if ((buffer[0x106] &amp; 0x80) == 0x00) Serial.print(F(&quot;No Connection, &quot;)); if ((buffer[0x106] &amp; 0x80) == 0x80) Serial.print(F(&quot;Connected, &quot;)); Serial.print(F(&quot; n [0508h] SSID: &quot;)); for (int i = 0; i &lt; 32 &amp;&amp; buffer[0x108 + i] != 0; ++i) { Serial.print((char)buffer[0x108 + i]); } Serial.print(F(&quot; n [0528h] Encryption Mode: &quot;)); switch (buffer[0x128]) { case 0 : Serial.print(F(&quot;Open System and no encryption&quot;)); break; case 1 : Serial.print(F(&quot;Open System and WEP&quot;)); break; case 2 : Serial.print(F(&quot;Shared Key and WEP&quot;)); break; case 3 : Serial.print(F(&quot;WPA-PSK and TKIP&quot;)); break; case 4 : Serial.print(F(&quot;WPA-PSK and AES&quot;)); break; case 5 : Serial.print(F(&quot;WPA2-PSK and TKIP&quot;)); break; case 6 : Serial.print(F(&quot;WPA2-PSK and AES&quot;)); break; default: Serial.print(F(&quot;Unknown&quot;)); } Serial.print(F(&quot; n [0529h] Signal Strength: &quot;)); Serial.print(buffer[0x129], DEC); Serial.print(F(&quot; n [052Ah] Channel: &quot;)); if (buffer[0x12A] == 0) Serial.print(F(&quot;No connection&quot;)); else Serial.print(buffer[0x12A], DEC); Serial.print(F(&quot; n [0530h] MAC Address: &quot;)); printBytes(buffer + 0x130, 6); Serial.print(F(&quot; n [0540h] ID: &quot;)); for (int i = 0; i &lt; 16 &amp;&amp; buffer[0x140 + i] != 0; ++i) { Serial.print((char)buffer[0x140 + i]); } Serial.print(F(&quot; n [0550h] IP Address: &quot;)); printIPAddress(buffer + 0x150); Serial.print(F(&quot; n [0554h] Subnet Mask: &quot;)); printIPAddress(buffer + 0x154); Serial.print(F(&quot; n [0558h] Default Gateway: &quot;)); printIPAddress(buffer + 0x158); Serial.print(F(&quot; n [055Ch] Preferred DNS Server: &quot;)); printIPAddress(buffer + 0x15C); Serial.print(F(&quot; n [0560h] Alternate DNS Server: &quot;)); printIPAddress(buffer + 0x160); Serial.print(F(&quot; n [0564h] Proxy Server: &quot;)); if ((buffer[0x164] &amp; 0x01) == 0x00) Serial.print(F(&quot;Disabled&quot;)); if ((buffer[0x164] &amp; 0x01) == 0x01) Serial.print(F(&quot;Enabled&quot;)); Serial.print(F(&quot; n [0570h] Date: &quot;)); Serial.print(buffer[0x171] + 1980, DEC); Serial.print(&#39;-&#39;); Serial.print(buffer[0x170] &gt;&gt; 4, DEC); Serial.print(&#39;-&#39;); Serial.print(buffer[0x170] &amp; 0xF, DEC); Serial.print(F(&quot; n [0572h] Time: &quot;)); Serial.print(buffer[0x173] &gt;&gt; 3, DEC); Serial.print(&#39;:&#39;); Serial.print(buffer[0x172] &lt;&lt; 3 | buffer[0x170] &gt;&gt; 3, DEC); Serial.print(&#39;:&#39;); Serial.print((buffer[0x172] &amp; 0x1F) * 2, DEC); Serial.print(F(&quot; n [0574h] HTTP Status: &quot;)); Serial.print(buffer[0x174] &amp; 0xEF, DEC); if ((buffer[0x174] &amp; 0x80) == 0x00) Serial.print(F(&quot; (No Processing)&quot;)); if ((buffer[0x174] &amp; 0x80) == 0x80) Serial.print(F(&quot; (Processing)&quot;)); Serial.print(F(&quot; n [0575h] Power Save Management: &quot;)); if ((buffer[0x175] &amp; 0x01) == 0x00) Serial.print(F(&quot;Power Save Mode Off&quot;)); if ((buffer[0x175] &amp; 0x01) == 0x01) Serial.print(F(&quot;Power Save Mode On&quot;)); Serial.print(F(&quot; n [0576h] File System Management: &quot;)); if ((buffer[0x176] &amp; 0x01) == 0x00) Serial.print(F(&quot;FS Information may be modified&quot;)); if ((buffer[0x176] &amp; 0x01) == 0x01) Serial.print(F(&quot;FS Information shall not be modified&quot;)); Serial.println(); return true; } なお、 Serial.print()や Serial.println()は、「シリアルモニタ」に文字を出力するための関数ですが、 文字列引数を F()というマクロで囲っています。 通常文字列定数は、言語仕様上書き換え可能であるためRAM上に置かれてしまい、 たくさんの文字列表示をするとあっという間にメモリが不足してしまいます。 しかし、表示用の文字列は変更することがないため、RAMには置かずにメモリを節約したいところです。 そこで、 F()マクロを使います。 囲まれた文字列はROM領域に置かれてRAMを消費しなくなります。 そして、 setup()で呼び出します。 arduino_tutorial_03.ino (その2) void setup() { // Initialize UART for message print. Serial.begin(9600); while (!Serial) { ; } // Initialize SD card. Serial.print(F(&quot; nInitializing SD card...&quot;)); if (card.init(SPI_HALF_SPEED, chipSelectPin)) { Serial.print(F(&quot;OK&quot;)); } else { Serial.print(F(&quot;NG&quot;)); abort(); } if (iSDIO_status()) { Serial.print(F(&quot; nOK&quot;)); } else { Serial.println(F(&quot; nFailed to read status.&quot;)); } } 実行結果 これを実行するとたとえば下記のような出力が得られます。 実行結果例 Read iSDIO Status Register == iSDIO Status Registers == [0400h] Command Write Status: [0420h] iSDIO Status: CRU [0422h] iSDIO Int Enable: [0424h] Error Status: [0426h] Memory Status: MEX [0440] Command Response Status #1: id = 3, sequence id = 0, status = Process Succeeded [0454] Command Response Status #2: Not registered [0468] Command Response Status #3: Not registered [047C] Command Response Status #4: Not registered [0490] Command Response Status #5: Not registered [04A4] Command Response Status #6: Not registered [04B8] Command Response Status #7: Not registered [04CC] Command Response Status #8: Not registered == Wireless LAN Status Registers == [0500h] DLNA Status: [0501h] P2P Status: [0502h] PTP Status: [0504h] Application: 0 [0506h] WLAN: No Scan, No WPS, Group Client, AP, Infrastructure, No Connection, [0508h] SSID: flashair_sdio [0528h] Encryption Mode: WPA2-PSK and AES [0529h] Signal Strength: 0 [052Ah] Channel: 11 [0530h] MAC Address: B86B23733F4F [0540h] ID: [0550h] IP Address: 192.168.0.1 [0554h] Subnet Mask: 255.255.255.0 [0558h] Default Gateway: 192.168.0.1 [055Ch] Preferred DNS Server: 192.168.0.1 [0560h] Alternate DNS Server: 0.0.0.0 [0564h] Proxy Server: Disabled [0570h] Date: 1980-0-0 [0572h] Time: 0:0:0 [0574h] HTTP Status: 0 (No Processing) [0575h] Power Save Management: Power Save Mode Off [0576h] File System Management: FS Information may be modified OK サンプルコード arduino_tutorial_03.zip (23KB) 本チュートリアルのサンプルコードはGPLv3および二条項BSDライセンスで提供されています。 詳細はダウンロードした各ファイルを参照してください。",
    "url": "http://localhost:4000/docs/tutorials/arduino/3.html",
    "relUrl": "/docs/tutorials/arduino/3.html"
  },
  "20": {
    "id": "20",
    "title": "コンテンツのダウンロード",
    "content": "コンテンツのダウンロード 第3回では、FlashAirのコンテンツをダウンロードするアプリを作成します。 ダウンロード処理では、CordovaのFileプラグイン及びFileTransferプラグインを使用します。 事前準備 1. プロジェクトを作成する まずは作成するアプリのプロジェクトを作成します。 前回までと同じく、プロジェクトを作成したいディレクトリへ移動し、以下のコマンドを実行します。 &gt; cordova create cordovatutorial3 com.fixstars.flashair.tutorial CordovaTutorial3 また、プロジェクト作成後、browserプラットフォーム及び第2回で使用したStatusbarプラグイン（config.xmlへのコード追加作業含む）の追加を行ってください。 2. 第2回で使用したファイルを追加する 第2回で使用したファイルを以下のようにコピーして追加します。 cordovatutorial3 ├─ hooks ├─ platforms ├─ plugins ├─ www │ ├─ css │ │ └─ load.css（上書きコピー） │ ├─ img │ │ └─ logo.png │ ├─ js │ │ ├─ jquery-3.1.1.min.js（上書きコピー） │ │ ├─ load.js（上書きコピー） │ │ └─ tutorial2.js（上書きコピー） │ ├─ index.html（上書きコピー） │ └─ tutorial2.html（上書きコピー） └─ config.xml アプリのトップ画面作成 1. index.htmlを編集する アプリのトップ画面であるindex.htmlを編集します。 第2回の36～39行目を、以下のように変更してください。 /www/index.html &lt;p class=&quot;pos-center&quot;&gt;&lt;button type=&quot;button&quot; onclick=&quot;location.href=&#39;tutorial2.html&#39;&quot;&gt;２．コンテンツリストの取得&lt;/button&gt;&lt;/p&gt; &lt;p class=&quot;pos-center&quot;&gt;&lt;button type=&quot;button&quot; onclick=&quot;location.href=&#39;tutorial3.html&#39;&quot;&gt;３．コンテンツのダウンロード&lt;/button&gt;&lt;/p&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;cordova.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;js/load.js&quot;&gt;&lt;/script&gt; &lt;/body&gt; 37行目 タップされたらtutorial3.htmlの画面へ遷移するボタンを追加しています。コンテンツのダウンロードはtutorial3.htmlの画面で行います。 2. 実行結果 上記の編集が完了したら、ビルドを行い、出来上がったアプリのインストールを行ってください。第2回と比べて、「３．コンテンツのダウンロード」ボタンを追加しています。 Androidデバイスの場合 iOSデバイスの場合 コンテンツのダウンロード画面の作成 1. tutorial3.htmlを作成する 続いて、コンテンツのダウンロード画面を作成します。tutorial2.htmlとの共通部分が多いので、コピーしたファイルをtutorial3.htmlとして保存して、9～24行目を以下のように変更してください。 /www/tutorial3.html &lt;title&gt;Tutorial3&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;css/load.css&quot;&gt; &lt;/head&gt; &lt;body onload=&quot;onLoad()&quot;&gt; &lt;div id=&quot;header&quot; class=&quot;pos-center&quot;&gt; &lt;div id=&quot;head-left&quot;&gt;&amp;lt;&lt;br&gt;Back&lt;/div&gt; &lt;h1 id=&quot;head-center&quot;&gt;Download&lt;/h1&gt; &lt;div id=&quot;head-right&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div id=&quot;list&quot;&gt;&lt;/div&gt; &lt;hr&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;cordova.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;js/jquery-3.1.1.min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;js/tutorial3.js&quot;&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 9行目 画面のタイトルをTutorial3に変更しています。 15行目 ヘッダーのタイトルをDownloadに変更しています。 18-19行目 tutorial3.jsで取得するコンテンツリストをここに表示させます。 22行目 ロードするJavaScriptの内、tutorial2.jsをtutorial3.jsへ変更しています。tutorial3.jsについては後述します。 2. tutorial3.jsで使用するプラグインを追加する 次はtutorial3.jsの作成に移りますが、その前にそちらで使用するプラグインを追加していきます。 まず、ダウンロード処理で使用するFileTransferプラグインを追加します。 また、ダウンロード時に端末内のファイルへアクセス（書き込み）を行うのに必要なFileプラグインも追加します。 また、ファイルのダウンロード後、コンテンツの表示にウェブブラウザビューを使用するので、Inappbrowserプラグインも追加します。 それぞれの追加コマンドは以下の通りです。 &gt; cordova plugin add cordova-plugin-file -save cordova plugin add cordova-plugin-file-transfer -save cordova plugin add cordova-plugin-inappbrowser -save 3. tutorial3.jsを作成する コンテンツのダウンロード画面でロードするtutorial3.jsを作成していきます。 ダウンロード処理はFileTransferプラグインのdownloadを利用して行います。 また、tutorial2.jsと異なり、コンテンツリストは階層表示ができるようにします。 /www/js/tutorial3.js var currentPath = &quot;/&quot;; var wlansd = new Array(); var doesFileExist = false; function onLoad(){ document.addEventListener(&quot;deviceready&quot;, onDeviceReady, false); } function onDeviceReady(){ getFileList(&quot;&quot;); $(document).on(&quot;click&quot;, &quot;a.dir&quot;, function(){ getFileList(this.text); }); $(document).on(&quot;click&quot;, &quot;a.file&quot;, function(){ downloadFile(this.text, currentPath); }); document.addEventListener(&quot;backbutton&quot;, onBackKeyDown, false); $(&quot;#head-left&quot;).click(function(){ onBackKeyDown(); }); } function onBackKeyDown(){ if(doesFileExist == false){ location.href = &quot;index.html&quot;; } else if(currentPath == &quot;/&quot;){ location.href = &quot;index.html&quot;; } else { getFileList(&quot;..&quot;); } } // Get the content list. function getFileList(dir){ doesFileExist = false; var nextPath = makePath(dir); var url = &quot;http://flashair/command.cgi?op=100&amp;DIR=&quot; + nextPath; $.get(url, function(data){ //Save the current path. currentPath = nextPath; // Split lines by new line characters. wlansd = data.split(/ n/g); // Ignore the first line (title) and last line (blank). wlansd.shift(); wlansd.pop(); splitFileList(currentPath); wlansd.sort(cmptime); showFileList(currentPath); // Success to get content list. doesFileExist = true; }); } // Make a Path to show next. function makePath(dir){ var arrPath = currentPath.split(&quot;/&quot;); if(currentPath == &quot;/&quot;){ arrPath.pop(); } if(dir == &quot;..&quot;){ // Go to parent directory. Remove last fragment. arrPath.pop(); } else if(dir != &quot;&quot; &amp;&amp; dir != &quot;.&quot;){ // Go to child directory. Append dir to the current path. arrPath.push(dir); } if (arrPath.length == 1){ arrPath.push(&quot;&quot;); } return arrPath.join(&quot;/&quot;); } // Split the content list data. function splitFileList(){ for(var i=0; i&lt;wlansd.length; i++){ var elements = wlansd[i].split(&quot;,&quot;); wlansd[i] = new Array(); wlansd[i][&quot;r_uri&quot;] = elements[0]; wlansd[i][&quot;fname&quot;] = elements[1]; wlansd[i][&quot;fsize&quot;] = Number(elements[2]); wlansd[i][&quot;attr&quot;] = Number(elements[3]); wlansd[i][&quot;fdate&quot;] = Number(elements[4]); wlansd[i][&quot;ftime&quot;] = Number(elements[5]); } } // Sort contents by date and time. function cmptime(a,b){ if(a[&quot;fdate&quot;] == b[&quot;fdate&quot;]){ return a[&quot;ftime&quot;] - b[&quot;ftime&quot;]; } else { return a[&quot;fdate&quot;] - b[&quot;fdate&quot;]; } } // Show the content list. function showFileList(){ $(&quot;#list&quot;).html(&quot;&quot;); $.each(wlansd, function(){ var file = this; var filelink = $(&quot;&lt;a href=&#39;javascript:void(0)&#39;&gt;&lt;/a&gt;&quot;); var caption = file[&quot;fname&quot;]; var faDir = file[&quot;r_uri&quot;]; var fileobj = $(&quot;&lt;div&gt;&lt;/div&gt;&quot;); // Skip hidden file. if(file[&quot;attr&quot;] &amp; 0x02){ return; } // Make a link to directories and files. if(file[&quot;attr&quot;] &amp; 0x10){ filelink.addClass(&quot;dir&quot;); } else { filelink.addClass(&quot;file&quot;); } $(&quot;#list&quot;).append( fileobj.append( filelink.append( caption ) ) ); }); } // Download the content. function downloadFile(fname, dir){ var fileTransfer = new FileTransfer(); var dlPath = dir !=&quot;/&quot; ? dir + &quot;/&quot; + fname : dir + fname; var dlUrl = encodeURI(&quot;http://flashair&quot; + dlPath); var destUrl = encodeURI(&quot;cdvfile://localhost/persistent/download/&quot; + fname); fileTransfer.download(dlUrl, destUrl, function(entry) { window.open = cordova.InAppBrowser.open(entry.toURL(), &quot;_blank&quot;, &quot;location=no&quot;); }, function(error) { switch (error.code){ case 1: alert(&quot;Failed to download the file. Error code is &#39;FILE_NOT_FOUND_ERR&#39;&quot;); break; case 2: alert(&quot;Failed to download the file. Error code is &#39;INVALID_URL_ERR&#39;&quot;); break; case 3: alert(&quot;Failed to download the file. Error code is &#39;CONNECTION_ERR&#39;&quot;); break; case 4: alert(&quot;Failed to download the file. Error code is &#39;ABORT_ERR&#39;&quot;); break; case 5: alert(&quot;Failed to download the file. Error code is &#39;NOT_MODIFIED_ERR&#39;&quot;); break; } }); } 1行目 コンテンツリストの取得や表示で使用する（FlashAir上の）カレントディレクトリの変数を宣言しています。初期値は&quot;/&quot;（root）です。 9-21行目 devicereadyイベントが発火した後、最初にgetFileList(&#39;&#39;)でrootのコンテンツリストを取得・表示させています。 そして、class=&quot;dir&quot;を持つリンクがタップされた場合はそのディレクトリのコンテンツリストを新たに表示させます。 また、class=&quot;file&quot;を持つリンクがタップされた場合はそのファイルコンテンツをダウンロードするdownloadFile関数を呼び出します。 23-31行目 getFileList関数でコンテンツリストのデータを取得できなかった場合、もしくはカレントディレクトリがrootの場合は、トップ画面へ戻るようにしています。また、カレントディレクトリがrootでない場合は、一つ前（親）のディレクトリのコンテンツリストを表示するようにしています。 33-52行目 コンテンツリストのデータを取得する関数です。 36行目でcommand.cgi?op=100のコマンドを発行しています。FlashAirから返ってきたデータに対する処理は、2番目の引数であるコールバック関数（function(data) {...}）の内部に記述します。 これは、CGIコマンドの実行が非同期的に行われるためです。取得したデータは48行目のshowFileList関数で表示させています。 54-71行目 FlashAir上での絶対パスを作成するヘルパー関数です。 73-84行目 取得したコンテンツリストのデータを細分化して格納する関数です。 細分化したデータは、r_uriがコンテンツのあるディレクトリ、fnameがコンテンツ名、fsizeがコンテンツのサイズ、attrがコンテンツの属性、fdateがコンテンツの作成日、ftimeがコンテンツの作成時間になります。 86-92行目 取得したコンテンツリストのデータを更新日時順に並べ替える関数です。 94-120行目 取得したコンテンツリストをHTML中に用意したlistの位置に表示させる関数です。 123行目 FileTransferのインスタンス変数を宣言しています。 124-125行目 ファイルのダウンロード元となるサーバのURLを設定します。 126行目 ダウンロードしたファイルの保存先を設定します。 これは端末上のファイルのフルパスで指定する必要があります。ただし、FileTransferプラグインのdownloadではcdvfile形式のパスを使用でき、これを使用すれば、プラットフォームに依存せず指定された場所（アプリ内）に保存されるようになります。cdvfileの詳細については公式のFileプラグインのcdvfile protocol及びFileTransferプラグインのBackwards ompatibility Notesをご覧ください。 128-148行目 FileTransferプラグインのdownloadを利用して、ファイルのダウンロードを行っています。第1引数はダウンロード元URL、第2引数はダウンロード先のURL、第3引数はダウンロードのサクセスコールバック関数、第4引数はダウンロードのエラーコールバック関数です。サクセスコールバック関数（function(entry) {...}）では、Inappbrowserプラグインの機能を利用して、ダウンロードしたファイルコンテンツをウェブブラウザビューで表示します。また、エラーコールバック関数（function(error) {...}）では、デバッグ用として受け取ったエラーコードのアラートを出力します。 （※本サンプルコードではFileTransferプラグインのエラーコードを表示していますが、実際のアプリでは適切なメッセージを表示するのがよいでしょう。） 4. 実行結果 プロジェクト内の全てのファイルの配置が完了したら、ビルドを行い、アプリへインストールします。 ここで一つ注意点があります。 Androidデバイスでは以下の画面の通り、インストール時にストレージへのアクセス権限の許可が必要になります。 これはFileプラグイン及びFileTransferプラグイン利用でandroid.permission.WRITE_EXTERNAL_STORAGEパーミッションの利用を設定するためです。 （※iOSデバイスでは許可が必要になる権限はありません。） アプリインストール後、FlashAirへ無線LAN接続していれば、トップ画面の「３．コンテンツのダウンロード」ボタンをタップすることで、コンテンツリストが表示されます。 またリストの内、ファイルコンテンツをタップすれば、アプリ内へのダウンロードを行い、ウェブブラウザビューで表示されます。 （以下の右側の画面は「テスト.txt」ファイルをタップして、ダウンロード完了後に表示される画面です。） Androidデバイスの場合 iOSデバイスの場合 サンプルコード リポジトリを見る（GitHub） このサンプルコードはApache License, Version 2.0で提供されています。 「cordova_tutorial_03」ディレクトリは、zipファイルで圧縮してPhoneGap Buildへアップロードすることでビルドできます。 ビルド方法はHelloWorldアプリをビルドするをご確認ください。 Cordovaプロジェクトで確認する場合は、「cordova_tutorial_03」ディレクトリ内のデータをプロジェクト内へ上書きコピーしてください。",
    "url": "http://localhost:4000/docs/tutorials/cordova/3.html",
    "relUrl": "/docs/tutorials/cordova/3.html"
  },
  "21": {
    "id": "21",
    "title": "コンテンツのダウンロード",
    "content": "コンテンツのダウンロード このチュートリアルではコンテンツのダウンロード方法について学びます。 command.cgiを使用して取得したコンテンツリストから、選択されたイメージファイルを表示するアプリケーションを作成します。 このチュートリアルは別項のiOS Tutorial 2:コンテンツリストの取得に基づいています。 それではさっそく作ってみましょう。 画面レイアウトの作成 今回作成するアプリケーションの画面レイアウトです。 アプリケーションが起動されると、labelCount にファイル数、labelDirectory に現在のフォルダ、Table View にコンテンツリストが表示されるように作ります。 コンテンツリストのコンテンツがタップされると、該当のイメージファイルをダウンロードし、Image View に表示します。 以下の部品を配置します。 コンテンツリスト画面 Round Rect Button(UIButton) back : 一つ上の階層へ移動 Label(UILabel) labelCount : 現在のフォルダのファイル数を表示 labelDirectory : 現在のフォルダパスを表示 Table View(UITableView) コンテンツリスト Table View Cell(UITableViewCell) コンテンツリスト上のセル イメージ表示画面 View Controller(UIViewController) Image View(UIImageView) イメージファイルを表示 その他 Navigation Controller(UINavigationController) イメージファイル表示画面から、コンテンツリスト画面へ戻るために使用 このように表示されるコンテンツリストを作ります。 フォルダがタップされた場合は、選択したフォルダの中身を表示します。 back がタップされた場合は、ひとつ上のフォルダの中身を表示します。 イメージファイルがタップされた場合は、以下のように画像を表示します。 コードの作成 イメージファイルの表示 イメージファイルの表示は、イメージファイル表示用の View Controller を用意し、そのサブクラス内で行います。 サブクラスは以下のクラス名で用意します。 FSImageViewController イメージファイルの取得は、CGIは介さずに直接ファイルパスを指定することで実現します。 取得の際には、NSData dataWithContentsOfURLを使用してい ます。 この関数は、データオブジェクトを返します。 FSImageViewController.h @interface FSImageViewController : UIViewController @property (strong, nonatomic) IBOutlet UIImageView *imageView; @property (nonatomic) NSString *fileInfo; @end 3行目fileInfo:コンテンツリストの View Controller から、選択されたファイル情報を受け取るための property です。 FSImageViewController.m - (void)viewDidLoad { [super viewDidLoad]; // Do any additional setup after loading the view. // Make a file path NSString *dir = [[self.fileInfo componentsSeparatedByString:@&quot;,&quot;] objectAtIndex:0]; NSString *filename = [[self.fileInfo componentsSeparatedByString:@&quot;,&quot;] objectAtIndex:1]; NSString *filePath = [[dir stringByAppendingString:@&quot;/&quot;] stringByAppendingString:filename]; // Run NSURL *url = [NSURL URLWithString:[NSString stringWithFormat:@&quot;http://flashair/%@&quot;, filePath]]; // Get image data if(nil == url)return; NSData *img_data = [NSData dataWithContentsOfURL:url]; UIImage *img = [[UIImage alloc] initWithData:img_data]; // Display results self.imageView.image = img; } 7-12行目 コンテンツリストの View Controller から引き渡されたファイル情報をもとに、ファイルパスを作成しています。 14-15行目 使用するURLです。 17-19行目 URLを実行しイメージデータを取得しています。 21行目 取得したイメージデータを、Image View に設定しています。 コンテンツリストの表示 コンテンツリストの取得は、 command.cgi の op=100、 op=101 を使用します。 取得方法については、別項の iOS Tutorial 2:コンテンツリストの取得 を参照してください。 今回は取得結果を、Table View に設定しています。 FSViewController.h #import &lt;UIKit/UIKit.h&gt; #import &quot;FSImageViewController.h&quot; @interface FSViewController : UIViewController{ @private NSArray *files; NSString *count; NSString *rowdata; } @property (strong, nonatomic) IBOutlet UILabel *labelCount; @property (strong, nonatomic) IBOutlet UILabel *labelDirectory; @property (strong, nonatomic) IBOutlet UITableView *tableViewFileList; - (IBAction)buttonPush:(id)sender; - (void)getFileList:(NSString*)path; @end 2行目 イメージファイルを表示する側の View Controller の property に、選択されたファイル情報を渡す必要があるので、サブクラスを importしています。 6-8行目 files, count： command.cgiのop=100,op=101 で取得した結果をそれぞれ管理します。 rowdata：選択中の行のファイル情報を管理します。 FSViewController.m コンテンツリスト取得 - (void)getFileList:(NSString *)path{ NSError *error = nil; // Get file list // Make url NSURL *url100 = [NSURL URLWithString:[@&quot;http://flashair/command.cgi?op=100&amp;DIR=&quot; stringByAppendingString: path]]; // Run cgi NSString *dirStr = [NSString stringWithContentsOfURL:url100 encoding:NSUTF8StringEncoding error:&amp;error]; if ([error.domain isEqualToString:NSCocoaErrorDomain]){ NSLog(@&quot;error100 %@ n&quot;,error); return; } files = [dirStr componentsSeparatedByString:@&quot; n&quot;]; // Get the number of files // Make url NSURL *url101 = [NSURL URLWithString:[@&quot;http://flashair/command.cgi?op=101&amp;DIR=&quot; stringByAppendingString: path]]; // Run cgi NSString *cntStr = [NSString stringWithContentsOfURL:url101 encoding:NSUTF8StringEncoding error:&amp;error]; if ([error.domain isEqualToString:NSCocoaErrorDomain]) { NSLog(@&quot;error101 %@ n&quot;,error); return; } count = cntStr; // Display results self.labelCount.text = [@&quot;Items Found:&quot; stringByAppendingString:cntStr]; if(![path isEqualToString:@&quot;/&quot;]){ self.labelDirectory.text = [path stringByAppendingString:@&quot;/&quot; ]; }else{ self.labelDirectory.text = @&quot;/&quot;; } } 7-16行目 command.cgiのop=100を実行し、結果をインスタンス変数に設定しています。 20-29行目 command.cgiのop=101を実行し、結果をインスタンス変数に設定しています。 32-37行目 各結果をlabelDirectoryに設定しています。 FSViewController.m tableView(1) セルの列数、行数を設定 - (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView { // Return the number of sections. return 1; } - (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section { // Return the number of rows in the section. return [count intValue]; } 4,10行目 Table View のセルの個数を設定しています。 FSViewController.m tableView(2) セルのテキストを設定 - (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath { static NSString *CellIdentifier = @&quot;Cell&quot;; UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:CellIdentifier forIndexPath:indexPath]; // Configure the cell... if (cell == nil) { cell = [[UITableViewCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:CellIdentifier]; } NSString *filename = [[[files objectAtIndex:indexPath.row + 1] componentsSeparatedByString:@&quot;,&quot;] objectAtIndex:1]; unsigned char attribute = [[[[files objectAtIndex:indexPath.row + 1] componentsSeparatedByString:@&quot;,&quot;] objectAtIndex:3] intValue]; // If it is folder if ((attribute &amp; 0x10) != 0) { filename = [filename stringByAppendingString:@&quot;/&quot; ]; }else{ NSArray *name_array = [filename componentsSeparatedByString:@&quot;.&quot;]; NSString *ext = [[name_array objectAtIndex:[name_array count]-1] lowercaseString]; if (!([ext isEqualToString:@&quot;jpg&quot;] || [ext isEqualToString:@&quot;jpeg&quot;] || [ext isEqualToString:@&quot;png&quot;] || [ext isEqualToString:@&quot;jpe&quot;])) { [cell setUserInteractionEnabled:NO]; } } cell.textLabel.text = filename; return cell; } 3-11行目 処理対象のセルを取得しています。 13-28行目 ファイル名、ファイルの属性を取得しています。 フォルダ、ファイル毎に表示用の調整を行っています。 29行目 取得したファイル名を、textLabelに設定しています。 コンテンツリストの動作 作成したコンテンツリストがタップされた際の動作です。 イメージファイルが選択された際の処理と、フォルダまたは back がタップされた際の処理を実装します。 コンテンツリストがタップされた際の動作です。 FSViewController.m tableView 動作 - (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath { // Navigation logic may go here. Create and push another view controller. rowdata = [files objectAtIndex:indexPath.row + 1]; NSString *dir = [[rowdata componentsSeparatedByString:@&quot;,&quot;] objectAtIndex:0]; NSString *filename = [[rowdata componentsSeparatedByString:@&quot;,&quot;] objectAtIndex:1]; NSString *filePath = [[dir stringByAppendingString:@&quot;/&quot;] stringByAppendingString:filename]; // If it is folder if(([[[rowdata componentsSeparatedByString:@&quot;,&quot;] objectAtIndex:3] intValue] &amp; 0x10) != 0){ [self getFileList:filePath]; [self.tableViewFileList reloadData]; }else{ [self performSegueWithIdentifier:@&quot;imageView&quot; sender:self]; } [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. } - (void) prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender { // Give next View the Data if ([segue.identifier isEqualToString:@&quot;imageView&quot;]) { FSImageViewController *iamgeViewController = segue.destinationViewController; iamgeViewController.fileInfo = rowdata; } } 4-15行目 フォルダが選択された場合は、再度command.cgiを使用してフォルダの中身を取得したのち、 Table View に設定しています。 ファイルが選択された場合は、イメージファイル表示用の View Controller を呼び出しています。 24-26行目 イメージファイル表示用の View Controller に、選択されたコンテンツの情報を引き渡しています。 back がタップされた際の動作です。 FSViewController.m buttonPush動作 - (IBAction)buttonPush:(id)sender { NSString *path = [self.labelDirectory.text substringToIndex:[self.labelDirectory.text length] - 1]; NSRange found = [path rangeOfString:@&quot;/&quot; options:NSBackwardsSearch]; if(found.location != NSNotFound){ if (found.location == 0) { path = @&quot;/&quot;; }else{ path = [path substringToIndex:found.location]; } }else{ path = @&quot;/&quot;; } // Reload tableview [self getFileList:path]; [self.tableViewFileList reloadData]; } 1-14行目 戻り先のパスを作成しています。 17-18行目 作成したパスをもとに、再度command.cgiを使用してコンテンツを取得し、 Table View に設定しています。 実行結果 プログラムが出来上がったら、確認をしてみましょう。 Table View 上の、IMG_2340.JPG をタップしたのち、該当のイメージファイルが表示されました。 以上で、コンテンツのダウンロード に関する解説はおわりです。 サンプルコード ios_tutorial_03.zip (25KB) このサイトのサンプルコードは二条項BSDライセンスで提供されています。",
    "url": "http://localhost:4000/docs/tutorials/ios/3.html",
    "relUrl": "/docs/tutorials/ios/3.html"
  },
  "22": {
    "id": "22",
    "title": "インターネット同時接続モードの利用",
    "content": "インターネット同時接続モードの利用 インターネット同時接続モードを使うと、PCやスマートフォンなどのデバイスからFlashAirを経由して、インターネットなどの別のネットワークと通信することができます。本チュートリアルでは、インターネット同時接続モードに設定する方法を解説します。 概要 アクセスポイントモード 通常、FlashAirはアクセスポイント（AP）モードになっており、いわゆる無線LAN親機として動作しています。 PCやスマートフォンなどのデバイスは、無線LAN子機としてFlashAirに接続します。 FlashAirに接続中は、他の無線LAN親機とは接続できません。 このため、インターネットにアクセスできなくなったりします。 インターネット同時接続モード インターネット同時接続モードが有効な場合、FlashAirのアクセスポイント（AP）とステーション（STA）の両方の機能が同時に動作し、 FlashAirを親機とするデバイス（AP側）とFlashAirの親機（STA側）の間の通信を中継（ルーティング）します。 STA側の無線LANにインターネット接続を設定しておけば、 PCやスマートフォンなどのデバイスが無線LAN子機としてFlashAirに接続した場合も、 FlashAirを経由してインターネット通信が可能となります ステーションモードとインターネット同時接続モードの違い FlashAirとインターネットの同時接続は、 インターネットに接続された無線LAN親機があれば、 STAモードにしたFlashAirをその子機とすることでも可能です。 しかし、インターネット同時接続モードでは、 インターネット接続に加えてAPモードがもつ下記のようなメリットを得られます。 無線LAN親機のない環境、例えば屋外などでも、FlashAirに接続できます。 STAモードにしたFlashAirへの接続には、無線LAN親機を経由する必要があります。 ゲストにFlashAirの写真を閲覧させる場合には、FlashAirのSSIDとパスワードを教えればOKです。STAモードのFlashAirの写真を閲覧させたい場合には、無線LAN親機のSSIDとパスワードを教えなければなりません。 対応FlashAir 本機能を利用するには、Class10モデルのFlashAirとファームウェアバージョン2.00.02以上が必要です。 重要 Class6モデルでは利用できません。 設定方法 インターネット同時接続モードを使用する、 FlashAirの動作モードや無線LANの情報、FlashAirカードを識別する名前の設定などを行う必要があります。 変更には、設定ファイルを直接変更する方法と、config.cgiを利用する方法の2通りがあります。 変更する項目 以下の6つの情報を設定する必要があります。括弧内は APIガイド / CONFIGファイルの対応するパラメータ名です。 動作モード (APPMODE) パラメータに6または3を指定し、インターネット同時接続モードに変更します。 FlashAir（AP側） 無線LAN SSID (APPSSID) 任意のSSIDを指定します。 FlashAir（AP側） 無線LAN ネットワークセキュリティキー (APPNETWORKKEY) 任意のネットワークセキュリティキー（パスワード）を指定します。 インターネット（STA側） 無線LAN SSID (BRGSSID) 接続先無線LANのSSIDを指定します。 インターネット（STA側） 無線LAN ネットワークセキュリティキー (BRGNETWORKKEY) 接続先無線LANのネットワークセキュリティキー（パスワード）を指定します。 FlashAir識別名 (APPNAME) 接続先無線LANの中でFlashAirカードを特定するための名前を指定します。 方法1: 設定ファイルを直接編集する /SD_WLAN/CONFIGをエディタ等で開き、前述のパラメータを編集します。このフォルダは隠しフォルダとなっていますので、隠しフォルダを扱う事が出来るツールを使いましょう。 (Macの場合は/Volumes/(ボリュームラベル名)/SD_WLAN/CONFIGです。) パラメータが存在しない場合は新しく行を追加してください。 パラメータの順序は問いません。 編集後は、たとえば下記のようになります。 APPMODE=6 APPNAME=myflashair APPSSID=FOOSSID APPNETWORKKEY=password0123 VERSION=F19BAW3AW2.00.02 CID=02544d535731364708d0ca497800d501 PRODUCT=FlashAir VENDOR=TOSHIBA UPLOAD=1 MASTERCODE=70dee243a2c2 LOCK=1 BRGSSID=LANSSID BRGNETWORKKEY=lanpassword0123 方法2: config.cgiを利用する場合 FlashAir識別名(APPNAME)以外の項目については、 config.cgiを使用してネットワーク経由で変更することもできます。 設定変更にはマスターコードが必要になります。未設定ならば、事前に設定しておきましょう。 マスターコードを設定するためのCGI呼び出し例： http://flashair/config.cgi?MASTERCODE=70dee243a2c2 パラメータを変更するためのCGI呼び出し例： http://flashair/config.cgi?MASTERCODE=70dee243a2c2&amp;APPMODE=6&amp;BRGSSID=LANSSID&amp;BRGNETWORKKEY=lanpassword0123 コマンドを発行するとFlashAirが再起動するため、一時的に通信が切断されます。 FlashAirへのアクセス方法 PCやスマートフォンのデバイスからインターネット同時接続モードに設定されたFlashAirへアクセスするには、 APモードと同様、FlashAirの無線LANネットワークに接続します。 また、STAモード同様、無線LAN親機経由でもアクセスできます。 STAモードでの接続方法と使用上の注意は 上級者向けチュートリアル - ステーションモードの利用 を参照してください。 使用上の注意 インターネット側無線LAN親機がない環境での動作 インターネット同時接続モードの場合、最初にFlashAirはインターネット側（STA側）の接続を試み、 その後、FlashAirの無線LAN（AP側）を起動します。 インターネット側無線LAN親機がない環境では、STA側の接続試行がタイムアウトするまで待つため、 FlashAirのSSIDが利用可能になるまで、時間がかかる場合があります。 重要 アクセス制限不備の脆弱性について インターネット同時接続機能を有効にすると、インターネット接続側ネットワークから認証なしで接続可能になります。 当該製品が接続するインターネット接続側無線 LAN にアクセス可能な第三者によって、当該製品に記録されているファイルやデータを取得される可能性があります。 さらに、FlashAir W-03 で認証に関する設定を追加せずに WebDAV によるアクセスとファイルアップロードを許可するよう設定している場合、当該製品に記録されているファイルやデータを改ざんされたり、任意の Lua スクリプトを実行されたりする可能性があります。 インターネット同時接続機能を有効にする場合は、ウェブサーバへの接続時に認証を要求するよう、下記のCONFIGパラメータを設定してください。 HTTPDMODE — 認証方法 HTTPDUSER — Basic認証のユーザ名 HTTPDPASS — Basic認証のパスワード、Digest認証のハッシュ値 脆弱性に関してはFAQもあわせて参照ください。",
    "url": "http://localhost:4000/docs/tutorials/advanced/3.html",
    "relUrl": "/docs/tutorials/advanced/3.html"
  },
  "23": {
    "id": "23",
    "title": "HTTPを利用したファイルのダウンロード",
    "content": "HTTPを利用したファイルのダウンロード Luaをつかえば、FlashAirがHTTP（またはFTPなど他のプロトコルを使って）でファイルをダウンロードすることができます。 HTTPを使う場合は、HTTPGetFileリクエストを実行するだけです。 例えば、FlashAirのロゴ画像を取得するには、下記のluaスクリプトを作成し、 FlashAirでLuaを実行するにあるいずれかの方法で実行すればOKです。 /HTTPGetFile.lua result = fa.HTTPGetFile(&quot;https://flashair-developers.com/images/assets/flashairLogo_official_small.png&quot;, &quot;logo.png&quot;) if result ~= nil then print(&quot;Success! File downloaded. n&quot;) --process the file else print(&quot;Failure! File failed to download... n&quot;) end Luaスクリプト実行後、ルートフォルダにlogo.pngが表示されます。 FlashAirへのHTTPアクセス時に実行するで実行した場合、ブラウザにスクリプトの標準出力が表示されます。 WebDAV等パスワードによるアクセス制限がかかっているファイルの場合は， HTTPリクエストにユーザー名とパスワードを指定します。 /HTTPGetFileofAccessLimit.lua result = fa.HTTPGetFile(&quot;http://somewhere/secretfile.txt&quot;, &quot;secretfile.txt&quot;, &quot;aUser&quot;, &quot;passw0rd&quot;) if result ~= nil then ... (snip) ... サンプルコード リポジトリを見る（GitHub） このサイトのサンプルコードは二条項BSDライセンスで提供されています。",
    "url": "http://localhost:4000/docs/tutorials/lua/3.html",
    "relUrl": "/docs/tutorials/lua/3.html"
  },
  "24": {
    "id": "24",
    "title": "コンテンツのダウンロード",
    "content": "コンテンツのダウンロード 　 このチュートリアルでは、コンテンツのダウンロード方法について学びます。 使用するCGIは command.cgi です。 このチュートリアルは別項の Android Tutorial 2:コンテンツリストの取得 に基づいています。 現在のコンテンツリストを取得し ListView に表示します。 リストに表示されたフォルダをクリック（タップ）した場合、そのフォルダの中身を表示します。イメージファイルをクリック（タップ）した場合は、そのファイルをダウンロードし、画面に表示します。 レイアウトは、コンテンツリストの上にコンテンツ数を表示し、その上に現在のフォルダパスを表示します。 また、一つ上のフォルダへ戻るための Button も配置します(例. 現在のフォルダが ‘DCIM/106 ___05/’ である場合は、 ‘DCIM/’ へ移動します)。 このようにレイアウトを設定します: コンテンツリストのイメージファイルをクリックすると、 画像はこのように表示されます: 表示されているとおり、Android 端末に画像ファイルがダウンロードされます。 アプリケーションを作成するために、次のファイルを作成します : MainActivity.java activity_main.xml ImageViewActivity.java activity_image_view.xml 重要: Android application は、デフォルトの状態ではインターネットにアクセスすることができません。 そのため、設定ファイル AndroidManifest.xml を変更し、権限を与える必要があります。 パス: [Project_Folder]/AndroidManifest.xml AndroidManifest.xml に以下のコードを追加してください: &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt; リストのレイアウト作成 ではまず、 activity_main.xml を記述して、レイアウトを決定します。 このファイルは、layout フォルダに配置されています。 パス: [Project_Folder]/res/layout/activity_main.xml activity_main.xml に以下のように記述してください: activity_main.xml &lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;fill_parent&quot; android:layout_height=&quot;match_parent&quot; android:gravity=&quot;center_horizontal&quot; android:orientation=&quot;vertical&quot; tools:context=&quot;.MainActivity&quot; &gt; &lt;Button android:id=&quot;@+id/button1&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:cacheColorHint=&quot;#00000000&quot; android:text=&quot;Back&quot; android:textColor=&quot;@android:color/white&quot; android:textSize=&quot;20sp&quot; /&gt; &lt;TextView android:id=&quot;@+id/textView1&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:gravity=&quot;center_horizontal&quot; android:scaleType=&quot;centerInside&quot; android:text=&quot;Directory Name&quot; android:textAlignment=&quot;center&quot; android:textAppearance=&quot;?android:attr/textAppearanceLarge&quot; /&gt; &lt;TextView android:id=&quot;@+id/textView2&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:gravity=&quot;center_horizontal&quot; android:scaleType=&quot;centerInside&quot; android:text=&quot;Number of files&quot; android:textAlignment=&quot;center&quot; android:textAppearance=&quot;?android:attr/textAppearanceLarge&quot; android:textSize=&quot;20sp&quot; /&gt; &lt;ListView android:id=&quot;@+id/listView1&quot; android:layout_width=&quot;fill_parent&quot; android:layout_height=&quot;match_parent&quot; android:cacheColorHint=&quot;#00000000&quot; android:clickable=&quot;true&quot; android:headerDividersEnabled=&quot;false&quot; /&gt; &lt;/LinearLayout&gt; イメージビューのレイアウト作成 次に、 activity_image_view.xml を記述して、レイアウトを決定します。 このファイルは、layout フォルダに配置されています。 パス: [Project_Folder]/res/layout/activity_image_view.xml activity_image_view.xml に以下のように記述してください: activity_image_view.xml &lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot; tools:context=&quot;.ImageViewActivity&quot; &gt; &lt;Button android:id=&quot;@+id/button2&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:cacheColorHint=&quot;#00000000&quot; android:text=&quot;Back&quot; android:textColor=&quot;@android:color/white&quot; android:textSize=&quot;20sp&quot; /&gt; &lt;ImageView android:id=&quot;@+id/imageView1&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;fill_parent&quot; android:scaleType=&quot;centerInside&quot; android:contentDescription=&quot;view image&quot; android:text=&quot;image would be here&quot; /&gt; &lt;/LinearLayout&gt; イメージビューのアクティビティ作成 次に、 AndroidManifest.xml を記述して、アクティビティを追加します。 パス: [Project_Folder]/AndroidManifest.xml AndroidManifest.xml の application タグに以下のように記述してください: AndroidManifest.xml &lt;activity android:name=&quot;com.example.android_tutorial_03.ImageViewActivity&quot; android:label=&quot;@string/app_name&quot; &gt; &lt;/activity&gt; コンテンツリストの作成 さて、 MainActivity.java を修正します。 デフォルトでは次のようになります: MainActivity.java import android.os.Bundle; import android.app.Activity; import android.view.Menu; public class MainActivity extends Activity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); } @Override public boolean onCreateOptionsMenu(Menu menu) { // Inflate the menu; this adds items to the action bar if it is present. getMenuInflater().inflate(R.menu.main, menu); return true; } } 初期化 リストの項目をクリックした場合の処理を記述するため、クラス宣言にOnClickListenerを追加します。 MainActivity.java (1) public class MainActivity extends Activity implements AdapterView.OnItemClickListener { 使用予定のビューのうちの1つの宣言をし、その他のクラス変数の宣言や画面の初期設定を行います。 また、 onCreate(Bundle savedInstanceState) をオーバーライドし、アクティビティクラスの初期化も行います。 コンテンツリストの初期設定や一つ上のフォルダへ戻るための Buttonのクリックリスナーも設定します。 MainActivity.java (2) ListView listView; ImageView imageView; TextView currentDirText; TextView numFilesText; Button backButton; String rootDir = &quot;DCIM&quot;; String directoryName = rootDir; // Initialize to rootDirectory ArrayAdapter&lt;String&gt; listAdapter; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); // Set buttons getWindow().setTitleColor(Color.rgb(65, 183, 216)); backButton = (Button)findViewById(R.id.button1); backButton.getBackground().setColorFilter(Color.rgb(65, 183, 216), PorterDuff.Mode.SRC_IN); backButton.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { if(directoryName.equals(rootDir)) { listRootDirectory(); } else { int index = directoryName.lastIndexOf(&quot;/&quot;); directoryName = directoryName.substring(0, index); listDirectory(directoryName); } } }); backButton.setEnabled(false); // Disable in root directory listRootDirectory(); } @Override public boolean onCreateOptionsMenu(Menu menu) { // Inflate the menu; this adds items to the action bar if it is present. getMenuInflater().inflate(R.menu.main, menu); return true; } 17-32行目 ユーザーがButton をクリックした際、一つ上のフォルダへ行けるように設定しています。 元々表示しているルートフォルダは、それより上のフォルダへは移動できないため、ボタンを無効にしています。 ルートのフォルダを”DCIM”としていますが(6行目)、こちらは同じように設定をする必要はありません。 販売されている多くのデジタルカメラが撮影した画像を “DCIM” フォルダへ格納しているので、ここでは “DCIM” を設定しました。 ルートフォルダのコンテンツ情報取得 上記で呼ばれている listRootDirectory() と listDirectory(directoryName) は、FlashAir に処理を要求しコンテンツを取得しています。 listRootDirectory() は、単にクラス変数 directoryName にルートフォルダを設定し listDirectory(String dir) を呼び出しています: MainActivity.java (3) public void listRootDirectory() { directoryName = rootDir; listDirectory(directoryName); } その他のフォルダのコンテンツ情報取得 現在のフォルダがルートフォルダである場合に、back ボタンの制御を行います。 MainActivity.java (4) public void listDirectory(String dir) { // Prepare command directory path if(dir.equals(rootDir)) { backButton.setEnabled(false); } else { backButton.setEnabled(true); } 3-8行目 back ボタンの有効/無効を制御しています。 ルートフォルダを表示中の場合は、それより上の階層へ移動できいないためです。 その結果、画面はこのようになります: それ以外のフォルダを表示している場合は、ボタンは有効でありクリックすることができます。 ファイル数を取得するためには、以下のコマンドを使用します。 ファイル数は、command.cgi にop=101 とフォルダパスを指定することで取得できます。 コマンド: http://flashair/command.cgi?op=101&amp;DIR=/DCIM コマンドが返す情報: &lt;NumberofItems&gt; ファイルデータを取得するためには、以下のコマンドを使用します。 ファイルデータは、command.cgi にop=100 とフォルダパスを指定することで取得できます。 コマンド:http://flashair/command.cgi?op=100&amp;DIR=/DCIM コマンドが返す情報:&lt;Directory&gt;,&lt;Filename&gt;,&lt;Size&gt;,&lt;Attribute&gt;,&lt;Date&gt;,&lt;Time&gt; コマンドの実行には前項 Android Tutorial 2:コンテンツリストの取得 と同じく、 FlashAirRequest.java を使用します。 MainActivity.java (5) currentDirText = (TextView)findViewById(R.id.textView1); currentDirText.setText(dir + &quot;/&quot;); // Fetch number of items in directory and display in a TextView dir = &quot;/&quot; + dir; ArrayList &lt;NameValuePair&gt; httpParams = new ArrayList &lt;NameValuePair&gt; (); httpParams.add(new BasicNameValuePair(&quot;DIR&quot;, dir)); dir = URLEncodedUtils.format (httpParams, &quot;UTF-8&quot; ); numFilesText = (TextView)findViewById(R.id.textView2); // Fetch number of items in directory and display in a TextView new AsyncTask&lt;String, Void, String&gt;(){ @Override protected String doInBackground(String... params) { String dir = params[0]; String fileCount = FlashAirRequest.getString(&quot;http://flashair/command.cgi?op=101&amp;&quot; + dir); return fileCount; } @Override protected void onPostExecute(String fileCount) { numFilesText.setText(&quot;Items Found: &quot; + fileCount); } }.execute(dir); 7行目 返される文字のエンコードは、ここでは UTF-8 を使用します。 command.cgi の op=100 は指定したフォルダの以下の情報を返します: &lt;Directory&gt;,&lt;Filename&gt;,&lt;Size&gt;,&lt;Attribute&gt;,&lt;Date&gt;,&lt;Time&gt; 今回使用するのは、ファイル名のみです。 CGIコマンド実行後、ファイル名のみを取り出すよう調整する必要があります。 また、クラスが現在とルートのフォルダを管理しているので、手動でフォルダ名をCGIに渡す必要はなく、代わりに関数から渡されたフォルダ名を使用します。 MainActivity.java (6) // Fetch list of items in directory and display in a ListView new AsyncTask&lt;String, Void, ListAdapter&gt;(){ @Override protected ListAdapter doInBackground(String... params) { String dir = params[0]; ArrayList &lt;String&gt; fileNames = new ArrayList &lt;String&gt;(); String files = FlashAirRequest.getString(&quot;http://flashair/command.cgi?op=100&amp;&quot; + dir); String[] allFiles = files.split(&quot;([, n])&quot;); // split by newline or comma for(int i = 2; i &lt; allFiles.length; i= i + 6) { if(allFiles[i].contains(&quot;.&quot;)) { // File fileNames.add(allFiles[i]); } else { // Directory, append &quot;/&quot; fileNames.add(allFiles[i] + &quot;/&quot;); } } listAdapter = new ArrayAdapter&lt;String&gt;(MainActivity.this, android.R.layout.simple_list_item_1, fileNames); return listAdapter; } @Override protected void onPostExecute(ListAdapter listAdapter) { // Set the file list to a widget listView = (ListView)findViewById(R.id.listView1); ColorDrawable divcolor = new ColorDrawable(Color.rgb(17, 19, 58)); listView.setDivider(divcolor); listView.setDividerHeight(1); listView.setAdapter(listAdapter); listView.setOnItemClickListener(MainActivity.this); } }.execute(dir); 8-17行目 フォルダであるか、ファイルであるのかをチェックしています。 フォルダの場合は、表示する際最後に “/”を付加しています。これはフォルダの場合の標準的な記述方法です。 さらにこの仕組は、コンテンツリストをクリックした際の、フォルダとファイルで処理を分けるためにも使用します。 コンテンツリストのクリックリスナー設定 MainActivity クラスは現時点では、コンテンツリストは表示されますがクリックすることができません。 このため、OnItemClickListener をMainActivity に定義します。 この特別なクリックリスナーは、単にリストをクリックしたことを把握するだけではなく、どのコンテンツをクリックしたのかを識別します。 リストは次のように設定します: フォルダをクリックした場合は、選択したフォルダのコンテンツを表示した画面を表示します。 ファイルをクリックした場合は、ファイルをダウンロードし、ダウンロードした画像を表示しした画面を表示します。 元のonItemClick は、&lt; AdapterView&lt;?&gt; l, View v, int position, long id &gt; といった引数です。 オーバーライドするため、これらの引数も渡します。 MainActivity.java (7) @Override public void onItemClick(AdapterView&lt;?&gt; l, View v, int position, long id) { Object downloadFile = l.getItemAtPosition(position); // get item at clicked position in list of files if(downloadFile.toString().endsWith(&quot;/&quot;)) { // Directory, remove &quot;/&quot; and show content list String dirName = downloadFile.toString().substring(0, downloadFile.toString().length()-1); // all but the &quot;/&quot; directoryName = directoryName + &quot;/&quot; + dirName; listDirectory(directoryName); } else if( downloadFile.toString().toLowerCase(Locale.getDefault()).endsWith(&quot;.jpg&quot;) || downloadFile.toString().toLowerCase(Locale.getDefault()).endsWith(&quot;.jpeg&quot;) || downloadFile.toString().toLowerCase(Locale.getDefault()).endsWith(&quot;.jpe&quot;) || downloadFile.toString().toLowerCase(Locale.getDefault()).endsWith(&quot;.png&quot;) ) { // Image file, download using ImageViewActivity Intent viewImageIntent = new Intent(this, ImageViewActivity.class); viewImageIntent.putExtra(&quot;downloadFile&quot;, downloadFile.toString()); viewImageIntent.putExtra(&quot;directoryName&quot;, directoryName); MainActivity.this.startActivity(viewImageIntent); } } } // End MainActivity class 12行目 実際にファイルをダウンロードし表示するのは２つめのクラス (class ImageViewActivity)なので、Intent を作成します。 class ImageViewActivity は、ファイルをダウンロードし表示するので、ファイル名 (downloadFile.toString()) と フォルダパス (directoryName) にアクセス可能である必要があります。 13-14行目 Intentに、上記の値を設定します。これにより、ImageViewActivity 生成時に、この値が渡されます。 イメージビューの作成 初期化 このクラスもまたActivity クラスを拡張したクラスです。 画像を表示するためのImageView と コンテンツリスト画面へ戻るためのButtonを設定します。 クラス宣言は次のようになります: ImageViewActivity.java (1) public class ImageViewActivity extends Activity { ImageView imageView; Button backButton; onCreate(Bundle savedInstanceState) と onCreateOptionsMenu(Menu menu) をオーバーライドする必要もあります。 onCreate(Bundle savedInstanceState) にて、 back ボタンの動作を設定します。 ImageViewActivity.java (2) @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_image_view); getIntent(); imageView = (ImageView)findViewById(R.id.imageView1); backButton = (Button)findViewById(R.id.button2); getWindow().setTitleColor(Color.rgb(65, 183, 216)); backButton.getBackground().setColorFilter(Color.rgb(65, 183, 216), PorterDuff.Mode.SRC_IN); Bundle extrasData = getIntent().getExtras(); String fileName = extrasData.getString(&quot;downloadFile&quot;); String directory = extrasData.getString(&quot;directoryName&quot;); downloadFile(fileName, directory); } @Override public boolean onCreateOptionsMenu(Menu menu) { // Inflate the menu; this adds items to the action bar if it is present. getMenuInflater().inflate(R.menu.image_view, menu); return true; } 10行目 Intentを宣言した際class MainActivity から渡したデータを読み込んでいます。 11-12行目 読み込んだ各値を保存しています。 ファイルのダウンロード 次に, FlashAir からファイルをダウンロードする機能を実装します。 CGIコマンドを実行し結果のBitmap を返す、getBitmap() を前項Android Tutorial 2:コンテンツリストの取得 で作成した FlashAirRequest.java に追加します。 FlashAirRequest.java static public Bitmap getBitmap(String command) { Bitmap resultBitmap = null; try{ URL url = new URL(command); URLConnection urlCon = url.openConnection(); urlCon.connect(); InputStream inputStream = urlCon.getInputStream(); ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); byte[] byteChunk = new byte[1024]; int bytesRead = 0; while( (bytesRead = inputStream.read(byteChunk)) != -1) { byteArrayOutputStream.write(byteChunk, 0, bytesRead); } byte[] byteArray = byteArrayOutputStream.toByteArray(); BitmapFactory.Options bfOptions = new BitmapFactory.Options(); bfOptions.inPurgeable = true; resultBitmap = BitmapFactory.decodeByteArray(byteArray, 0, byteArray.length, bfOptions); byteArrayOutputStream.close(); inputStream.close(); }catch(MalformedURLException e) { Log.e(&quot;ERROR&quot;, &quot;ERROR: &quot; + e.toString()); e.printStackTrace(); } catch(IOException e) { Log.e(&quot;ERROR&quot;, &quot;ERROR: &quot; + e.toString()); e.printStackTrace(); } return resultBitmap; } 15-16行目 メモリーを有効活用するために、解放可能なBitmap を生成しています。 Intent により渡したファイル名とフォルダパスからパスを作成し、ファイルをダウンロードします。 ファイルのダウンロードには、FlashAirRequest.java に追加した getBitmap()を使用します。 ImageViewActivity.java (3) void downloadFile(String downloadFile, String directory) { final ProgressDialog waitDialog; // Setting ProgressDialog waitDialog = new ProgressDialog(this); waitDialog.setMessage(&quot;Now downloading...&quot;); waitDialog.setProgressStyle(ProgressDialog.STYLE_SPINNER); waitDialog.show(); // Download file new AsyncTask&lt;String, Void, Bitmap&gt;(){ @Override protected Bitmap doInBackground(String... params) { String fileName = params[0]; return FlashAirRequest.getBitmap(fileName); } @Override protected void onPostExecute(Bitmap resultBitmap) { waitDialog.dismiss(); viewImage(resultBitmap); } }.execute(&quot;http://flashair/&quot; + directory + &quot;/&quot; + downloadFile.toString()); } 画像を表示する Bitmap イメージを読み込んだ後、上記の関数でviewImage() を呼び出すと、画像が表示されます。 この関数では画像の表示にImageView を使用しています。 ImageViewActivity.java (4) lined: void viewImage(Bitmap imageBitmap) { // Show image in ImageView backButton.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { ImageViewActivity.this.finish(); } }); if (imageBitmap == null) { imageView.setImageResource(R.drawable.ic_launcher); } else { imageView.setImageBitmap(imageBitmap); } } } // End ImageViewActivity class 実行結果 画像はこのように表示されます: サンプルコード android_tutorial_03.zip (539KB) このサイトのサンプルコードは二条項BSDライセンスで提供されています。",
    "url": "http://localhost:4000/docs/tutorials/android/3.html",
    "relUrl": "/docs/tutorials/android/3.html"
  },
  "25": {
    "id": "25",
    "title": "コンテンツリストの取得2",
    "content": "コンテンツリストの取得2 FlashAirに保存されたコンテンツのリストを取得する方法について学びます。 コンテンツリストの取得1では、HTMLへ埋め込まれるファイルリストを利用しましたが、 CGIだけを使って同じことを実現することもできます。 command.cgiを使ってフォルダ一覧を取得してみましょう。 事前準備 コンテンツリストの取得1と同様に、 jQueryを ダウンロードし、FlashAirに /SD_WLAN/js/jquery.jsとして保存します。 画面レイアウトの作成 ブラウザユーティリティ本体となるHTMLファイルを作成します。 コンテンツリストの取得1で作成したものとよく似ていますが、 ファイルリストの差し込みをするためのスクリプト部分はありません。 それ以外は、重要な２つの仕事、１つはJavaScriptをロードすること、 もう１つはそのJavaScriptが画面要素を書き込むための &lt;div&gt;タグを用意すること、を行っています。 作成したファイルは必ず、FlashAirの /SD_WLAN/List.htmに保存してください。 /SD_WLAN/List.htm &lt;!doctype html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;FlashAir&lt;/title&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;/SD_WLAN/js/jquery.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;/SD_WLAN/js/main.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;header&quot;&gt; &lt;h1&gt;header&lt;/h1&gt; &lt;/div&gt; &lt;hr&gt; &lt;div id=&quot;list&quot;&gt; &lt;/div&gt; &lt;hr&gt; &lt;div id=&quot;footer&quot;&gt; footer &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 6,7行目 jquery.jsと、次に作成するmain.jsをロードしています。 14行目 listというid属性を持つdivタグを宣言しています。この中にフォルダのファイルリストが挿入されます。 コードの作成 CGIコマンドでフォルダリストを取得し、それを読みやすい形でHTMLに挿入する作業を、JavaScriptで記述します。 getFileList(dir)関数でCGIコマンドを発行してファイル一覧を取得し、 showFileList(path)では取得した一覧を元に、HTMLの要素を作成するという流れになっています。 コンテンツリストの取得1で作成したヘルパー関数を再利用しましょう。 ただし、 isV1(wlansd)は今回は使用していません。 作成したファイルはFlashAirの /SD_WLAN/js/main.jsというファイルとして保存しましょう。 /SD_WLAN/js/main.js // JavaScript Document // Judge the card is V1 or V2. function isV1(wlansd) { if ( wlansd.length == undefined || wlansd.length == 0 ) { // List is empty so the card version is not detectable. Assumes as V2. return false; } else if ( wlansd[0].length != undefined ) { // Each row in the list is array. V1. return true; } else { // Otherwise V2. return false; } } // Convert data format from V1 to V2. function convertFileList() { for (var i = 0; i &lt; wlansd.length; i++) { var elements = wlansd[i].split(&quot;,&quot;); wlansd[i] = new Array(); wlansd[i][&quot;r_uri&quot;] = elements[0]; wlansd[i][&quot;fname&quot;] = elements[1]; wlansd[i][&quot;fsize&quot;] = Number(elements[2]); wlansd[i][&quot;attr&quot;] = Number(elements[3]); wlansd[i][&quot;fdate&quot;] = Number(elements[4]); wlansd[i][&quot;ftime&quot;] = Number(elements[5]); } } // Callback Function for sort() function cmptime(a, b) { if( a[&quot;fdate&quot;] == b[&quot;fdate&quot;] ) { return a[&quot;ftime&quot;] - b[&quot;ftime&quot;]; }else{ return a[&quot;fdate&quot;] - b[&quot;fdate&quot;]; } } // Show file list function showFileList(path) { // Clear box. $(&quot;#list&quot;).html(&#39;&#39;); // Output a link to the parent directory if it is not the root directory. if( path != &quot;/&quot; ) { $(&quot;#list&quot;).append( $(&quot;&lt;div&gt;&lt;/div&gt;&quot;).append( $(&#39;&lt;a href=&quot;javascript:void(0)&quot; class=&quot;dir&quot;&gt;..&lt;/a&gt;&#39;) ) ); } $.each(wlansd, function() { var file = this; // Skip hidden file. if ( file[&quot;attr&quot;] &amp; 0x02 ) { return; } // Make a link to directories and files. var filelink = $(&#39;&lt;a href=&quot;javascript:void(0)&quot;&gt;&lt;/a&gt;&#39;); var caption = file[&quot;fname&quot;]; var fileobj = $(&quot;&lt;div&gt;&lt;/div&gt;&quot;); if ( file[&quot;attr&quot;] &amp; 0x10 ) { filelink.addClass(&quot;dir&quot;); } else { filelink.addClass(&quot;file&quot;).attr(&#39;href&#39;, file[&quot;r_uri&quot;] + &#39;/&#39; + file[&quot;fname&quot;]).attr(&quot;target&quot;,&quot;_blank&quot;); } // Append a file entry or directory to the end of the list. $(&quot;#list&quot;).append( fileobj.append( filelink.append( caption ) ) ); }); } //Making Path function makePath(dir) { var arrPath = currentPath.split(&#39;/&#39;); if ( currentPath == &quot;/&quot; ) { arrPath.pop(); } if ( dir == &quot;..&quot; ) { // Go to parent directory. Remove last fragment. arrPath.pop(); } else if ( dir != &quot;&quot; &amp;&amp; dir != &quot;.&quot; ) { // Go to child directory. Append dir to the current path. arrPath.push(dir); } if ( arrPath.length == 1 ) { arrPath.push(&quot;&quot;); } return arrPath.join(&quot;/&quot;); } // Get file list function getFileList(dir) { // Make a path to show next. var nextPath = makePath(dir); // Make URL for CGI. (DIR must not end with &#39;/&#39; except if it is the root.) var url = &quot;/command.cgi?op=100&amp;DIR=&quot; + nextPath; // Issue CGI command. $.get(url, function(data) { // Save the current path. currentPath = nextPath; // Split lines by new line characters. wlansd = data.split(/ n/g); // Ignore the first line (title) and last line (blank). wlansd.shift(); wlansd.pop(); // Convert to V2 format. convertFileList(wlansd); // Sort by date and time. wlansd.sort(cmptime); // Show showFileList(currentPath); }); } //Document Ready $(function() { // Iniialize global variables. currentPath = location.pathname; wlansd = new Array(); // Show the root directory. getFileList(&#39;&#39;); // Register onClick handler for &lt;a class=&quot;dir&quot;&gt; $(document).on(&quot;click&quot;,&quot;a.dir&quot;,function() { getFileList(this.text); }); }); 38-73行目 得られたファイルリストの各行に対して、アンカー(&lt;a&gt;)とボックス(&lt;div&gt;)を生成し、 HTML中に用意した表示位置($(&quot;#list&quot;))に追加しています。 コンテンツリストの取得1とよく似ていますが、 フォルダの場合はハイパーリンクに javascript:void(0)を設定してクリックしても画面遷移しないようにしています。 75-91行目 URLに使う絶対パスを作成するヘルパー関数です。 ルートフォルダである場合を除き、最後のスラッシュはつけてはならない点に注意しましょう。 93-115行目 ページ読み込み時またはフォルダがクリックされたときに起動されて、 ファイル一覧を取得する関数です。 99行目でCGIコマンドを発行しています。 FlashAirから返ってきたデータに対する処理は、 2番目の引数であるコールバック関数( function(data) {...})の内部に記述します。 これは、CGIコマンドの実行が非同期的に行われるためです。 取得したデータは113行目で表示させています。 117-127行目 本ファイルが読み込まれたときに自動的に呼び出されて、処理を実行する部分です。 119行目では表示されているフォルダのパスの初期設定をしています。 120行目は、ファイルリストを格納する配列の初期化をしています。 124行目以降では、 class=&quot;dir&quot;を持つリンクがクリックされたときに実行されるイベントハンドラ関数を割り当てています。 クリックされると、リンクのテキスト部分を引数としてgetFileList(dir)が呼び出されて、新しいコンテンツリストを取得します。 実行結果 コードをFlashAirに置いたら、FlashAirに無線LAN接続したPCまたはスマートフォンのブラウザで確認してみましょう。 例えば、以下のような画面が表示されるでしょう。 これは /DCIM/100__TSBを表示した例ですが、URLが flashairとルートのままであることに注目してください。 ファイル一覧の取得と表示をCGIとJavaScriptのみで実行しており、画面遷移を行っていないためです。 文字の大きさなどはCSSなどで工夫してみてください。 サンプルコード web_tutorial_03.zip (4KB) このサイトのサンプルコードは二条項BSDライセンスで提供されています。",
    "url": "http://localhost:4000/docs/tutorials/web/3.html",
    "relUrl": "/docs/tutorials/web/3.html"
  },
  "26": {
    "id": "26",
    "title": "FlashAirを使ったセンサーデータの無線モニタリング",
    "content": "FlashAirを使ったセンサーデータの無線モニタリング 本チュートリアルでは、FlashAirを、センサ機器の簡便な無線化オプションとして利用する方法を解説します。 システム概要 機器構成 FlashAir Arduino SDメモリカードシールド センサー 電源 外箱 機器例 写真の例では、下記の機材を使用しています。 FlashAir W-02 (容量は何でもよい) Arduino Uno R3 Seeed Studio SD Shield v4.0 Seeed Studio Groveシステム 押しボタン 電池ボックス (本来は7V以上が推奨されています) 外箱 (アクリルボックスを丁番でつなげています) 動作の説明 ブラウザで http://flashair/ を開く HTMLテンプレート (ブラウザユーティリティとも言います) は事前に作っておく必要があります。 JavaScriptで約1秒ごとにファイルを読み取り、グラフを表示 SD.hを使ってセンサーデータをファイルに追記 ソースコード Arduino側 #include &lt;SD.h&gt; const int SOUND_SENSOR = A5; const int LED = 9; int val = 0; const int TIMER_COUNTER = 34286; // 2Hz. (65536 - 16MHz/256scale/2Hz) const uint8_t SLOT_SIZE = 2; File myFile; void setup() { // Open serial communications and wait for port to open: Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for Leonardo only } Serial.print(&quot;Initializing SD card...&quot;); if (!SD.begin(4)) { Serial.println(&quot;initialization failed!&quot;); return; } Serial.println(&quot;initialization done.&quot;); if (SD.exists(&quot;TEST.TXT&quot;)) { Serial.println(&quot;TEST.TXT exists.&quot;); Serial.println(&quot;Removing TEST.TXT...&quot;); SD.remove(&quot;TEST.TXT&quot;); } else { Serial.println(&quot;TEST.TXT doesn&#39;t exist.&quot;); } pinMode(LED, OUTPUT); pinMode(SOUND_SENSOR, INPUT); // initialize Timer1 noInterrupts(); // disable all interrupts TCCR1A = 0; TCCR1B = 0; TCNT1 = TIMER_COUNTER; TCCR1B |= (1 &lt;&lt; CS12); TIMSK1 |= (1 &lt;&lt; TOIE1); // enable timer overflow interrupt interrupts(); // enable all interrupts } uint16_t counter = 0; uint8_t slot = 0; bool readyToSave = false; uint16_t value[2][SLOT_SIZE]; ISR(TIMER1_OVF_vect) { value[slot][counter] = analogRead(SOUND_SENSOR); if (++counter == SLOT_SIZE) { readyToSave = true; counter = 0; slot ^= 1; } TCNT1 = TIMER_COUNTER; // preload timer } void save(uint8_t slotToSave) { myFile = SD.open(&quot;TEST.TXT&quot;, FILE_WRITE); if (myFile) { for (int i = 0; i &lt; SLOT_SIZE - 1; i++) { myFile.println(value[slotToSave][i]); } myFile.println(value[slotToSave][SLOT_SIZE - 1]); myFile.close(); Serial.println(&quot;.&quot;); } else { // if the file didn&#39;t open, print an error: Serial.println(&quot;error opening TEST.TXT&quot;); } } void loop() { if (readyToSave) { save(slot ^ 1); readyToSave = false; } delay(100); } 割り込みの使用は、押しボタン程度ならば不要ですが、、変化の速いセンサーを考えて割り込みを使っています。 HTMLテンプレート側 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;/SD_WLAN/jquery-2.1.0.min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;/SD_WLAN/ccchart-min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body style=&quot;width: 99%; height: 99%; margin: 0 auto; background-color:#FFA;&quot;&gt; &lt;div id=&quot;drawing&quot;&gt; &lt;canvas id=&quot;graph&quot; width=&quot;240&quot; height=&quot;360&quot; style=&quot;width:99%; max-width: 400px; height:99%; max-height: 600px;&quot;&gt;&lt;/canvas&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; function drawBars(testData) { var canvas = $(&#39;#graph&#39;); var chartdata = { &#39;config&#39;: { &#39;title&#39;: &#39;FlashAir x Sensor&#39;, &#39;titleFont&#39;: &#39;100 16px &quot;Arial&quot;&#39;, &#39;type&#39;: &#39;line&#39;, &#39;lineWidth&#39;: 4, &#39;minY&#39;: 0, &#39;maxY&#39;: 1100, &#39;useVal&#39;: &#39;yes&#39;, &#39;onlyChartWidthTitle&#39;: &#39;yes&#39;, &#39;colorSet&#39;: [&#39;yellow&#39;], &#39;bgGradient&#39;: { &#39;direction&#39;:&#39;vertical&#39;, &#39;from&#39;:&#39;#333&#39;, &#39;to&#39;:&#39;#000&#39; }, &#39;width&#39;: canvas.width(), &#39;height&#39;: canvas.height() }, &#39;data&#39;: [ [&#39;time&#39;,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20], [&#39;brightness&#39;,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0], ] }; var values = testData.trim().split(&#39; n&#39;); var MAX_BARS = 20; var first = Math.max(values.length - MAX_BARS, 0); var last = values.length; for (var i = first; i &lt; last; i++) { var n = i - first; chartdata[&#39;data&#39;][1][1 + n] = values[i]; } ccchart.init(&#39;graph&#39;, chartdata) } function repeater() { $.ajax({ type: &#39;GET&#39;, url: &#39;/TEST.TXT?TIME=&#39; + Math.floor(Math.random() * 10000), datatype: &#39;text&#39;, success: function(data, dataType) { drawBars(data); setTimeout(&#39;repeater()&#39;, 800); }, error: function(request, status, error) { setTimeout(&#39;repeater()&#39;, 800); }, }); } window.onload = function() { var data = &quot;100 n200 n300 n400 n500 n600 n700 n800 n900 n1000 n100 n200 n300 n400 n500 n600 n700 n800 n900 n1000 n&quot;; drawBars(data); repeater(); } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 以下のライブラリを使用しています。 jquery 2.1 http://jquery.com/ ccchart https://ccchart.com/ センサーデータファイル (TEXT.TXT) 1行に1個の数値が並んでいるのみ Arduino起動時にクリア (ファイル削除) 容量が増えるとダウンロードが遅くなるため、データ量が多い・全部保存したい、などの場合はリングバッファ方式の導入など検討したほうがよいでしょう。",
    "url": "http://localhost:4000/docs/tutorials/advanced/4.html",
    "relUrl": "/docs/tutorials/advanced/4.html"
  },
  "27": {
    "id": "27",
    "title": "APモードでの起動",
    "content": "APモードでの起動 本チュートリアルでは、iSDIOコマンドを使って、FlashAirの無線LANをAPモードで起動してみます。 概要 APモードの起動には、iSDIOで規定されているEstablishコマンドを使用します。 Establishコマンドの発行が完了した後、 FlashAirが実際に無線LAN APとして動作開始するまでには、 数秒～20秒程度の時間がかかります。 動作開始を確認するためには、ステータスレジスタを利用します。 チュートリアル３で ステータスレジスタの読み出し方を解説しましたが、 全部のステータスは必要ありませんので、 本チュートリアルでは、コマンド発行後の処理ステータスを確認する方法だけを切り出してみます。 また、Establishコマンドが正しく動作するためには、 FlashAirの無線LANが未接続状態になっていなければなりません。 そこで、このチュートリアルでは、無線LANを切断するためのDisconnectコマンドも実行してみましょう。 以下、 チュートリアル３のソースコードを元に追加・変更していきます。 シーケンスIDについて 前述のとおり、コマンドは発行してから処理が完了するまで時間がかかります。 最後に発行されたコマンドを識別するために、シーケンスIDという仕組みが取り入れられています。 iSDIOのシーケンスIDは、0以上の4バイトの符号なし数値です。 コマンドを新しく発行するたびに、シーケンスIDを新しい値（通常は以前の値に１加えたもの）に更新します。 注意点：シーケンスIDは、ホストプログラムだけが変更するとは限りません。 FlashAirの起動時あるいはCGIでの指示により、FlashAir自身が無線LAN状態を変更した場合も、 iSDIOコマンドが発行されてシーケンスIDが変更される可能性があることに注意が必要です。 そのため、厳密にはコマンド発行の都度最新のシーケンスIDを取得して、 新しいシーケンスIDを作成するのが正しいでしょう。 ただし、本チュートリアルシリーズでは説明の簡略化のため、起動直後のシーケンスIDを読み取り、 それ以降は自分で管理したIDのみを使います。 自分が発行した最後のシーケンスIDを覚えておくため、変数を一つ用意します。 arduino_tutorial_04.ino (一部抜粋) uint32_t nextSequenceId = 0; Establishコマンドの発行 Establishは、無線LAN機能をAPモードで立ち上げるためのコマンドです。 同時に、HTTPサーバー機能とDHCPサーバー機能も立ち上がります。 詳細は、 SD Specifications Part E7 Wireless LAN Simplified Addendum Version 1.10 4.2.3 Estalibsh(ssid, networkKey, encMode) に規定されています。 コマンドデータを作るためには、下記の情報が必要です。 コマンドID (3) シーケンスID 引数個数 (3) 引数 SSID ネットワークキー (パスワード) セキュリティモード arduino_tutorial_04.ino (一部抜粋) boolean iSDIO_establish(uint32_t sequenceId) { Serial.print(F(&quot; nEstablish command: n&quot;)); memset(buffer, 0, 512); uint8_t* p = buffer; p = put_command_header(p, 1, 0); p = put_command_info_header(p, 0x03, sequenceId, 3); p = put_str_arg(p, &quot;sdiotest&quot;); p = put_str_arg(p, &quot;12345678&quot;); p = put_u8_arg(p, 0x06); put_command_header(buffer, 1, (p - buffer)); printHex(buffer, (p - buffer)); return card.writeExtDataPort(1, 1, 0x000, buffer) ? true : false; } 3行目～10行目 FlashAirに発行するコマンドのデータをArduinoのメモリ上に作っています。 5行目 ヘルパー関数を利用して、コマンドのヘッダを作っています。 最後の引数にはコマンドデータの長さ(バイト数)を入れますが、 可変長の引数があるため、引数を含んでいるため、後で計算します。 6行目 ヘルパー関数を利用して、コマンド情報のヘッダを作っています。 establishのコマンドID0x03、シーケンスIDsequenceID、引数の個数3を指定しています。 7行目 1番目の引数SSIDを書き込んでいます。 文字列引数を書き込むヘルパー関数を利用しています。 8行目 同様に、2番目の引数ネットワークキーを書き込んでいます。 9行目 3番目の引数セキュリティモードを書き込んでいます。 ここでは、WPA2-PSK and AESを表す0x06を指定しています。他の値については仕様書をご覧ください。 １バイトデータを書き込むヘルパー関数を利用しています。 10行目 全データが書き込まれ、バイト数が確定したので、コマンドヘッダを改めて書き込んでいます。 11行目 正しく作成されたかを確認する目的で、コマンドデータをダンプしています。printHex()関数についてはサンプルコードを参照ください。 12行目 FlashAirに対してデータを書き込んでいます。 コマンド処理状況の確認 コマンド処理状況を確認するには、iSDIOのコマンドレスポンスステータスを読み取ります。 コマンドレスポンスステータス (SD Specifications Part E7 iSDIO Simplifed Specification Version 1.10より抜粋) 特に重要なのは、 _iSDIO command sequence id_と、 _Response Status_の2つです。 iSDIO command sequence idが、いま確認したいシーケンスIDと一致しているか確認します。 一致していることが確認できたら、Response Statusで処理状況を確認します。 なお、iSDIO規格では最大8つまでのコマンドを同時に発行できることになっており、 コマンドレスポンスステータスレジスタも8個ありますが、 FlashAirは1つまでの対応となっていますので、アドレス 0x440のステータスを常に読み取ります。 以下に、指定したシーケンスIDのコマンドの終了を待機する関数を作成します。 arduino_tutorial_04.ino (一部抜粋) boolean iSDIO_waitResponse(uint32_t sequenceId) { Serial.print(F(&quot; nWaiting response &quot;)); uint8_t prev = 0xFF; for (int i = 0; i &lt; 20; ++i) { memset(buffer, 0, 0x14); // Read command response status. if (!card.readExtMemory(1, 1, 0x440, 0x14, buffer)) { return false; } uint8_t resp = get_u8(buffer + 8); if (sequenceId == get_u32(buffer + 4)) { if (prev != resp) { switch (resp) { case 0x00: Serial.print(F(&quot; n Initial&quot;)); break; case 0x01: Serial.print(F(&quot; n Command Processing&quot;)); break; case 0x02: Serial.println(F(&quot; n Command Rejected&quot;)); return false; case 0x03: Serial.println(F(&quot; n Process Succeeded&quot;)); return true; case 0x04: Serial.println(F(&quot; n Process Terminated&quot;)); return false; default: Serial.print(F(&quot; n Process Failed &quot;)); Serial.println(resp, HEX); return false; } prev = resp; } } Serial.print(F(&quot;.&quot;)); delay(1000); } return false; } 8行目 コマンドレスポンスステータスレジスタを読み取っています。 13行目 シーケンスIDが一致することを確認しています。 15行目～35行目 レスポンスステータスを確認してます。処理が完了すると、Process Succeededになります。 39行目 1秒ごとにこの確認を実行しています。 Disconnectコマンドの発行 Disconnectは、無線LANを切断するためのコマンドです。 同時に、HTTPサーバー機能とDHCPサーバー機能も停止します。 詳細は、 **SD Specifications Part E7 Wireless LAN Simplified Addendum Version 1.10 4.2.7 Disconnect(ssid, networkKey, encMode) ** に規定されています。 コマンドデータを作るためには、下記の情報が必要です。 コマンドID (7) シーケンスID 引数個数 (0) 引数はありません。 arduino_tutorial_04.ino (一部抜粋) boolean iSDIO_disconnect(uint32_t sequenceId) { Serial.print(F(&quot; nDisconnect command: n&quot;)); memset(buffer, 0, 512); uint8_t* p = buffer; p = put_command_header(p, 1, 0); p = put_command_info_header(p, 0x07, sequenceId, 0); put_command_header(buffer, 1, (p - buffer)); printHex(buffer, (p - buffer)); return card.writeExtDataPort(1, 1, 0x000, buffer) ? true : false; } メインプログラム メインプログラムは、対話式のプログラムとしてみましょう。 Arduinoのシリアルターミナルで入力されたコマンド番号に従って、ステータス表示、Disconnect、Establish の各コマンドを実行します。 arduino_tutorial_04.ino (一部抜粋) void loop() { if (!iSDIO_status()) { Serial.println(F(&quot; nFailed to read status.&quot;)); } Serial.print(F(&quot; n0. Show status&quot;)); Serial.print(F(&quot; n1. Disconnect&quot;)); Serial.print(F(&quot; n2. Establish&quot;)); Serial.print(F(&quot; n nCommand? (next sequence id = &quot;)); Serial.print(nextSequenceId, DEC); Serial.println(F(&quot;)&quot;)); while (Serial.available() == 0); char command = Serial.read(); switch (command - &#39;0&#39;) { case 0 : break; case 1 : if (iSDIO_disconnect(nextSequenceId) &amp;&amp; iSDIO_waitResponse(nextSequenceId)) { Serial.println(F(&quot; nSuccess.&quot;)); } else { Serial.print(F(&quot; nFailed or waiting. errorCode=&quot;)); Serial.println(card.errorCode(), HEX); } nextSequenceId++; break; case 2 : if (iSDIO_establish(nextSequenceId) &amp;&amp; iSDIO_waitResponse(nextSequenceId)) { Serial.println(F(&quot; nSuccess.&quot;)); } else { Serial.print(F(&quot; nFailed or waiting. errorCode=&quot;)); Serial.println(card.errorCode(), HEX); } nextSequenceId++; break; default : Serial.println(F(&quot; nUnknown command.&quot;)); break; } } 2行目 ステータス表示です。 6行目～11行目 実行できるコマンドおよび次のシーケンスIDを表示しています。 13行目～14行目 番号の入力を待っています。 16行目～42行目 入力された番号に従ってコマンドを実行します。 ステータス表示を loop()関数に含めましたので、 setup()関数からは削除しましょう。 arduino_tutorial_04.ino (一部抜粋) void setup() { // Initialize UART for message print. Serial.begin(9600); while (!Serial) { ; } // Initialize SD card. Serial.print(F(&quot; nInitializing SD card...&quot;)); if (card.init(SPI_HALF_SPEED, chipSelectPin)) { Serial.print(F(&quot;OK&quot;)); } else { Serial.print(F(&quot;NG&quot;)); abort(); } // Read the previous sequence ID. if (card.readExtMemory(1, 1, 0x420, 0x34, buffer)) { if (buffer[0x20] == 0x01) { nextSequenceId = get_u32(buffer + 0x24); iSDIO_waitResponse(nextSequenceId); nextSequenceId++; } else { nextSequenceId = 0; } } else { Serial.println(F(&quot; nFailed to read status.&quot;)); nextSequenceId = 0; } } 17行目～29行目 最後に使われたシーケンスIDを読み取っています。 さらに、直前のコマンドが実行中の場合は完了を待機しています。 実行結果 実行すると、例えば次のようになります。 Initializing SD card...OK Wait for response Process Succeeded Read iSDIO Status Register == iSDIO Status Registers == [0400h] Command Write Status: ... (snip) ... [0440h] Command Response Status #1: id = 3, sequence id = 1, status = Process Succeeded ... (snip) ... [0506h] WLAN: No Scan, No WPS, Group Client, AP, Infrastructure, No Connection, ... (snip) ... [0550h] IP Address: 192.168.0.1 ... (snip) ... 0. Show status 1. Disconnect 2. Establish Command? (next sequence id = 2) 起動後の状態と、コマンドオプションを表示します。 この例では、起動時にFlashAirがAPモードで起動したことを表しています。 コマンドは、Arduino IDEのシリアルターミナル上部にあるボックスに入力します。 1、Enterと入力してみましょう。 Disconnect command: 00: 01010000180000000000000000000700 01: 0700000000000000 Wait for response Command Processing. Process Succeeded Success. Read iSDIO Status Register ... (snip) ... [0440h] Command Response Status #1: id = 7, sequence id = 2, status = Process Succeeded ... (snip) ... [0506h] WLAN: No Scan, No WPS, Group Client, STA, Initial, No Connection, ... (snip) ... [0550h] IP Address: 0.0.0.0 ... (snip) ... Command? (next sequence id = 3) 14行目が、DisconnectのコマンドID 7、指定したシーケンスID、ステータス Process Succeededになっていることから、 Disconnectコマンドが発行され、完了したことがわかります。 また、WLANステータスが STAでIP Addressの 0.0.0.0であることから、無線LANが切断されていると判断できます。 3行目～4行目は、コマンドデータです。うまく動かないときは内容を確認してみてください。 引き続き、APモードの起動を行ってみましょう。 シリアルターミナルのボックスに、 2、Enterと入力します。 Establish command: 00: 01010000380000000000000000000300 01: 0800000003000000080000007364696F 02: 74657374080000003132333435363738 03: 0100000006000000 Wait for response Command Processing..... Process Succeeded Success. Read iSDIO Status Register ... (snip) ... [0440h] Command Response Status #1: id = 3, sequence id = 3, status = Process Succeeded ... (snip) ... [0506h] WLAN: No Scan, No WPS, Group Client, AP, Infrastructure, No Connection, [0508h] SSID: sdiotest [0528h] Encryption Mode: WPA2-PSK and AES [0529h] Signal Strength: 0 [052Ah] Channel: 11 [0530h] MAC Address: E8E0B758A7FB [0540h] ID: [0550h] IP Address: 192.168.0.1 [0554h] Subnet Mask: 255.255.255.0 [0558h] Default Gateway: 192.168.0.1 [055Ch] Preferred DNS Server: 192.168.0.1 [0560h] Alternate DNS Server: 0.0.0.0 ... (snip) ... EstablishのコマンドID 3が実行されています。（16行目) WLANステータスが APおよびIP Addressが 192.168.0.1となっていることから、 FlashAirがAPモードで立ち上がっていることが確認できます。 サンプルコード arduino_tutorial_04.zip (24KB) 本チュートリアルのサンプルコードはGPLv3および二条項BSDライセンスで提供されています。 詳細はダウンロードした各ファイルを参照してください。",
    "url": "http://localhost:4000/docs/tutorials/arduino/4.html",
    "relUrl": "/docs/tutorials/arduino/4.html"
  },
  "28": {
    "id": "28",
    "title": "サムネイルの表示",
    "content": "サムネイルの表示 第4回では、FlashAirのコンテンツのサムネイルを表示するアプリを作成します。 thumbnail.cgiを使用します。 事前準備 1. プロジェクトを作成する まずは作成するアプリのプロジェクトを作成します。 前回までと同じく、プロジェクトを作成したいディレクトリへ移動し、以下のコマンドを実行します。 &gt; cordova create cordovatutorial4 com.fixstars.flashair.tutorial CordovaTutorial4 また、プロジェクト作成後、browserプラットフォーム及び以下のプラグインの追加を行ってください。 第2回で使用したプラグイン Statusbarプラグイン（config.xmlへのコード追加作業含む） 第3回で使用したプラグイン Fileプラグイン FileTransferプラグイン Inappbrowserプラグイン 2. 第3回で使用したファイルを追加する 第3回で使用したファイルを以下のようにコピーして追加します。 cordovatutorial4 ├─ hooks ├─ platforms ├─ plugins ├─ www │ ├─ css │ │ └─ load.css（上書きコピー） │ ├─ img │ │ └─ logo.png │ ├─ js │ │ ├─ jquery-3.1.1.min.js（上書きコピー） │ │ ├─ load.js（上書きコピー） │ │ ├─ tutorial2.js（上書きコピー） │ │ └─ tutorial3.js（上書きコピー） │ ├─ index.html（上書きコピー） │ ├─ tutorial2.html（上書きコピー） │ └─ tutorial3.html（上書きコピー） └─ config.xml アプリのトップ画面作成 1. index.htmlを編集する アプリのトップ画面であるindex.htmlを編集します。第3回の36～40行目を、以下のように変更してください。 /www/index.html &lt;p class=&quot;pos-center&quot;&gt;&lt;button type=&quot;button&quot; onclick=&quot;location.href=&#39;tutorial2.html&#39;&quot;&gt;２．コンテンツリストの取得&lt;/button&gt;&lt;/p&gt; &lt;p class=&quot;pos-center&quot;&gt;&lt;button type=&quot;button&quot; onclick=&quot;location.href=&#39;tutorial3.html&#39;&quot;&gt;３．コンテンツのダウンロード&lt;/button&gt;&lt;/p&gt; &lt;p class=&quot;pos-center&quot;&gt;&lt;button type=&quot;button&quot; onclick=&quot;location.href=&#39;tutorial4.html&#39;&quot;&gt;４．サムネイルの表示&lt;/button&gt;&lt;/p&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;cordova.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;js/load.js&quot;&gt;&lt;/script&gt; &lt;/body&gt; 38行目 タップされたらtutorial4.htmlの画面へ遷移するボタンを追加しています。サムネイルの表示はtutorial4.htmlの画面で行います。 2. 実行結果 上記の編集が完了したら、ビルドを行い、出来上がったアプリのインストールを行ってください。第3回と比べて、「４．サムネイルの表示」ボタンを追加しています。 Androidデバイスの場合 iOSデバイスの場合 サムネイルの表示画面の作成 1. tutorial4.htmlを作成する 続いて、サムネイルの表示画面を作成します。tutorial3.htmlとの共通部分が多いので、コピーしたファイルをtutorial4.htmlとして保存して、9～24行目を以下のように変更してください。 /www/tutorial4.html &lt;title&gt;Tutorial4&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;css/load.css&quot;&gt; &lt;/head&gt; &lt;body onload=&quot;onLoad()&quot;&gt; &lt;div id=&quot;header&quot; class=&quot;pos-center&quot;&gt; &lt;div id=&quot;head-left&quot;&gt;&amp;lt;&lt;br&gt;Back&lt;/div&gt; &lt;h1 id=&quot;head-center&quot;&gt;Thumbnail&lt;/h1&gt; &lt;div id=&quot;head-right&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div id=&quot;list&quot;&gt;&lt;/div&gt; &lt;hr&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;cordova.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;js/jquery-3.1.1.min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;js/tutorial4.js&quot;&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 9行目 画面のタイトルをTutorial4に変更しています。 15行目 ヘッダーのタイトルをThumbnailに変更しています。 22行目 ロードするJavaScriptの内、tutorial3.jsをtutorial4.jsへ変更しています。 2. tutorial4.jsを作成する コンテンツのダウンロード画面でロードするtutorial4.jsを作成していきます。tutorial3.jsとの共通部分が多いので、コピーしたファイルをtutorial4.jsとして保存して、93～120行目を以下のように変更してください。 /www/js/tutorial4.js // Show the content list. function showFileList(){ $(&quot;#list&quot;).html(&quot;&quot;); $.each(wlansd, function(){ var file = this; var filelink = $(&quot;&lt;a href=&#39;javascript:void(0)&#39;&gt;&lt;/a&gt;&quot;); var caption = file[&quot;fname&quot;]; var faDir = file[&quot;r_uri&quot;]; var fileobj = $(&quot;&lt;div&gt;&lt;/div&gt;&quot;); var img = $(&quot;&lt;img&gt;&quot;); // Skip hidden file. if(file[&quot;attr&quot;] &amp; 0x02){ return; } // Make a link to directories and files. if(file[&quot;attr&quot;] &amp; 0x10){ img.attr(&quot;src&quot;, &quot;img/folder.png&quot;); filelink.addClass(&quot;dir&quot;); } else { var array = file[&quot;fname&quot;].split(&quot;.&quot;); var ext = array.length &gt;=2 ? array[array.length-1] : &quot;&quot;; // Check a file extension. if( ext.toUpperCase() == &quot;JPG&quot;){ img.attr(&quot;src&quot;, &quot;http://flashair/thumbnail.cgi?&quot; + faDir + &quot;/&quot; + caption); } else { img.attr(&quot;src&quot;, &quot;img/flashair.png&quot;); } filelink.addClass(&quot;file&quot;); } $(&quot;#list&quot;).append( fileobj.append( filelink.append( img ).append( caption ) ) ); }); } 102行目 サムネイル画像を表示させるimgタグの変数を宣言しています。 109行目 コンテンツがディレクトリの場合、サムネイル画像の代わりにimg/folder.pngを指定して表示させます。 112-119行目 コンテンツがファイルで拡張子がJPGの場合は、サムネイル画像をthumbnail.cgiで取得して表示させます。 また、拡張子がJPG以外の場合は、サムネイル画像の代わりにimg/flashair.pngを指定して表示させます。 124-128行目 サムネイル画像をコンテンツ名（caption）の前に表示させます。 3. tutorial4.jsで指定している画像を追加する tutorial4.jsで指定した以下の画像を/www/img以下に保存します。 folder.png flashair.png 4. 実行結果 上記のの編集が完了したら、ビルドを行い、アプリのインストールを行います。アプリインストール後、FlashAirへ無線LAN接続していれば、トップ画面の「４．サムネイルの表示」ボタンをタップすることで、サムネイル画像付きのコンテンツリストが表示されます。（以下の左側の画面は/ディレクトリ、右側の画面は/DCIM/100_TSBディレクトリを表示させたときの画面です。） Androidデバイスの場合 iOSデバイスの場合 サンプルコード リポジトリを見る（GitHub） このサンプルコードはApache License, Version 2.0で提供されています。 「cordova_tutorial_04」ディレクトリは、zipファイルで圧縮してPhoneGap Buildへアップロードすることでビルドできます。 ビルド方法はHelloWorldアプリをビルドするをご確認ください。 Cordovaプロジェクトで確認する場合は、「cordova_tutorial_04」ディレクトリ内のデータをプロジェクト内へ上書きコピーしてください。",
    "url": "http://localhost:4000/docs/tutorials/cordova/4.html",
    "relUrl": "/docs/tutorials/cordova/4.html"
  },
  "29": {
    "id": "29",
    "title": "FTPを使ったファイルのアップロード",
    "content": "FTPを使ったファイルのアップロード このチュートリアルでは、FTPサーバーにファイルをアップロードします。 起動するとフォルダ内の全ファイルをアップロードする、というシンプルなスクリプトを作ってみましょう。 また、実行中のログをファイルに記録してみます。 注: FlashAirがPCに挿入されている場合は、ログファイルが書き込めないことがあります。 はじめに FlashAirにUploadフォルダを作成し、アップロードするファイルを設置します。 アップロード機能を有効にするために、CONFIGファイルにUPLOAD=1を追加します。 FlashAirでLuaを実行するを参考に、Luaスクリプト実行方法をCONFIGファイルに指定します。 アップロードするFTPサーバーがない場合は、ローカルFTPサーバーを構築しておきます。 アップロード まず、よく使う変数の準備からはじめましょう。接続先のFTPサーバー情報を調べておきましょう。 /FTPUpload.lua local logfile = &quot;/FTPLog.txt&quot; -- Log file created in FlashAir local folder = &quot;/Upload&quot; -- Folder to upload file is located local server = &quot;192.168.1.1&quot; -- IP address of FTP server local serverDir = &quot;/LuaTutorial&quot; -- FTP server upload folder local user = &quot;ftp&quot; -- FTP user name local passwd = &quot;abc123&quot; -- FTP password 次に、これらの変数を組み合わせて、アップロードに使うURLを作成します。 -- Assemble our FTP command string -- example: &quot;ftp://user:pass@192.168.1.1/LuaTutorial&quot; local ftpstring = &quot;ftp://&quot;..user..&quot;:&quot;..passwd..&quot;@&quot;..server..serverDir そして、ログファイルを作成します。 -- Open the log file local outfile = io.open(logfile, &quot;w&quot;) -- Write a header outfile:write(&quot;File list: n&quot;) LuaFileSystem (lfs) を使ってフォルダ内をスキャンし、 fa.ftp()でアップロードを行います。 結果はログファイルに記録されています。 Webブラウザから実行しているならば、一部の出力は画面でも見られます。 -- For each file in folder... for file in lfs.dir(folder) do -- Get that file&#39;s attributes attr = lfs.attributes(folder .. &quot;/&quot; .. file) print( &quot;Found &quot;..attr.mode..&quot;: &quot; .. file ) -- Don&#39;t worry about directories (yet) if attr.mode == &quot;file&quot; then --Attempt to upload the file! --ex ftp(&quot;put&quot;, &quot;ftp://user:pass@192.168.1.1/LuaTutorial/test.jpg&quot;, &quot;Upload/test.jpg&quot;) response = fa.ftp(&quot;put&quot;, ftpstring .. &quot;/&quot; .. file, folder .. &quot;/&quot; .. file) --Check to see if it worked, and log the result! if response ~= nil then print(&quot;Success!&quot;) outfile:write(&quot;&quot; .. file .. &quot;... Success! n&quot;) else print(&quot;Fail :(&quot;) outfile:write(&quot;&quot; .. file .. &quot;... Fail :( n&quot;) end end end 使い終わったら閉じるのを忘れずに！ --Close our log file outfile:close() これだけです！簡単でしょ！？ Luaスクリプト実行後、ルートフォルダにFTPLog.txtが追加され、実行結果が出力されます。 サンプルコード リポジトリを見る（GitHub） このサイトのサンプルコードは二条項BSDライセンスで提供されています。",
    "url": "http://localhost:4000/docs/tutorials/lua/4.html",
    "relUrl": "/docs/tutorials/lua/4.html"
  },
  "30": {
    "id": "30",
    "title": "サムネイルの表示",
    "content": "サムネイルの表示 このチュートリアルではサムネイルの表示方法について学びます。 command.cgi を使用して取得したコンテンツリストに、 thumbnail.cgi を使用して取得したムネイルを設定し表示するアプリケーションを作成します。 このチュートリアルは別項のiOS Tutorial 3:コンテンツのダウンロード に基づいています。 それではさっそく作ってみましょう。 画面レイアウトの作成 このようにサムネイルが表示されるコンテンツリストを作ります。 今回作成するアプリケーションの画面レイアウトについては別項のiOS Tutorial 3:コンテンツのダウンロード と同じです。 詳細はそちらを確認してください。 コードの作成 サムネイルの表示 サムネイルの取得は、thumbnail.cgiに取得対象のファイルパスを与えることで実現します。 取得には、NSData dataWithContentsOfURLを使用しています。 この関数は、データオブジェクトを返します。 設定先は、既に使用している Table View Cell が imageView の property を持っているので、こちらを利用します。 別項iOS Tutorial 3:コンテンツのダウンロード で作成した、 - (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath{} に、サムネイルを取得し設定する以下の処理を追加します。 FSViewController.m NSString *dir = [[[files objectAtIndex:indexPath.row + 1] componentsSeparatedByString:@&quot;,&quot;] objectAtIndex:0]; // Make url NSString *filePath = [[dir stringByAppendingString:@&quot;/&quot;] stringByAppendingString:filename]; NSURL *url = [NSURL URLWithString:[@&quot;http://flashair/thumbnail.cgi?&quot; stringByAppendingString:filePath]]; // Run CGI NSData *img_data = [NSData dataWithContentsOfURL:url]; // Display results cell.imageView.image = [[UIImage alloc] initWithData:img_data]; 1行目 dir にフォルダ、filename にファイル名が格納されているので、連結しファイルパスを作成しています。 4-5行目 今回使用するURLhttp://flashair/thumbnail.cgi? に作成したファイルパスを付加しています。 8行目 URLを実行しイメージデータを取得しています。 10行目 取得したイメージデータを、cell.imageView に設定しています。 実行結果 プログラムが出来上がったら、結果を確認をしてみましょう。 サムネイル画像を持ったイメージファイルが保存されているフォルダを選択します。 コンテンツリストを選択し、表示されるイメージファイルと一致しているかも確認をしてみましょう。 問題なく該当のサムネイルが表示されています。 以上で、サムネイルの表示 に関する解説はおわりです。 サンプルコード ios_tutorial_04.zip (25KB) このサイトのサンプルコードは二条項BSDライセンスで提供されています。",
    "url": "http://localhost:4000/docs/tutorials/ios/4.html",
    "relUrl": "/docs/tutorials/ios/4.html"
  },
  "31": {
    "id": "31",
    "title": "サムネイルの表示",
    "content": "サムネイルの表示 このチュートリアルではサムネイルの表示方法について学びます。 thumbnail.cgi と command.cgi を使用します。 このチュートリアルは別項の Android Tutorial 3:コンテンツのダウンロード に基づいています。 サムネイルとファイル名をセットで表示し、インタラクティブなコンテンツリストにします。 アプリケーションの開始時は、ルートフォルダが表示されます。 リストは次のようになります: コンテンツリストのイメージファイルをクリック（タップ）すると、 画像はこのように表示されます: コンテンツリストのフォルダをクリック（タップ）すると、 その中身が表示されます: 子のコンテンツリストのイメージファイルをクリック（タップ）すると、 画像はこのように表示されます: 表示されているとおり、Android 端末に画像ファイルがダウンロードされます。 このチュートリアルでは、データの取得・表示のために、これまでに学んだコマンドを利用します。 アプリケーションを作成するために、次のファイルを作成します : MainActivity.java activity_main.xml ImageViewActivity.java activity_image_view.xml 重要: Android application は、デフォルトの状態ではインターネットにアクセスすることができません。 そのため、設定ファイル AndroidManifest.xml を変更し、権限を与える必要があります。 パス: [Project_Folder]/AndroidManifest.xml AndroidManifest.xml に以下のコードを追加してください: &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt; リストのレイアウト作成 ではまず、 activity_main.xml を記述して、レイアウトを決定します。 このファイルは、layout フォルダに配置されています。 パス: [Project_Folder]/res/layout/activity_main.xml activity_main.xml は Android Tutorial 3: コンテンツのダウンロードと同じになります。 実装の説明についてはそちらを参照してください。 イメージビューのレイアウト作成 次に、 activity_image_view.xml を記述して、レイアウトを決定します。 このファイルは、layout フォルダに配置されています。 パス: [Project_Folder]/res/layout/activity_image_view.xml activity_image_view.xml は Android Tutorial 3: コンテンツのダウンロードと同じになります。 実装の説明についてはそちらを参照してください。 コンテンツリストの作成 さて、 MainActivity.java を修正します。 まずは FlashAir の任意のフォルダにあるファイル名の一覧を取得します(詳細は Android Tutorial 3: コンテンツのダウンロード を確認してください)。 次に、リスト内の各ファイルのサムネイルを取得し、 ListView にファイル名とサムネイルの情報を設定します。 リストはクリック可能にします。 初期化 コンテンツリストをクリックしたら、どの要素がクリックされたのかを判別し、画像を表示する必要があります。 onItemClick() のクラス宣言の変更から開始します。 アプリケーションの開始時に、コンテンツリストを表示したいので、 Activity クラスの onCreate(Bundle savedInstanceState) を修正します。 このコードは前回のチュートリアルの内容とよく似ていますが、いくつか異なっている点があります。 前回のチュートリアルのコードを再利用している場合は、変数の型や関数の呼び出しがこのチュートリアルのコードと一致していることを必ず確認してください。 SimpleAdapterを使用する理由については後述します。 MainActivity.java (1) public class MainActivity extends Activity implements AdapterView.OnItemClickListener { ListView listView; ImageView imageView; TextView currentDirText; TextView numFilesText; Button backButton; String rootDir = &quot;DCIM&quot;; String directoryName = rootDir; // Initialize to rootDirectory SimpleAdapter listAdapter; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); try { // Set buttons getWindow().setTitleColor(Color.rgb(65, 183, 216)); backButton = (Button)findViewById(R.id.button1); backButton.getBackground().setColorFilter(Color.rgb(65, 183, 216), PorterDuff.Mode.SRC_IN); backButton.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { if(directoryName.equals(rootDir)) { listRootDirectory(); } else { int index = directoryName.lastIndexOf(&quot;/&quot;); directoryName = directoryName.substring(0, index); listDirectory(directoryName); } } }); backButton.setEnabled(false); // Disable in root directory listRootDirectory(); } catch(Exception e) { Log.e(&quot;ERROR&quot;, &quot;ERROR: &quot; + e.toString()); e.printStackTrace(); } } @Override public boolean onCreateOptionsMenu(Menu menu) { // Inflate the menu; this adds items to the action bar if it is present. getMenuInflater().inflate(R.menu.main, menu); return true; } ViewBinderの作成 ListView を使用してサムネイルとファイル名のペアを表示します。 しかし、画像はプロジェクトフォルダの Drawable では静的管理していません。実行時に処理する必要があります。 ファイル名と関連付けられたサムネイルを操作するために、 Adapter を使用します。 使用するのは上記で宣言している SimpleAdapter です。 サムネイルとファイル名を表示するのに、 SimpleAdapter が正確なサムネイルとファイル名を map をできるよう、カスタムの ViewBinder を作成する必要があります。 MainActivity.java (2) class CustomViewBinder implements ViewBinder { @Override public boolean setViewValue(View view, Object obj, String text) { if((view instanceof ImageView) &amp;&amp; (obj instanceof Drawable)) { ImageView imageView = (ImageView) view; BitmapDrawable thumbnail = (BitmapDrawable) obj; imageView.setImageDrawable((Drawable)thumbnail); return true; } return false; } } コンテンツリストの作成 ファイル数を取得するためには、以下のコマンドを使用します。 ファイル数は、command.cgi にop=101 とフォルダパスを指定することで取得できます。 コマンド: http://flashair/command.cgi?op=101&amp;DIR=/DCIM コマンドが返す情報:&lt;NumberofItems&gt; ファイルデータを取得するためには、以下のコマンドを使用します。 ファイルデータは、command.cgi にop=100 とフォルダパスを指定することで取得できます。 コマンド:http://flashair/command.cgi?op=100&amp;DIR=/DCIM コマンドが返す情報: &lt;Directory&gt;,&lt;Filename&gt;,&lt;Size&gt;,&lt;Attribute&gt;,&lt;Date&gt;,&lt;Time&gt; サムネイルを取得するためには、以下のコマンドを使用します: thumbnail.cgi はバラメータにファイルパスを指定して使用します。 コマンド: http://flashair/thumbnail.cgi?directoryPath/fileName コマンドが返す情報:&lt;EXIF_thumbnail_image&gt; キー &quot;thmb&quot; と、ファイル名の &quot;fname&quot; を Map オブジェクトに設定します。 この Map オブジェクトは 前述した SimpleAdapter で使用される ArrayListに追加されます。 ファイルは Bitmap オブジェクトで読み込みます。 コマンドの実行には前項 Android Tutorial 3: コンテンツのダウンロードまでに作成した、 FlashAirRequest.java を使用します。 listRootDirectory() と listDirectory(directoryName) は onCreate(Bundle savedInstanceState) で呼ばれ、コンテンツを取得し表示するものです。 詳細は Android Tutorial 3: コンテンツのダウンロード で説明しています。 MainActivity.java (3) public void listRootDirectory() { directoryName = rootDir; listDirectory(directoryName); } public void listDirectory(String dir) { // Prepare command directory path if(dir.equals(rootDir)) { backButton.setEnabled(false); } else { backButton.setEnabled(true); } currentDirText = (TextView)findViewById(R.id.textView1); currentDirText.setText(dir + &quot;/&quot;); dir = &quot;/&quot; + dir; ArrayList &lt;NameValuePair&gt; httpParams = new ArrayList &lt;NameValuePair&gt; (); httpParams.add(new BasicNameValuePair(&quot;DIR&quot;, dir)); dir = URLEncodedUtils.format (httpParams, &quot;UTF-8&quot; ); numFilesText = (TextView)findViewById(R.id.textView2); // Fetch number of items in directory and display in a TextView new AsyncTask&lt;String, Void, String&gt;(){ @Override protected String doInBackground(String... params) { String dir = params[0]; String fileCount = FlashAirRequest.getString(&quot;http://flashair/command.cgi?op=101&amp;&quot; + dir); return fileCount; } @Override protected void onPostExecute(String fileCount) { numFilesText.setText(&quot;Items Found: &quot; + fileCount); } }.execute(dir); // Fetch list of items in directory and display in a ListView new AsyncTask&lt;String, Void, ListAdapter&gt;(){ @Override protected ListAdapter doInBackground(String... params) { String dir = params[0]; ArrayList &lt;String&gt; fileNames = new ArrayList &lt;String&gt;(); String files = FlashAirRequest.getString(&quot;http://flashair/command.cgi?op=100&amp;&quot; + dir); String[] allFiles = files.split(&quot;([, n])&quot;); // split by newline or comma for(int i = 2; i &lt; allFiles.length; i= i + 6) { if(allFiles[i].contains(&quot;.&quot;)) { // File fileNames.add(allFiles[i]); } else { // Directory, append &quot;/&quot; fileNames.add(allFiles[i] + &quot;/&quot;); } } // Get thumbnails ArrayList&lt;Map&lt;String, Object&gt;&gt; data = new ArrayList&lt;Map&lt;String, Object&gt;&gt;(); for(int i = 0; i &lt; fileNames.size(); i++) { String fileName = &quot;&quot;; fileName = &quot;http://flashair/thumbnail.cgi?&quot; + directoryName + &quot;/&quot; + fileNames.get(i); Map&lt;String, Object&gt; entry = new HashMap&lt;String, Object&gt;(); BitmapDrawable drawnIcon = null; if( (fileName.toLowerCase(Locale.getDefault()).endsWith(&quot;.jpg&quot;)) || (fileName.toLowerCase(Locale.getDefault()).endsWith(&quot;.jpeg&quot;)) ) { Bitmap thumbnail = FlashAirRequest.getBitmap(fileName); drawnIcon = new BitmapDrawable(getResources(), thumbnail); } if(drawnIcon == null) { entry.put(&quot;thmb&quot;, R.drawable.ic_launcher); } else { entry.put(&quot;thmb&quot;, drawnIcon); } entry.put(&quot;fname&quot;, fileNames.get(i)); // Put file name onto the map data.add(entry); } // Set the file list to a widget listAdapter = new SimpleAdapter(MainActivity.this, data, android.R.layout.activity_list_item, new String[]{&quot;thmb&quot;, &quot;fname&quot;}, new int[]{android.R.id.icon, android.R.id.text1}); listAdapter.setViewBinder(new CustomViewBinder()); return listAdapter; } @Override protected void onPostExecute(ListAdapter listAdapter) { listView = (ListView)findViewById(R.id.listView1); ColorDrawable divcolor = new ColorDrawable(Color.rgb(17, 19, 58)); listView.setDivider(divcolor); listView.setDividerHeight(1); listView.setAdapter(listAdapter); listView.setOnItemClickListener(MainActivity.this); } }.execute(dir); } thumbnail.cgiは、EXIFデータを持ったJPEGファイルの場合にのみ、サムネイルを返すことに注意してください。 60行目 JPEG ファイルであるか判別しています。 ファイルが JPEG であった場合は、EXIFデータを持っているかを判別しています(64行目)。EXIFデータを持っているかどうかは、BitmapDrawable を使用して試験的に保存し、サムネイルがnullであるかどうかで決定しています。 64-66行目 サムネイルを持っていない場合に、Androidのアイコンを設定しています。 86-91行目 新規のListViewを作成しています。 サムネイルとファイル名がそれぞれ view にバインドされています。 作成したViewをレイアウトに設定しています。 75-80行目 新規のAdapter とCustomViewBinderを生成しています。 これらは、90行目で ListView にバインドされています。 クリックリスナーの設定 Android Tutorial 3: コンテンツのダウンロード と同様の設定を行います: フォルダをクリックした場合は、選択したフォルダのコンテンツを表示した画面を表示します。 ファイルをクリックした場合は、ファイルをダウンロードし、ダウンロードした画像を表示しした画面を表示します。 リストの動作は同じですが、書式が異なっています。 ( ListView の Adapter が Map オブジェクトとして構成されています。) この変更に対応するために onItemClick() をオーバーライドします: MainActivity.java (4) @Override public void onItemClick(AdapterView&lt;?&gt; l, View v, int position, long id) { Object item = l.getItemAtPosition(position); // Get item at clicked position in list of files if(item instanceof Map&lt;?, ?&gt;) { Map&lt;String, Object&gt; mapItem = (Map&lt;String, Object&gt;) item; Object downloadFile = mapItem.get(&quot;fname&quot;); if(downloadFile.toString().endsWith(&quot;/&quot;)) { // Directory, remove &quot;/&quot; and show content list String dirName = downloadFile.toString().substring(0, downloadFile.toString().length()-1); // All but the &quot;/&quot; directoryName = directoryName + &quot;/&quot; + dirName; listDirectory(directoryName); } else if( (downloadFile.toString().toLowerCase(Locale.getDefault()).endsWith(&quot;.jpg&quot;)) || (downloadFile.toString().toLowerCase(Locale.getDefault()).endsWith(&quot;.jpeg&quot;)) || (downloadFile.toString().toLowerCase(Locale.getDefault()).endsWith(&quot;.jpe&quot;)) || (downloadFile.toString().toLowerCase(Locale.getDefault()).endsWith(&quot;.png&quot;)) ) { // Image file, download using ImageViewActivity Intent viewImageIntent = new Intent(this, ImageViewActivity.class); viewImageIntent.putExtra(&quot;downloadFile&quot;, downloadFile.toString()); viewImageIntent.putExtra(&quot;directoryName&quot;, directoryName); MainActivity.this.startActivity(viewImageIntent); } } } } // End MainActivity class 4-6行目 Map オブジェクトを使用して、ListView で選択されたファイル名を取得しています。 画像表示画面の作成 class ImageViewActivity は Android Tutorial 3: コンテンツのダウンロードと同じです。 実装の詳細についてはこちらのチュートリアルを参照してください。 サンプルコード android_tutorial_04.zip (533KB) このサイトのサンプルコードは二条項BSDライセンスで提供されています。",
    "url": "http://localhost:4000/docs/tutorials/android/4.html",
    "relUrl": "/docs/tutorials/android/4.html"
  },
  "32": {
    "id": "32",
    "title": "サムネイルの表示",
    "content": "サムネイルの表示 コンテンツリストの取得1で作成したファイル一覧にサムネイルを表示させてみましょう。 サムネイルの取得には thumbnail.cgi を使用します。 画面レイアウトの作成 HTMLファイルは コンテンツリストの取得1から変更ありません。 そのまま使いましょう。 サムネイルの取得と表示 コンテンツリストの取得1のmain.jsを変更していきます。 showFileList(path)関数のファイルリンク生成部分にサムネイルの読み込みを追加します。 リストの項目がJPGファイルだった場合には &lt;img&gt;タグを作成し、サムネイルのURLを設定しています。 このURLが、 thumbnail.cgiへのコマンド発行となります。 フォルダやJPG以外のファイルだった場合には、 /SD_WLAN/img/folder.pngと /SD_WLAN/img/other.pngを表示するようにしました。 適当な画像ファイルを用意しておいてください。 コードは次のようになります。追加した部分を // --&gt;と // &lt;--で囲んであります。 // Make a link to directories and files. var filelink = $(&#39;&lt;a&gt;&lt;/a&gt;&#39;).attr(&#39;href&#39;, file[&quot;r_uri&quot;] + &#39;/&#39; + file[&quot;fname&quot;]); var caption = file[&quot;fname&quot;]; var fileobj = $(&quot;&lt;div&gt;&lt;/div&gt;&quot;); // --&gt; var img = $(&#39;&lt;img&gt;&#39;); if ( file[&quot;attr&quot;] &amp; 0x10 ) { img.attr(&quot;src&quot;, &quot;/SD_WLAN/img/folder.png&quot;); filelink.addClass(&quot;dir&quot;); } else { var array = file[&quot;fname&quot;].split(&quot;.&quot;); var ext = array.length &gt;= 2 ? array[array.length - 1] : &#39;&#39;; if ( ext.toUpperCase() == &#39;JPG&#39; ) { img.attr(&quot;src&quot;, &quot;/thumbnail.cgi?&quot; + file[&quot;r_uri&quot;] + &#39;/&#39; + file[&quot;fname&quot;]); } else { img.attr(&quot;src&quot;, &quot;/SD_WLAN/img/other.png&quot;); } filelink.addClass(&quot;file&quot;).attr(&quot;target&quot;,&quot;_blank&quot;); } // Append a file entry or directory to the end of the list. $(&quot;#list&quot;).append( fileobj.append( filelink.append( // --&gt; img ).append( // &lt;-- caption ) ) ); 6行目 サムネイルを表示するための&lt;img&gt;タグを作成しています。 表示する画像を指定するsrc属性の値はこのあとで設定しています。 11-12行目 ファイル名から拡張子を取得しています。 拡張子がない場合、&quot;.&quot;(ドット)が複数ある場合を考慮しています。 13行目 拡張子がJPGであるかどうかを判定しています。 ファイル名が大文字でも小文字でも問題ないよう、一旦大文字に変換してから比較しています。 14行目 &lt;img&gt;タグのsrc属性にthumbnail.cgiを呼び出すURLを設定しています。 コード全体は次のようになります。 /SD_WLAN/js/main.js // JavaScript Document // Judge the card is V1 or V2. function isV1(wlansd) { if ( wlansd.length == undefined || wlansd.length == 0 ) { // List is empty so the card version is not detectable. Assumes as V2. return false; } else if ( wlansd[0].length != undefined ) { // Each row in the list is array. V1. return true; } else { // Otherwise V2. return false; } } // Convert data format from V1 to V2. function convertFileList(wlansd) { for (var i = 0; i &lt; wlansd.length; i++) { var elements = wlansd[i].split(&quot;,&quot;); wlansd[i] = new Array(); wlansd[i][&quot;r_uri&quot;] = elements[0]; wlansd[i][&quot;fname&quot;] = elements[1]; wlansd[i][&quot;fsize&quot;] = Number(elements[2]); wlansd[i][&quot;attr&quot;] = Number(elements[3]); wlansd[i][&quot;fdate&quot;] = Number(elements[4]); wlansd[i][&quot;ftime&quot;] = Number(elements[5]); } } // Callback Function for sort() function cmptime(a, b) { if ( a[&quot;fdate&quot;] == b[&quot;fdate&quot;] ) { return a[&quot;ftime&quot;] - b[&quot;ftime&quot;]; } else { return a[&quot;fdate&quot;] - b[&quot;fdate&quot;]; } } // Show file list function showFileList(path) { // Clear box. $(&quot;#list&quot;).html(&#39;&#39;); // Output a link to the parent directory if it is not the root directory. if ( path != &quot;/&quot; ) { // Make parent path var parentpath = path; if ( parentpath[parentpath.length - 1] != &#39;/&#39; ) { parentpath += &#39;/&#39;; } parentpath += &#39;..&#39;; // Make a link to the parent path. $(&quot;#list&quot;).append( $(&quot;&lt;div&gt;&lt;/div&gt;&quot;).append( $(&#39;&lt;a href=&quot;&#39; + parentpath + &#39;&quot; class=&quot;dir&quot;&gt;..&lt;/a&gt;&#39;) ) ); } $.each(wlansd, function() { var file = this; // Skip hidden file. if ( file[&quot;attr&quot;] &amp; 0x02 ) { return; } // Make a link to directories and files. var filelink = $(&#39;&lt;a&gt;&lt;/a&gt;&#39;).attr(&#39;href&#39;, file[&quot;r_uri&quot;] + &#39;/&#39; + file[&quot;fname&quot;]); var caption = file[&quot;fname&quot;]; var fileobj = $(&quot;&lt;div&gt;&lt;/div&gt;&quot;); var img = $(&#39;&lt;img&gt;&#39;); if ( file[&quot;attr&quot;] &amp; 0x10 ) { img.attr(&quot;src&quot;, &quot;/SD_WLAN/img/folder.png&quot;); filelink.addClass(&quot;dir&quot;); } else { var array = file[&quot;fname&quot;].split(&quot;.&quot;); var ext = array.length &gt;= 2 ? array[array.length - 1] : &#39;&#39;; if ( ext.toUpperCase() == &#39;JPG&#39; ) { img.attr(&quot;src&quot;, &quot;/thumbnail.cgi?&quot; + file[&quot;r_uri&quot;] + &#39;/&#39; + file[&quot;fname&quot;]); } else { img.attr(&quot;src&quot;, &quot;/SD_WLAN/img/other.png&quot;); } filelink.addClass(&quot;file&quot;).attr(&quot;target&quot;,&quot;_blank&quot;); } // Append a file entry or directory to the end of the list. $(&quot;#list&quot;).append( fileobj.append( filelink.append( img ).append( caption ) ) ); }); } // Document Ready $(function() { if ( isV1(wlansd) ) { convertFileList(wlansd); } wlansd.sort(cmptime); showFileList(location.pathname); }); 実行結果 コードをFlashAirに置いたら、FlashAirに無線LAN接続したPCまたはスマートフォンのブラウザで確認してみましょう。 例えば、以下のような画面が表示されるでしょう。 サムネイルがファイル名の隣に表示されています。 文字の大きさや並べ方はCSSなどで工夫してみてください。 サンプルコード web_tutorial_04.zip (4KB) このサイトのサンプルコードは二条項BSDライセンスで提供されています。",
    "url": "http://localhost:4000/docs/tutorials/web/4.html",
    "relUrl": "/docs/tutorials/web/4.html"
  },
  "33": {
    "id": "33",
    "title": "コンテンツの自動更新",
    "content": "コンテンツの自動更新 このチュートリアルではコンテンツの自動更新方法について学びます。 command.cgi のファイルアップデート情報の取得を使用して、FlashAirの更新情報を取得し、同時にコンテンツの更新も行うアプリケーションを作成します。 メモ:このチュートリアルの学習効果を高めるため、FlashAirをお手持ちのデジタルカメラに挿入することをお勧めします。 新しい写真を撮影したり、撮影済みの写真を削除すると、このアプリケーションにFlashAirの変更内容が反映されます。 このチュートリアルは別項のiOS Tutorial 4:サムネイルの表示 に基づいています。 それではさっそく作ってみましょう。 画面レイアウトの作成 今回作成するアプリケーションの画面レイアウトについては別項のiOS Tutorial 4:サムネイルの表示 を確認してください。 コードの作成 ファイルアップデート情報の取得 コンテンツの自動更新を行うには、まずcommand.cgi のop=102 を使用します。 このCGIを使用すると、FlashAirのコンテンツが更新されているかどうかを知ることができます。 別スレッドを立てて、このCGIを数秒おきに実行し、確認を行います。 CGIの実行には、NSString stringWithContentsOfURLを使用しています。 この関数は、指定されたエンコーディングの文字列（ここではUTF-8）と、発生した例外を返します。 FSViewController.m - (void)viewDidLoad { [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. [self getFileList:@&quot;/DCIM&quot;]; // Start updateCheck [NSThread detachNewThreadSelector:@selector(updateCheck) toTarget:self withObject:nil]; } - (void)updateCheck { bool status = true; NSError *error = nil; NSString *path,*sts; NSURL *url102 = [NSURL URLWithString:@&quot;http://flashair/command.cgi?op=102&quot;]; while (status) { // Run cgi sts =[NSString stringWithContentsOfURL:url102 encoding:NSUTF8StringEncoding error:&amp;error]; if ([error.domain isEqualToString:NSCocoaErrorDomain]){ NSLog(@&quot;error102 %@ n&quot;,error); status = false; }else{ // If flashair is updated then reload if([sts intValue] == 1){ path = [self.labelDirectory.text substringToIndex:[self.labelDirectory.text length] - 1]; [self performSelectorOnMainThread:@selector(reloadView:) withObject:path waitUntilDone:YES]; } } [NSThread sleepForTimeInterval:0.1f]; } } - (void) reloadView:(NSString *)path { [self getFileList:path]; [self.tableViewFileList reloadData]; } 8-9行目 ここで別スレッドを立ち上げ、立ち上げたスレッドでupdateCheck()を実行しています。 17行目 使用するURLです。 op=102 を設定します。 21-23行目 CGIが実行されます。 返される文字のエンコードは、ここでは UTF-8 を使用します。 encoding:NSUTF8StringEncoding を指定しています。 32-33行目 Table View の更新はメインスレッドから行う必要があるので、メインスレッドに更新処理を依頼しています。 41-42行目 メインスレッドに依頼する更新処理です。 実行結果 プログラムが出来上がったら、結果を確認をしてみましょう。 現在のコンテンツ数が、 11 と表示されていることも確認しておきます。 FlashAirを挿入している別の機器から、ファイルを追加してみます。 カメラに挿入している場合は、写真を1枚撮影してみましょう。 該当のコンテンツが増え、現在のコンテンツ数も、 12 と表示されました。 コンテンツリストを選択し、追加されたイメージファイルの確認もしてみましょう。 表示されました。 以上で、コンテンツの自動更新 に関する解説はおわりです。 サンプルコード ios_tutorial_05.zip (25KB) このサイトのサンプルコードは二条項BSDライセンスで提供されています。",
    "url": "http://localhost:4000/docs/tutorials/ios/5.html",
    "relUrl": "/docs/tutorials/ios/5.html"
  },
  "34": {
    "id": "34",
    "title": "Facebookへのアップロード",
    "content": "Facebookへのアップロード このチュートリアルでは、Facebookにファイルをアップロードしてみます。　本サイトでは、Facebookへアップロードする サンプルプログラムを公開していますので、ここでは、サンプルプログラムがどのように動作するかをみていきます。 Facebook.html facebook.htmlは、FacebookのOAuthサービスへリダイレクトするためにjavascriptを使用します。これは、認証トークンを取得するために使用します。 fb_get_token.lua fb_get_token.luaは、長期アクセストークン(60日間有効)を取得するために使用します。 まず、現在のアクセストークン(有効期限が1時間)が有効であることを確認するために、 fa.requestとcjsonを使用します。 local function hasValidToken(t) local b, c, h = fa.request { url = &#39;https://graph.facebook.com/debug_token?input_token=&#39; ..t.user_access_token..&#39;&amp;access_token=&#39; ..t.app_access_token, headers = {Connection = &#39;close&#39;} } if (c == 200) then local cjson = require(&quot;cjson&quot;) local res = cjson.decode(b) cjson = nil if (res.error ~= nil) then t.message = res.error.message else t.long_term = res.data.issued_at if (res.data.error ~= nil) then t.message = res.data.error.message else t.message = res.data.message end end return res.data.is_valid else t.message = b return false end end レスポンスコード(c)を確認し、200の場合、JSONレスポンスへデコードします。いずれかのステップで失敗した場合、有効なトークンが取得できず、showAuthorizationURL()が呼ばれ、新しいキーを取得するよう指示する文字が表示されます。 hasValidTokenが「true」を返した場合、長期アクセストークンを取得しにいきます。ここで、FacebookのOAuth APIを呼び出すために、 fa.requestを再び使用します。一時的なアクセストークンを渡すと、60日間有効なアクセストークンに更新され、表示されるはずです。 local function getLongtermToken(t) local b, c, h = fa.request { url = &#39;https://graph.facebook.com/oauth/access_token?grant_type=fb_exchange_token&#39; ..&#39;&amp;client_id=&#39;..t.app_id ..&#39;&amp;client_secret=&#39;..t.app_secret ..&#39;&amp;fb_exchange_token=&#39;..t.user_access_token, headers = {Connection = &#39;close&#39;} } if (c == 200) then local s, e = b:find(&quot;&amp;&quot;) local longtermToken = b:sub(1, s - 1) local file = io.open( t.token_fullpath, &quot;w&quot; ) file:write( longtermToken ) io.close( file ) file = nil s, e = longtermToken:find(&quot;=&quot;) -- Store the returned token t.user_access_token = longtermToken:sub(e+1, #longtermToken) end end fb_token_handler.lua このスクリプトは、fb_get_token.lua用の設定ファイル(facebook.cfg)を管理します。結果を含むテーブル(mod)を返します。 fb_auto_up.lua 最後に、このスクリプトは、Facebookにアップロードするためのスクリプトです。まず、無線LANが接続されるのを待ちます(waitWlanConnect())。そして、接続が確立されると、アップロードディレクトリ内の各フォルダをを探索し、1回に1ファイルをアップロードします。 各ファイルを選択するために、LuaFileSystemを利用します(autoUpload())。 --... --For each directory... for aDirectory in lfs.dir(&quot;/DCIM&quot;) do local _dir_id = tonumber(aDirectory:sub(1, 3)) -- print(&quot;DIR:&quot;..aDirectory, lfs.attributes(&quot;/DCIM/&quot;..aDirectory, &quot;modification&quot;)) if (_dir_id ~= nil and _dir_id &gt;= lastDirectory) then --for each file in that directory... for aFile in lfs.dir(&quot;/DCIM/&quot;..aDirectory) do --Process and upload! --... 次に、フォルダをアップロードする前に、アルバムを作成するためにFacebookのGraph APIを使います。これは、基本的な fa.requestでリクエストを発行します。正しい場所にアップロードするために、レスポンス文字列をデコードし、アルバムIDを取得します。 local function createAlbum(_name, _message) local req = {} req[&quot;url&quot;] = &#39;https://graph.facebook.com/v2.1/me/albums?access_token=&#39;..user_access_token ..&#39;&amp;name=&#39;..string.gsub (_name, &quot; &quot;, &quot;+&quot;) ..&#39;&amp;message=&#39;..string.gsub (_message, &quot; &quot;, &quot;+&quot;) ..&#39;&amp;privacy=%7B%22value%22%3A+%22SELF%22%7D&#39; req[&quot;method&quot;] = &#39;POST&#39; req[&quot;headers&quot;] = {Connection = &quot;close&quot;} local b,c,h = fa.request(req) if (c ~= 200) then print(h, b) return nil end req = nil c, h = nil local cjson = require(&quot;cjson&quot;) local res = cjson.decode(b) collectgarbage() return res[&quot;id&quot;] end 最後に、POSTリクエストを発行するために、 fa.requestを使用して各ファイルのアップロードを行います。(uploadFile(filePath,_album_id)) local function uploadFile(filePath, _album_id) local boundary = &#39;--bnfDxpKY69NKk&#39; local headers = {} local place_holder = &#39;&lt;!--WLANSDFILE--&gt;&#39; headers[&#39;Connection&#39;] = &#39;close&#39; headers[&#39;Content-Type&#39;] = &#39;multipart/form-data; boundary=&quot;&#39;..boundary..&#39;&quot;&#39; local body = &#39;--&#39;..boundary..&#39; r n&#39; ..&#39;Content-Disposition: form-data; name=&quot;source&quot;; filename=&quot;&#39; ..filePath..&#39;&quot; r n&#39; ..&#39;Content-Type: image/jpeg r n r n&#39; ..&#39;&lt;!--WLANSDFILE--&gt; r n&#39; .. &#39;--&#39; .. boundary .. &#39;-- r n&#39; headers[&#39;Content-Length&#39;] = lfs.attributes(filePath, &#39;size&#39;) + string.len(body) - string.len(place_holder) local args = {} args[&quot;url&quot;] = &#39;https://graph.facebook.com/v2.1/&#39; .._album_id..&#39;/photos?access_token=&#39; ..user_access_token ..&#39;&amp;message=&#39;..filePath args[&quot;method&quot;] = &quot;POST&quot; args[&quot;headers&quot;] = headers args[&quot;body&quot;] = body args[&quot;file&quot;] = filePath args[&quot;bufsize&quot;] = 1460*10 local b,c,h = fa.request(args) b, h = nil collectgarbage() if (c ~= 200) then print(h, b) return nil end return c end アップロードには数分かかる場合があります。 サンプルコード リポジトリを見る（GitHub） このサイトのサンプルコードは二条項BSDライセンスで提供されています。",
    "url": "http://localhost:4000/docs/tutorials/lua/5.html",
    "relUrl": "/docs/tutorials/lua/5.html"
  },
  "35": {
    "id": "35",
    "title": "コンテンツの自動更新",
    "content": "コンテンツの自動更新 このチュートリアルではコンテンツの自動更新方法について学びます。 thumbnail.cgi と command.cgi を使用します。 作成した Android Tutorial 4: サムネイルの表示 に自動更新機能を追加します。 FlashAirの内容が更新されると、コンテンツリストも更新します。 メモ: このチュートリアルの学習効果を高めるため、FlashAirをお手持ちのデジタルカメラに挿入することをお勧めします。 新しい写真を撮影したり、撮影済みの写真を削除すると、このアプリケーションにFlashAirの変更内容が反映されます。 コンテンツのファイル名とサムネイルのペアを含むリストは次のようになります: FlashAirを挿入したデジタルカメラで写真を撮ると、コンテンツリストが(指定した時間後)にリフレッシュされ、撮った写真が反映されます: 新しく追加されたイメージファイルの名前をクリック（タップ）すれば、撮影したばかりの写真を表示することもできます: 表示されているとおり、Android 端末に画像ファイルがダウンロードされます。 アプリケーションを作成するために、次のファイルを作成します: MainActivity.java activity_main.xml ImageViewActivity.java activity_image_view.xml 重要: Android application は、デフォルトの状態ではインターネットにアクセスすることができません。 そのため、設定ファイル AndroidManifest.xml を変更し、権限を与える必要があります。 パス: [Project_Folder]/AndroidManifest.xml AndroidManifest.xml に以下のコードを追加してください: &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt; リストのレイアウト作成 ではまず、 activity_main.xml を記述して、レイアウトを決定します。 このファイルは、layout フォルダに配置されています。 パス: [Project_Folder]/res/layout/activity_main.xml activity_main.xml は Android Tutorial 3: コンテンツのダウンロードと同じになります。 実装の説明についてはそちらを参照してください。 イメージビューのレイアウト作成 次に、 activity_image_view.xml を記述して、レイアウトを決定します。 このファイルは、layout フォルダに配置されています。 パス: [Project_Folder]/res/layout/activity_image_view.xml activity_image_view.xml は Android Tutorial 3: コンテンツのダウンロードと同じになります。 実装の説明についてはそちらを参照してください。 コンテンツリストの作成 さて、 MainActivity.java を修正します。 まずは FlashAir の任意のフォルダにあるファイル名の一覧を取得します(詳細は Android Tutorial 3: コンテンツのダウンロード を確認してください)。 次に、リスト中のファイル名とそのファイルのサムネイル画像をペアとして ListView に表示し、動作を設定します(詳細は Android Tutorial 4: サムネイルの表示 を確認してください)。 初期化 Android Tutorial 4: サムネイルの表示 の MainActivity.java をコピーし、それを新しい MainActivity.java としてご使用ください。 class MainActivity 宣言, メンバ変数、と onCreate(Bundle savedInstanceState) 関数を下記のように置き換えます: MainActivity.java (1) public class MainActivity extends Activity implements AdapterView.OnItemClickListener { ListView listView; ImageView imageView; TextView currentDirText; TextView numFilesText; Button backButton; String rootDir = &quot;DCIM&quot;; String directoryName = rootDir; // Initialize to rootDirectory SimpleAdapter listAdapter; int checkInterval = 5000; Handler updateHandler; boolean viewingList; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); viewingList = true; // Start out viewing the list try { // Set buttons getWindow().setTitleColor(Color.rgb(65, 183, 216)); backButton = (Button)findViewById(R.id.button1); backButton.getBackground().setColorFilter(Color.rgb(65, 183, 216), PorterDuff.Mode.SRC_IN); backButton.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { if(directoryName.equals(rootDir)) { listRootDirectory(); } else { int index = directoryName.lastIndexOf(&quot;/&quot;); directoryName = directoryName.substring(0, index); listDirectory(directoryName); } } }); backButton.setEnabled(false); // Disable in root directory listRootDirectory(); } catch(Exception e) { Log.e(&quot;ERROR&quot;, &quot;ERROR: &quot; + e.toString()); e.printStackTrace(); } updateHandler = new Handler(); startUpdate(); } 前回までに作成した MainActivity クラスにメンバ変数を追加しました。 11行目 FlashAirの状態をチェックする時間間隔を設定しています。 12行目 後述の関数で実装するRunnable を管理するHandler updateHandlerを宣言しています。 13行目 現在コンテンツリストや画像を表示ししているかを追跡するboolean viewingList を宣言しています 。 ルートのフォルダを”DCIM”としていますが(8行目)、他のフォルダをルートにしても構いません。 販売されている多くのデジタルカメラが撮影した画像を “DCIM” フォルダへ格納しているので、ここでは “DCIM” を設定しました。 残りの MainActivity.java はそのまま使用します(コンテンツリストの設定を含める必要があります)。 ビューの状態による制御 MainActivity.java に、更新の状態をチェックする処理を追加します。 この処理は、 以前作成した class MainActivity に含めます。 ユーザーがコンテンツリストを表示していない場合には、FlashAirの状態を監視する必要はありません。 コンテンツリストを表示する際に、最新の情報を取得するためです。 ユーザーがコンテンツリストを表示中の場合にだけ、FlashAirの状態を監視し、変更内容を反映するようにしましょう。 コンテンツリストのビューが表示されているかを判断するために、上記で宣言したフラグ viewingList (13行目)を更新するリスナー関数をオーバーライドします。 MainActivity.java (2) @Override public void onWindowFocusChanged(boolean hasFocus) { super.onWindowFocusChanged(hasFocus); if(hasFocus) { viewingList = true; } else { viewingList = false; } } public boolean checkIfListView() { // Check if user is viewing a content list if(viewingList) { return true; } return false; } hasFocus 変数は、コンテンツリストを表示している場合に True です。 ユーザーが View を切り替えると通知されます。 これは、以下の Runnable の実装を容易にしています。 更新ハンドラの設定と コンテンツの更新 FlashAirの更新状態を取得するためには、以下のコマンドを使用します。 command.cgi にop=102 を指定します。 コマンド: http://flashair/command.cgi?op=102 コマンドが返す情報: 1 アップデートされている 0 アップデートされていない コマンドCGIは 1 を１度だけ返します。 その後別の変更が行われるまでは 0 を返します。 コマンドの実行には前項 Android Tutorial 3: コンテンツのダウンロードまでに作成した、 FlashAirRequest.java を使用します。 次の関数では、コンテンツリストを自動更新する動作と、その間隔を決定します。 MainActivity.java (3) public Runnable statusChecker = new Runnable() { @Override public void run() { if (checkIfListView() == true) { new AsyncTask&lt;String, Void, String&gt;(){ @Override protected String doInBackground(String... params) { return FlashAirRequest.getString(params[0]); } @Override protected void onPostExecute(String status) { if(status.equals(&quot;1&quot;)) { // Fetch current contents of FlashAir and display list listDirectory(directoryName); } } }.execute(&quot;http://flashair/command.cgi?op=102&quot;); } updateHandler.postDelayed(statusChecker, checkInterval); } }; public void startUpdate() { statusChecker.run(); } public void stopUpdate() { updateHandler.removeCallbacks(statusChecker); } 3-20行目Runnable class のメイン処理run() 関数を設定しています。 19行目updateHandlerに対し、statusCheckerのrun()関数が、checkIntervalミリ秒後に実行されるよう設定しています。 このコードが自身の関数内のrun() 関数で実行されていることに注意してください。 これは長い時間updateHandler が停止せず、checkInterval にミリ秒単位で設定した時間ごとに、再度実行されることを意味します。 画像表示画面の作成 class ImageViewActivity はAndroid Tutorial 3: コンテンツのダウンロードと同じです。 実装の詳細についてはこのチュートリアルを参照してください。 サンプルコード android_tutorial_05.zip (533KB) このサイトのサンプルコードは二条項BSDライセンスで提供されています。",
    "url": "http://localhost:4000/docs/tutorials/android/5.html",
    "relUrl": "/docs/tutorials/android/5.html"
  },
  "36": {
    "id": "36",
    "title": "FlashAirへのアップロード",
    "content": "FlashAirへのアップロード 第5回では、FlashAirへファイルをアップロードするアプリを作成します。upload.cgiを使用します。 事前準備 1. プロジェクトを作成する まずは作成するアプリのプロジェクトを作成します。 前回までと同じく、プロジェクトを作成したいディレクトリへ移動し、以下のコマンドを実行します。 &gt; cordova create cordovatutorial5 com.fixstars.flashair.tutorial CordovaTutorial5 また、プロジェクト作成後、browserプラットフォーム及び以下のプラグインの追加を行ってください。 第2回で使用したプラグイン Statusbarプラグイン（config.xmlへのコード追加作業含む） 第3回で使用したプラグイン Fileプラグイン FileTransferプラグイン Inappbrowserプラグイン 2. 第4回で使用したファイルを追加する 第4回で使用したファイルを以下のようにコピーして追加します。 cordovatutorial5 ├─ hooks ├─ platforms ├─ plugins ├─ www │ ├─ css │ │ └─ load.css（上書きコピー） │ ├─ img │ │ └─ logo.png │ ├─ js │ │ ├─ jquery-3.1.1.min.js（上書きコピー） │ │ ├─ load.js（上書きコピー） │ │ ├─ tutorial2.js（上書きコピー） │ │ ├─ tutorial3.js（上書きコピー） │ │ └─ tutorial4.js（上書きコピー） │ ├─ index.html（上書きコピー） │ ├─ tutorial2.html（上書きコピー） │ ├─ tutorial3.html（上書きコピー） │ └─ tutorial4.html（上書きコピー） └─ config.xml アプリのトップ画面作成 1. index.htmlを編集する アプリのトップ画面であるindex.htmlを編集します。第4回の36～41行目を、以下のように変更してください。 /www/index.html &lt;p class=&quot;pos-center&quot;&gt;&lt;button type=&quot;button&quot; onclick=&quot;location.href=&#39;tutorial2.html&#39;&quot;&gt;２．コンテンツリストの取得&lt;/button&gt;&lt;/p&gt; &lt;p class=&quot;pos-center&quot;&gt;&lt;button type=&quot;button&quot; onclick=&quot;location.href=&#39;tutorial3.html&#39;&quot;&gt;３．コンテンツのダウンロード&lt;/button&gt;&lt;/p&gt; &lt;p class=&quot;pos-center&quot;&gt;&lt;button type=&quot;button&quot; onclick=&quot;location.href=&#39;tutorial4.html&#39;&quot;&gt;４．サムネイルの表示&lt;/button&gt;&lt;/p&gt; &lt;p class=&quot;pos-center&quot;&gt;&lt;button type=&quot;button&quot; onclick=&quot;location.href=&#39;tutorial5.html&#39;&quot;&gt;５．FlashAirへのアップロード&lt;/button&gt;&lt;/p&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;cordova.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;js/load.js&quot;&gt;&lt;/script&gt; &lt;/body&gt; 39行目 タップされたらtutorial5.htmlの画面へ遷移するボタンを追加しています。FlashAirへのアップロードはtutorial5.htmlの画面で行います。 2. 実行結果 上記の編集が完了したら、ビルドを行い、出来上がったアプリのインストールを行ってください。第4回と比べて、「５．FlashAirへのアップロード」ボタンを追加しています。 Androidデバイスの場合 iOSデバイスの場合 FlashAirへのアップロード画面の作成 1. tutorial5.htmlを作成する 続いて、FlashAirへのアップロード画面を作成します。tutorial4.htmlとの共通部分が多いので、コピーしたファイルをtutorial5.htmlとして保存して、9～24行目を以下のように変更してください。 /www/tutorial5.html &lt;title&gt;Tutorial5&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;css/load.css&quot;&gt; &lt;/head&gt; &lt;body onload=&quot;onLoad()&quot;&gt; &lt;div id=&quot;header&quot; class=&quot;pos-center&quot;&gt; &lt;div id=&quot;head-left&quot;&gt;&amp;lt;&lt;br&gt;Back&lt;/div&gt; &lt;h1 id=&quot;head-center&quot;&gt;Upload&lt;/h1&gt; &lt;div id=&quot;head-right&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div id=&quot;list&quot;&gt;&lt;/div&gt; &lt;hr&gt; &lt;div id=&quot;upload&quot;&gt; &lt;h3&gt;Upload the file to the current directory&lt;/h3&gt; &lt;button id=&quot;doUpload&quot;&gt;Upload!&lt;/button&gt; &lt;/div&gt; &lt;hr&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;cordova.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;js/jquery-3.1.1.min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;js/tutorial5.js&quot;&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; &lt;/html&gt; 9行目 画面のタイトルをTutorial5に変更しています。 15行目 ヘッダーのタイトルをUploadに変更しています。 20-23行目 FlashAirへアプリ内に格納しているファイルをアップロードするボタン枠を追加しています。 アップロードするファイルについては後述します。 27行目 ロードするJavaScriptの内、tutorial4.jsをtutorial5.jsへ変更しています。 2. tutorial5.jsで使用するプラグインを追加する 次はtutorial5.jsの作成に移りますが、その前にアップロード処理時の確認用ダイアログを使えるようにするため、Dialogsプラグインを追加していきます。 追加コマンドは以下の通りです。 &gt; cordova plugin add cordova-plugin-dialogs -save 3. tutorial5.jsを作成する FlashAirへアップロード画面でロードするtutorial5.jsを作成していきます。tutorial4.jsとの共通部分が多いので、コピーしたファイルを tutorial5.jsとして保存して、まず9～21行目を以下のように変更してください。 /www/js/tutorial5.js function onDeviceReady(){ getFileList(&quot;&quot;); $(document).on(&quot;click&quot;, &quot;a.dir&quot;, function(){ getFileList(this.text); }); $(document).on(&quot;click&quot;, &quot;a.file&quot;, function(){ downloadFile(this.text, currentPath); }); $(&quot;#doUpload&quot;).click(function(){ navigator.notification.confirm(&quot;Are you sure you upload &#39;upload.jpg&#39;?&quot;, confirmCallback, &quot;UPLOAD&quot;, &quot;YES,NO&quot;); function confirmCallback(buttonIndex) { switch (buttonIndex) { // Dialog closed without tapped any buttons. case 0: break; // &quot;YES&quot; tapped case 1: uploadFile(); break; // &quot;NO&quot; tapped case 2: break; } } }); document.addEventListener(&quot;backbutton&quot;, onBackKeyDown, false); $(&quot;#head-left&quot;).click(function(){ onBackKeyDown(); }); } 17-18行目 「Upload!」ボタンをタップしたときに、まず確認用のダイアログを表示させます。 確認ダイアログの表示にはDialogsプラグインのnavigator.notification.confirmを使用します。 第1引数がメッセージ、第2引数がコールバック関数、第3引数がタイトル、第4引数がボタン名の配列になります。 19-32行目 コールバック関数の中身です。 今回の場合は「YES」ボタンをタップしたときのみ、uploadFile関数が呼び出されるように設定しています。 続いて以下のアップロード処理について、最後の行（179行目）から追加してください。 尚、コードは上級者向けチュートリアル - FlashAirへのアップロード を元にしていますが、inputタグを使ったファイルアップロードがAndroid 4.4（Kitkat）で使用できない為、マルチパートの構造を自作してPOSTする方法をとっています。 /www/js/tutorial5.js // Upload the content. function uploadFile(){ var uppath = makePath(&quot;.&quot;); var cgi = &quot;http://flashair/upload.cgi&quot;; var dt = new Date(); // The range of years for FAT32 is from 1980 to 2107. var year = (dt.getFullYear() - 1980) &lt;&lt; 9; var month = (dt.getMonth() + 1) &lt;&lt; 5; var date = dt.getDate(); var hours = dt.getHours() &lt;&lt; 11; var minites = dt.getMinutes() &lt;&lt; 5; var seconds = Math.floor(dt.getSeconds() / 2); var timestring = &quot;0x&quot; + (year + month + date).toString(16) + (hours + minites + seconds).toString(16); var param = cgi + &quot;?WRITEPROTECT=ON&amp;UPDIR=&quot; + uppath + &quot;&amp;FTIME=&quot; + timestring; // GET request upload.cgi parameters. $.get(param, function(){ // Create boundary. var boundary = &quot;--FlashAir&quot; + year.toString() + month.toString() + date.toString() + hours.toString() + minites.toString() + seconds.toString); var localReq = new XMLHttpRequest(); var preReader = new FileReader(); var sufReader = new FileReader(); var localBuffer, faBuffer; // GET request upload file (as ArrayBuffer). localReq.open(&quot;GET&quot;, &quot;img/upload.jpg&quot;, true); localReq.responseType = &quot;arraybuffer&quot;; // POST request to FlashAir succeeds. var faReqSuccess = function(){ navigator.notification.alert(&quot;Upload complete!&quot;, function(){ // Update the content list. getFileList(&quot;.&quot;); }, &quot;UPLOAD&quot;, &quot;OK&quot;); }; // Suffix loading succeeds. var sufReaderSuccess = function(){ // Connect HTTP Body suffix. faBuffer = connectBuffer(faBuffer, sufReader.result); var faReq = new XMLHttpRequest(); // Make a POST request to upload a file to FlashAir. faReq.open(&quot;POST&quot;, cgi, true); // Set HTTP Headers. faReq.setRequestHeader(&quot;Content-Type&quot;, &quot;multipart/form-data; boundary=&quot; + boundary); faReq.onload = faReqSuccess; faReq.send(faBuffer); }; // Prefix loading succeeds. var preReaderSuccess = function(){ // Connect HTTP Body prefix and upload file. faBuffer = connectBuffer(preReader.result, localBuffer); // HTTP Body suffix var suffix = &quot; r n&quot; + &quot;--&quot; + boundary + &quot;--&quot;; sufReader.onload = sufReaderSuccess; // Load suffix (as ArrayBuffer). sufReader.readAsArrayBuffer(new Blob([suffix])); }; // GET request upload file succeeds. var localReqSuccess = function(){ localBuffer = localReq.response; // HTTP Body prefix var prefix = &quot;--&quot; + boundary + &quot; r n&quot; + &quot;Content-Disposition: form-data; name= &quot;userfile &quot;; filename= &quot;upload.jpg &quot; r n&quot; + &quot;Content-Type: image/peg r n r n&quot;; preReader.onload = preReaderSuccess; // Load prefix (as ArrayBuffer). preReader.readAsArrayBuffer(new Blob([prefix])); }; localReq.onload = localReqSuccess; localReq.send(null); }); return false; } // Add &quot;addBuffer&quot; to &quot;oriBuffer&quot; (as ArrayBuffer). function connectBuffer(oriBuffer, addBuffer){ var uint8Array = new Uint8Array(oriBuffer.byteLength + addBuffer.byteLength); uint8Array.set(new Uint8Array(oriBuffer), 0); uint8Array.set(new Uint8Array(addBuffer), oriBuffer.byteLength); return uint8Array.buffer; } 181-194行目 まずはupload.cgiのパラメータを確定させ、GETリクエストを行っています。 各パラメータについてはupload.cgiをご確認ください。 202-203,242-243行目 アプリ内に置いてあるファイル（img/upload.jpg）をGETリクエストしています。responseTypeにはarraybufferを指定して、バイナリデータとして取り扱います。 リクエスト成功時のコールバック関数はlocalReqSuccessです。 205-210行目 faReqSuccess（220行目）のコールバック関数の中身です。 Dialogsプラグインのnavigator.notification.alertを使用したアラートダイアログを表示します。第1引数がメッセージ、第2引数がアラートダイアログを閉じたときに呼ばれるコールバック関数、第3引数がタイトル、第4引数がボタン名になります。そしてコールバック関数の中で、getFileList(&quot;.&quot;)を呼び出すことでコンテンツリストが更新され、アップロードしたファイルが確認できるようになります。 212-222行目 sufReaderSuccess（229行目）のコールバック関数の中身です。upload.cgiを使用して、FlashAirへ「upload.jpg」をPOSTリクエストしています。 リクエスト成功時のコールバック関数はfaReqSuccessです。 224-232行目 preReaderSuccess（238行目）のコールバック関数の中身です。FileReader.readAsArrayBuffer()を利用して、HTTPボディ部のアップロードファイル本体の後につけるString（suffix）をArrayBufferとして読み出すようにしています。 読み出し成功時のコールバック関数はsufReaderSuccessです。 234-241行目 localReqSuccess（242行目）のコールバック関数の中身です。FileReader.readAsArrayBuffer()を利用して、HTTPボディ部のアップロードファイル本体の前につけるString（prefix）をArrayBufferとして読み出すようにしています。 読み出し成功時のコールバック関数はpreReaderSuccessです。 248-253行目 元のArrayBufferに追加したいArrayBufferを追加して返す関数です。 4. tutorial5.jsで指定している画像を追加する tutorial5.jsで指定したアップロード用の画像を/www/img以下に保存します。 upload.jpg 5. 実行結果 上記の編集が完了したら、ビルドを行い、アプリのインストールを行います。 アプリインストール後、FlashAirへ無線LAN接続していれば、トップ画面の「５．FlashAirへのアップロード」ボタンをタップしたときに、画面下部にファイルをアップロードするボタンの枠が表示されます。 そして、この中の「Upload!」ボタンをタップすると、表示しているカレントディレクトリに「upload.jpg」ファイルがアップロードされ、コンテンツリストの表示が更新されます。 Androidデバイスの場合 1.アップロードボタンをタップする前のコンテンツリスト 2.アップロードボタンタップ後の確認ダイアログ 3.アップロード完了後のアラートダイアログ 4.アラートダイアログを閉じた後に更新して表示されるコンテンツリスト iOSデバイスの場合 1.アップロードボタンをタップする前のコンテンツリスト 2.アップロードボタンタップ後の確認ダイアログ 3.アップロード完了後のアラートダイアログ 4.アラートダイアログを閉じた後に更新して表示されるコンテンツリスト サンプルコード リポジトリを見る（GitHub） このサンプルコードはApache License, Version 2.0で提供されています。 「cordova_tutorial_05」ディレクトリは、zipファイルで圧縮してPhoneGap Buildへアップロードすることでビルドできます。 ビルド方法はHelloWorldアプリをビルドするをご確認ください。 Cordovaプロジェクトで確認する場合は、「cordova_tutorial_05」ディレクトリ内のデータをプロジェクト内へ上書きコピーしてください。",
    "url": "http://localhost:4000/docs/tutorials/cordova/5.html",
    "relUrl": "/docs/tutorials/cordova/5.html"
  },
  "37": {
    "id": "37",
    "title": "STAモードでの起動",
    "content": "STAモードでの起動 本チュートリアルでは、iSDIOコマンドを使って、FlashAirの無線LANをSTAモードで起動してみます。 概要 STAモードの起動には、iSDIOで規定されているConnectコマンドを使用します。 Establishコマンド同様、Connectコマンドが正しく動作するためには、 FlashAirの無線LANが未接続状態になっていなければなりません。 STAモードで起動するためには、接続先のSSIDとネットワークキーが必要です。 近傍にある無線LAN APのSSIDを列挙する Scan コマンドも実行してみましょう。 以下、 チュートリアル４のソースコードを元に追加・変更していきます。 Connectコマンドの発行 Connectは、無線LAN機能をSTAモードで立ち上げるためのコマンドです。 同時に、HTTPサーバー機能とDHCPサーバー機能も立ち上がります。 詳細は、 SD Specifications Part E7 Wireless LAN Simplified Addendum Version 1.10 4.2.2 Connect(ssid, networkKey) に規定されています。 コマンドデータを作るためには、下記の情報が必要です。 コマンドID (2) シーケンスID 引数個数 (2) 引数 SSID ネットワークキー (パスワード) arduino_tutorial_5.ino (一部抜粋) boolean iSDIO_connect(uint32_t sequenceId, const char* ssid, const char* networkKey) { Serial.print(F(&quot; nConnect command: n&quot;)); memset(buffer, 0, 512); uint8_t* p = buffer; p = put_command_header(p, 1, 0); p = put_command_info_header(p, 0x02, sequenceId, 2); p = put_str_arg(p, ssid); p = put_str_arg(p, networkKey); put_command_header(buffer, 1, (p - buffer)); printHex(buffer, (p - buffer)); return card.writeExtDataPort(1, 1, 0x000, buffer) ? true : false; } Scanコマンドの発行 Scanは、接続可能な無線LAN APをスキャンするためのコマンドです。 無線LAN接続中は実行できません。 詳細は、 SD Specifications Part E7 Wireless LAN Simplified Addendum Version 1.10 4.2.1 Scan() に規定されています。 コマンドデータを作るためには、下記の情報が必要です。 コマンドID (1) シーケンスID 引数個数 (0) 引数はありません。 arduino_tutorial_5.ino (一部抜粋) boolean iSDIO_scan(uint32_t sequenceId) { Serial.print(F(&quot; nScan: n&quot;)); memset(buffer, 0, 512); uint8_t* p = buffer; p = put_command_header(p, 1, 0); p = put_command_info_header(p, 0x01, sequenceId, 0); put_command_header(buffer, 1, (p - buffer)); printHex(buffer, (p - buffer)); return card.writeExtDataPort(1, 1, 0x000, buffer) ? true : false; } スキャン結果は、コマンド完了後に結果レジスタ(0x200番地)をデータポートとして読み取ることで取得できます。 iSDIO Command Response Data (SD Specifications Part E7 Wireless LAN Simplified Addendum Version1.10より抜粋) このうち、データ本体は Response Dataの部分で、 次のようなフォーマットになっています。 Wireless LAN SSID List (SD Specifications Part E7 Wireless LAN Simplified Addendum Version 1.10より抜粋) ステータスを読み取って表示するルーチンを作ります。 arduino_tutorial_5.ino (一部抜粋) boolean iSDIO_showScanResult() { // Try to output some wifi info. if (!card.readExtDataPort(1, 1, 0x200, buffer)) { return false; } uint8_t num = get_u8(buffer + 24); Serial.print(F(&quot;Number of APs: &quot;)); Serial.println(num); uint8_t* p = buffer + 28; for (int i = 0; i &lt; num; i++){ Serial.print(F(&quot; &quot;)); Serial.print((const char*)p); Serial.print(F(&quot;, &quot;)); printBytes(p + 32, 6); Serial.print(F(&quot;, &quot;)); Serial.print(get_u8(p + 38), DEC); Serial.print(F(&quot;, &quot;)); switch (get_u8(p + 39)){ case 0 : Serial.print(F(&quot;NoSec&quot;)); break; case 1 : Serial.print(F(&quot;WEP&quot;)); break; case 2 : Serial.print(F(&quot;WPA&quot;)); break; case 3 : Serial.print(F(&quot;WPA2&quot;)); break; default : Serial.print(F(&quot;error&quot;)); break; } Serial.println(); p += 44; } return true; } メインプログラム メインプログラムに、ConnectコマンドとScanコマンドを追加します。 arduino_tutorial_05.ino (一部抜粋) void loop() { char ssid[16]; char networkKey[16]; if (!iSDIO_status()) { Serial.println(F(&quot; nFailed to read status.&quot;)); } Serial.print(F(&quot; n0. Show status&quot;)); Serial.print(F(&quot; n1. Disconnect&quot;)); Serial.print(F(&quot; n2. Establish&quot;)); Serial.print(F(&quot; n3. Connect&quot;)); Serial.print(F(&quot; n4. Scan&quot;)); Serial.print(F(&quot; n nCommand? (next sequence id = &quot;)); Serial.print(nextSequenceId, DEC); Serial.println(F(&quot;)&quot;)); while (Serial.available() == 0); char command = Serial.read(); switch (command - &#39;0&#39;) { .. (snip) .. case 3 : Serial.print(F(&quot;SSID? &quot;)); inputText(ssid, sizeof(ssid)); Serial.print(F(&quot;Network Key? &quot;)); inputText(networkKey, sizeof(networkKey)); if (iSDIO_connect(nextSequenceId, ssid, networkKey) &amp;&amp; iSDIO_waitResponse(nextSequenceId)) { Serial.println(F(&quot; nSuccess.&quot;)); } else { Serial.print(F(&quot; nFailed or waiting. errorCode=&quot;)); Serial.println(card.errorCode(), HEX); } nextSequenceId++; break; case 4 : if (iSDIO_scan(nextSequenceId) &amp;&amp; iSDIO_waitResponse(nextSequenceId) &amp;&amp; iSDIO_showScanResult()) { Serial.println(F(&quot; nSuccess.&quot;)); } else { Serial.print(F(&quot; nFailed or waiting. errorCode=&quot;)); Serial.println(card.errorCode(), HEX); } nextSequenceId++; break; default : Serial.println(F(&quot; nUnknown command.&quot;)); break; } } 24行目～27行目 Connectコマンドで使用するSSIDとNetworkKeyをユーザー入力する部分です。 上記で利用している、 inputText()関数を作ります。 ;が入力されたら、入力終わりと判断するようにしています。 arduino_tutorial_05.ino (一部抜粋) char* inputText(char* buf, uint8_t len) { // Read characters until user inputs enter or buffer gets full. uint8_t i = 0; while (i &lt; len - 1) { while (Serial.available() == 0); char c = Serial.read(); if (c == &#39;;&#39;) break; buf[i] = c; i++; } buf[i] = 0; Serial.println(buf); return buf; } 実行結果 実行してみましょう。 注意点： ScanもConnectも、Disconnect状態でないと実行できません。 もしFlashAirが別の機器につながっている場合は、まずDisconnectを実行してください。 ... (snip) ... 0. Show status 1. Disconnect 2. Establish 3. Connect 4. Scan Command? (next sequence id = 1) Scanを実行してみます。 シリアルターミナルのボックスに、 4、Enterと入力します。 Scan: 00: 01010000180000000000000000000100 01: 0700000000000000 Waiting response Command Processing... Process Succeeded Number of APs: 5 mynetwork, B86B23663750, 70, WPA2 flashair_led, B86B23583750, 64, NoSec flashair203r, B86B23005049, 61, WPA2 HWD14_VEGETA, C40528C98B0C, 52, WPA2 FlashairT5-v2, E8E0B744A7FB, 49, WPA2 Success. 近傍の無線LAN APの、SSID、BSSID (MACアドレス)、信号強度 (0～100)、セキュリティが表示されます。 続いて、Connectを実行しましょう。 シリアルターミナルのボックスに、 3、Enterと入力します。 すると、下記のようなプロンプトが表示されます。 SSID? 接続先のSSIDを入力しましょう。文字列の終わりを示すため、SSIDの最後に ;を付け加えてしてください。 たとえば、 mynetworkに接続する場合は、 mynetwork; とEnterを、シリアルターミナルのボックスに入力します。 入力すると、 Network Key? と表示されますので、同様にしてネットワークキーを打ち込みます。 接続に成功した場合は、次のようになるはずです。 Connect command: 00: 01010000340000000000000000000200 01: 0B00000002000000090000006D796E65 02: 74776F726B0000000800000031323334 03: 35363738 Waiting response Command Processing........... Process Succeeded Success. Read iSDIO Status Register ... (snip) ... [0440h] Command Response Status #1: id = 2, sequence id = 3, status = Process Succeeded ... (snip) ... [0506h] WLAN: No Scan, No WPS, Group Client, STA, Infrastructure, Connected, [0508h] SSID: mynetwork [0528h] Encryption Mode: WPA2-PSK and AES [0529h] Signal Strength: 98 [052Ah] Channel: 1 [0530h] MAC Address: E8E0B758A7FB [0540h] ID: [0550h] IP Address: 192.168.43.213 [0554h] Subnet Mask: 255.255.255.0 [0558h] Default Gateway: 192.168.43.1 [055Ch] Preferred DNS Server: 192.168.43.1 [0560h] Alternate DNS Server: 0.0.0.0 ... (snip) ... Command? (next sequence id = 11) サンプルコード arduino_tutorial_05.zip (24KB) 本チュートリアルのサンプルコードはGPLv3および二条項BSDライセンスで提供されています。 詳細はダウンロードした各ファイルを参照してください。",
    "url": "http://localhost:4000/docs/tutorials/arduino/5.html",
    "relUrl": "/docs/tutorials/arduino/5.html"
  },
  "38": {
    "id": "38",
    "title": "コンテンツの自動更新",
    "content": "コンテンツの自動更新 command.cgi の ファイルアップデート情報の取得 を使用して、 FlashAirの内容が更新されたことを取得し、更新があった場合はコンテンツの更新を行うようにしてみましょう。 今回は更新を検出したら、ページのリロードを行うことでコンテンツ更新を行います。 画面レイアウトの作成 HTMLファイルは コンテンツリストの取得1から変更ありません。 そのまま使いましょう。 更新ステータスの監視とリロード ウェブブラウザチュートリアル 4. サムネイルの表示の main.jsを変更していきます。 FlashAirのコンテンツに更新があったかどうかは、 command.cgiに op=102に与えることで取得できます。 更新ステータスを確認があったらページをリロードする処理をする関数を追加します。 //Callback Function for Polling function polling() { var url=&quot;/command.cgi?op=102&quot;; $.get(url,function(data) { if($.trim(data)==&quot;1&quot;) { location.reload(true); } }); } 3-4行目 更新ステータスを取得するCGIコマンドを実行しています。 5-6行目 ステータスが1だったら、ページのリロードを行います。 定期的な監視 上記の polling()関数を5秒ごとに呼び出すタイマーの設定を、 ページが読み込まれたときに実行される関数( document.ready(handler))に追加します。 // Document Ready $(function() { if ( isV1(wlansd) ) { convertFileList(wlansd); } wlansd.sort(cmptime); showFileList(location.pathname); setInterval(polling, 5000); }); 8行目 setInterval()関数に、 定期的に呼び出される関数の名前(polling)と、 呼び出し間隔をミリ秒単位で指定しています。 プログラム main.js全体は以下のようになります /SD_WLAN/js/main.js // JavaScript Document // Judge the card is V1 or V2. function isV1(wlansd) { if ( wlansd.length == undefined || wlansd.length == 0 ) { // List is empty so the card version is not detectable. Assumes as V2. return false; } else if ( wlansd[0].length != undefined ) { // Each row in the list is array. V1. return true; } else { // Otherwise V2. return false; } } // Convert data format from V1 to V2. function convertFileList(wlansd) { for (var i = 0; i &lt; wlansd.length; i++) { var elements = wlansd[i].split(&quot;,&quot;); wlansd[i] = new Array(); wlansd[i][&quot;r_uri&quot;] = elements[0]; wlansd[i][&quot;fname&quot;] = elements[1]; wlansd[i][&quot;fsize&quot;] = Number(elements[2]); wlansd[i][&quot;attr&quot;] = Number(elements[3]); wlansd[i][&quot;fdate&quot;] = Number(elements[4]); wlansd[i][&quot;ftime&quot;] = Number(elements[5]); } } // Callback Function for sort() function cmptime(a, b) { if( a[&quot;fdate&quot;] == b[&quot;fdate&quot;] ) { return a[&quot;ftime&quot;] - b[&quot;ftime&quot;]; }else{ return a[&quot;fdate&quot;] - b[&quot;fdate&quot;]; } } // Show file list function showFileList(path) { // Clear box. $(&quot;#list&quot;).html(&#39;&#39;); // Output a link to the parent directory if it is not the root directory. if ( path != &quot;/&quot; ) { // Make parent path var parentpath = path; if ( parentpath[parentpath.length - 1] != &#39;/&#39; ) { parentpath += &#39;/&#39;; } parentpath += &#39;..&#39;; // Make a link to the parent path. $(&quot;#list&quot;).append( $(&quot;&lt;div&gt;&lt;/div&gt;&quot;).append( $(&#39;&lt;a href=&quot;&#39; + parentpath + &#39;&quot; class=&quot;dir&quot;&gt;..&lt;/a&gt;&#39;) ) ); } $.each(wlansd, function() { var file = this; // Skip hidden file. if ( file[&quot;attr&quot;] &amp; 0x02 ) { return; } // Make a link to directories and files. var filelink = $(&#39;&lt;a&gt;&lt;/a&gt;&#39;).attr(&#39;href&#39;, file[&quot;r_uri&quot;] + &#39;/&#39; + file[&quot;fname&quot;]); var caption = file[&quot;fname&quot;]; var fileobj = $(&quot;&lt;div&gt;&lt;/div&gt;&quot;); var img = $(&#39;&lt;img&gt;&#39;); if ( file[&quot;attr&quot;] &amp; 0x10 ) { img.attr(&quot;src&quot;, &quot;/SD_WLAN/img/folder.png&quot;); filelink.addClass(&quot;dir&quot;); } else { var array = file[&quot;fname&quot;].split(&quot;.&quot;); var ext = array.length &gt;= 2 ? array[array.length - 1] : &#39;&#39;; if ( ext.toUpperCase() == &#39;JPG&#39; ) { img.attr(&quot;src&quot;, &quot;/thumbnail.cgi?&quot; + file[&quot;r_uri&quot;] + &#39;/&#39; + file[&quot;fname&quot;]); } else { img.attr(&quot;src&quot;, &quot;/SD_WLAN/img/other.png&quot;); } filelink.addClass(&quot;file&quot;).attr(&quot;target&quot;,&quot;_blank&quot;); } // Append a file entry or directory to the end of the list. $(&quot;#list&quot;).append( fileobj.append( filelink.append( img ).append( caption ) ) ); }); } //Callback Function for Polling function polling() { var url=&quot;/command.cgi?op=102&quot;; $.get(url, function(data) { if ( $.trim(data) == &quot;1&quot; ) { location.reload(true); } }); } // Document Ready $(function() { if ( isV1(wlansd) ) { convertFileList(wlansd); } wlansd.sort(cmptime); showFileList(location.pathname); setInterval(polling, 5000); }); 実行結果 FlashAirに無線LAN接続したPCまたはスマートフォンのブラウザで確認してみましょう。 サムネイル画像が表示されたら、FlashAirの中のファイルを増やしたり減らしたり名前を変えたりして、 リロードされることを確認してみましょう。 文字の大きさや並べ方はCSSなどで工夫してみてください。 サンプルコード web_tutorial_05.zip (4KB) このサイトのサンプルコードは二条項BSDライセンスで提供されています。",
    "url": "http://localhost:4000/docs/tutorials/web/5.html",
    "relUrl": "/docs/tutorials/web/5.html"
  },
  "39": {
    "id": "39",
    "title": "複数のFlashAirを同じ無線LANへ接続して利用する",
    "content": "複数のFlashAirを同じ無線LANへ接続して利用する 本チュートリアルでは、複数のFlashAirを同じ無線LANへ接続させて、個別にFlashAirを認識して利用する方法を解説します。 システム概要 機器構成例 このチュートリアル例では、下記の機材を使用しています。 FlashAir × 2（世代・容量は問わない） 無線LANルータ（無線LAN親機となるものであれば何でも可） 無線LAN通信可能なPC（無線LAN通信可能でウェブブラウザが使用できる機器であれば何でも可） APPNAMEを利用して個別にFlashAirを認識してアクセスする方法 まずは、2枚のFlashAirをSTAモードに変更して、用意した無線LANルータに接続できるようにします。 STAモードへの変更方法は ステーションモードの利用の「方法1: 設定ファイルを直接編集する」をご確認ください。 各FlashAirのCONFIGファイルに設定する値は、たとえば下記のようになります。 1枚目のFlashAir APPMODE=5 APPNAME=flashair1 APPSSID=FOOSSID APPNETWORKKEY=password0123 2枚目のFlashAir APPMODE=5 APPNAME=flashair2 APPSSID=FOOSSID APPNETWORKKEY=password0123 APPSSIDと APPNETWORKKEYは接続先である無線LANルータのSSID（例： FOOSSID）とネットワークキー（例： password0123）を設定するので同じになりますが、 APPNAMEは必ず異なるものを設定します。 この状態で同じ無線LANルータへ接続したPCからアクセスする場合、ウェブブラウザで以下を指定します。 1枚目のFlashAirにアクセスする場合 http://flashair1/ 2枚目のFlashAirにアクセスする場合 http://flashair2/ 3枚目以降のFlashAirを追加する場合は、上記と同様に APPNAMEを重複しないよう（例： flashair3、 flashair4 …）に設定していきます。 IPアドレスを設定して個別にFlashAirを認識してアクセスする方法 APPNAMEを設定する代わりに IP_Addressを設定して個別にアクセスする方法もあります。（ APPNAMEを同時に設定しても問題ありません。） 各FlashAirのCONFIGファイルに設定する値は、たとえば下記のようになります。 1枚目のFlashAir DHCP_Enabled=NO IP_Address=192.168.43.11 Subnet_Mask=255.255.255.0 Default_Gateway=192.168.43.1 2枚目のFlashAir DHCP_Enabled=NO IP_Address=192.168.43.12 Subnet_Mask=255.255.255.0 Default_Gateway=192.168.43.1 Default_Gatewayは接続先である無線LANルータのIPアドレス（例： 192.168.43.1）を設定し、そちらに合わせて Subnet_Mask　（例： 255.255.255.0）と無線LANルータに接続している他の機器と重複しないように IP_Addressを設定します。 この状態で同じ無線LANルータへ接続したPCからアクセスする場合、ウェブブラウザで以下を指定します。 1枚目のFlashAirにアクセスする場合 http://192.168.43.11/ 2枚目のFlashAirにアクセスする場合 http://192.168.43.12/ 3枚目以降のFlashAirを追加する場合は、上記と同様に IP_Addressを重複しないよう（例： 192.168.43.13、 192.168.43.14 …）に設定していきます。",
    "url": "http://localhost:4000/docs/tutorials/advanced/5.html",
    "relUrl": "/docs/tutorials/advanced/5.html"
  },
  "40": {
    "id": "40",
    "title": "FlashAirを再読み込みする",
    "content": "FlashAirを再読み込みする このチュートリアルではFlashAirを再読み込みし、Luaスクリプトやupload.cgiで変更したファイルをOSに認識させる方法を解説します。 問題点 注意点 Windowsの場合 Linuxの場合 macOSの場合 問題点 FlashAirではLuaスクリプトやupload.cgiを使い、ファイル作成や削除を行うことができます。 その際、PCなどのSDメモリカードホスト側のOSがSDメモリカードの内容をキャッシュしていると、その変更をOSが認識する事が出来ません。 その為、SDメモリカードホスト機器とLuaやCGIから同時に変更を行うとFAT不整合が起きる可能性があります。 SDメモリカードホスト機器から一度抜き、再挿入することでSDメモリカードホスト機器にSDメモリカードの内容を再読み込みさせる事が出来ますが、 遠隔地からFlashAirを操作する場合など、直接FlashAirに触れずに再認識したい場合もあるでしょう。 このチュートリアルでは物理的にFlashAirを刺したまま、再マウントし、OSに再読み込みさせる方法を説明します。 Luaスクリプトやupload.cgiでファイル作成や削除をした後にOSからFlashAir上のファイルを読み書きする際は、 今回説明する方法でOSにカードの内容を再読み込みさせると良いでしょう。 注意点 後述する方法でFlashAirを再読み込みする間、SDメモリカードホスト側からの書き込みをしたくない場合、upload.cgiにて書き込み制限を掛けることが出来ます。 SDメモリカードホスト機器からの書き込み禁止 この書き込みの制限はFlashAirを再起動し、再読み込みすることで解除されます。 Windowsの場合 devcon.exeというツールを使い、リムーバルディスクの再接続を行います。 devcon.exeはWindows Driver Kitに付属する為、まずはWindows Driver Kitを以下URLからダウンロードし、インストールします。 Download the Windows Driver Kit (WDK) FlashAirをSDカードリーダーやPC本体付属のSDカードスロットルなどSDメモリカードホスト機器を使い、Windows PCに接続します。 デバイスマネージャーから接続したSDメモリカードホスト機器のハードウェアIDを調べます。 デバイスマネージャー上でSDメモリカードホスト機器を右クリックし、プロパティをクリックします。 詳細タブ内のプロパティでハードウェアIDを選択し、値をコピーします。 PowerShellやコマンドプロンプトを管理者として実行し、以下のコマンドを実行してください。 ※64bit版Windows 10の例です。パスはインストール環境に合わせ適宜読み替えてください。 cd &quot;C: Program Files (x86) Windows Kits 10 Tools x64&quot; devcon.exe restart &lt;ハードウェアID&gt; Linuxの場合 mount、umountというコマンドを使用します。また、SDカードを読み込む為にライブラリをインストールします。 以下のコマンドでexFATフォーマットを読み書きする為のライブラリをインストールします。 ※既にインストール済みであれば、実施不要です。 Red Hat系ディストリビューションの場合 sudo yum install exfat-fuse exfat-utils * debian系ディストリビューションの場合 * sudo apt-get install exfat-fuse exfat-utils FlashAirを接続した状態と外した状態でそれぞれ以下のコマンドを実行し、OSに認識されたデバイス名を調べます。 sudo fdisk -l 以下の様にデバイスの情報が出力されますので、FlashAirを接続した際と外した際の出力の差分を確認してください。 $ sudo fdisk -l （中略） Device Boot Start End Sectors Size Id Type /dev/mmcblkOp1 8192 131971 122880 60M c w95 FAT32 (LBA) /dev/mmcblkOp2 131072 15564799 15433728 7.4G 83 Linux （中略） Device Boot Start End Sectors Size Id Type /dev/sdb1 8192 30228479 30220288 14.4G c w95 FAT32 (LBA) 上記の場合、FlashAirは/dev/sdb1として認識されています。 FlashAirをマウントします。自動でマウントされている場合は、この手順をスキップしてください。 マウントされてるか調べる為、dfコマンドを実行し、上記で調べたデバイス名があるか確認してください。 マウントされていない場合は次のコマンドを実行して、マウントします。この例では/dev/sdb1のデバイスを/mnt/flashairにマウントすることとします。 sudo mkdir /mnt/flashair mouont /dev/sdb1 /mnt/flashair 以下のコマンドを順に実行することで、FlshAirを再接続します。 umount /dev/sdb1 mount /dev/sdb1 /mnt/flashair macOSの場合 diskutilというコマンドを使い、デバイスを再接続させます。 FlashAirを接続した状態でターミナルから以下のコマンドを実行し、OSが認識しているデバイス名を調べます。 diskutil list $ diskutil list /dev/disk0 (internal, physical): #: TYPE NAME SIZE IDENTIFIER 0: GUID_partition_scheme *251.0 GB disk0 1: EFI EFI 209.7 MB disk0s1 2: Apple_APFS Container disk1 250.8 GB disk0s2 /dev/disk1 (synthesized): #: TYPE NAME SIZE IDENTIFIER 0: APFS Container Scheme - +250.8 GB disk1 Physical Store disk0s2 1: APFS Volume Macintosh HD 160.0 GB disk1s1 2: APFS Volume Preboot 21.3 MB disk1s2 3: APFS Volume Recovery 517.8 MB disk1s3 4: APFS Volume VM 3.2 GB disk1s4 /dev/disk2 (external, physical): #: TYPE NAME SIZE IDENTIFIER 0: FDisk_partition_scheme *15.5 GB disk2 1: Windows_FAT_32 NO NAME 15.5 GB disk2s1 上記の場合、FlashAirのデバイス名はdisk2s1として認識されています。 以下のコマンドを順に実行することで、FlshAirを再接続します。 diskutil umount &lt;デバイス名&gt; diskutil mount &lt;デバイス名&gt;",
    "url": "http://localhost:4000/docs/tutorials/advanced/6.html",
    "relUrl": "/docs/tutorials/advanced/6.html"
  },
  "41": {
    "id": "41",
    "title": "SSIDとパスワードの変更",
    "content": "SSIDとパスワードの変更 このチュートリアルではSSIDとパスワードの変更方法について学びます。 現在のSSIDとパスワードを、任意のSSIDとパスワードに変更できるアプリケーションを作成します。 登録に使用するCGIは config.cgi の SSIDの設定 と ネットワークセキュリティキーの設定 です。 現在のSSIDとパスワードの表示も行いますので、こちらは command.cgi の SSIDの取得 と ネットワークパスワードの取得 を使用して取得します。 それではさっそく作ってみましょう。 画面レイアウトの作成 今回作成するアプリケーションの画面レイアウトです。 Get がタップされると、labelSSID に現在のSSID、labelPassword に現在のパスワードを表示します。 Set がタップされると、登録画面の View Controller に遷移します。 入力画面では、Done がタップされると、SSID、パスワードを登録します。 注意: MASTERCODEは、FlashAirの新しいSSIDやパスワードを設定する際に使用します。 MASTERCODEを確認するには、PCなどにFlashAirを挿入し、”/SD_WLAN/” フォルダに保存されているCONFIGファイルを、お手持ちのテキストエディタなどで開きます（FlashAirの初期設定を終えていない場合は確認ができませんので、先に済ませるようにしてください）。 また、このフォルダは隠しフォルダとなっていますので、隠しフォルダを扱う事が出来るツールを使いましょう。 以下の部品を配置します。 表示画面 UIButton(UIButton) Get : SSID、パスワードを取得 Set : SSID、パスワード登録画面を表示 Label (UILabel) labelSSID : 現在のSSIDを表示 labelPassword : 現在のパスワードを表示 登録画面 UIButton(UIButton) Done : SSID、パスワードを登録 Text View(UITextField) textMASTERCODE : 現在のMASTERCODEを入力 textSSID : 登録するSSIDを入力 textPassword1 : 登録するパスワードを入力 textPassword2 : 登録するパスワードを入力 View Controller(UIViewController) Scroll View(UIScrollView) キーボード表示時に入力欄を閲覧するために使用 その他 Navigation Controller(UINavigationController) 登録画面から表示画面へ戻るために使用 このように表示される画面を作ります。 Set がタップされた場合に表示する画面です。 サブクラスを用意します。 FSSetViewController コードの作成 SSIDとパスワードの取得 SSIDとパスワードの取得は、command.cgi にop=104 とop=105 をそれぞれ与えることで実現します。 CGIの実行には、NSString stringWithContentsOfURLを使用しています。 この関数は、指定されたエンコーディングの文字列（ここではUTF-8）と、発生した例外を返します。 Get がタップされた際の動作です。 現在のSSIDとパスワードを取得し設定しています。 FSViewController.h @interface FSViewController : UIViewController - (IBAction)buttonGetPush:(id)sender; @property (strong, nonatomic) IBOutlet UILabel *labelSSID; @property (strong, nonatomic) IBOutlet UILabel *labelPassword; @end FSViewController.m - (IBAction)buttonGetPush:(id)sender { NSError *error = nil; // Get SSID // Make url NSURL *url104 = [NSURL URLWithString:@&quot;http://flashair/command.cgi?op=104&quot;]; // Run cgi NSString *SSIDStr = [NSString stringWithContentsOfURL:url104 encoding:NSUTF8StringEncoding error:&amp;error]; if ([error.domain isEqualToString:NSCocoaErrorDomain]) { UIAlertView *alert = [[UIAlertView alloc] initWithTitle:self.title message:@&quot;op=104 Failed n check access point&quot; delegate:nil cancelButtonTitle:nil otherButtonTitles:@&quot;OK&quot;, nil]; [alert show]; NSLog(@&quot;error104 %@ n&quot;,error); return; } // Get Password // Make url NSURL *url105 = [NSURL URLWithString:@&quot;http://flashair/command.cgi?op=105&quot;]; // Run cgi NSString *passwordStr = [NSString stringWithContentsOfURL:url105 encoding:NSUTF8StringEncoding error:&amp;error]; if ([error.domain isEqualToString:NSCocoaErrorDomain]) { UIAlertView *alert = [[UIAlertView alloc] initWithTitle:self.title message:@&quot;op=105 Failed n check access point&quot; delegate:nil cancelButtonTitle:nil otherButtonTitles:@&quot;OK&quot;, nil]; [alert show]; NSLog(@&quot;error105 %@ n&quot;,error); return; } self.labelSSID.text = SSIDStr; self.labelPassword.text = passwordStr; } 6行目 SSIDの取得に使用するURLです。 op=104 を設定します。 8-9行目 CGIが実行されます。 返される文字のエンコードは、ここでは UTF-8 を使用します。 encoding:NSUTF8StringEncoding を指定しています。 21行目 パスワードの取得に使用するURLです。 op=105 を設定します。 23-24行目 CGIが実行されます。 返される文字のエンコードは、ここでは UTF-8 を使用します。 encoding:NSUTF8StringEncoding を指定しています。 33-34行目 返された文字列（SSID、パスワード）を、Label に設定しています。 SSIDとパスワードの登録 SSIDとパスワードの登録は、config.cgiにて パラメータMASTERCODE、APPSSID、APPNETWORKKEY を指定することで実現します。 CGIの実行には、NSString stringWithContentsOfURLを使用しています。 この関数は、指定されたエンコーディングの文字列（ここではUTF-8）と、発生した例外を返します。 Done がタップされた際の動作です。 入力値のチェックを行った後、SSIDとパスワードを登録しています。 FSSetViewController.h @interface FSSetViewController : UIViewController @property (strong, nonatomic) IBOutlet UITextField *textMASTERCODE; @property (strong, nonatomic) IBOutlet UITextField *textSSID; @property (strong, nonatomic) IBOutlet UITextField *textPassword1; @property (strong, nonatomic) IBOutlet UITextField *textPassword2; - (IBAction)buttonDonePush:(id)sender; @end FSSetViewController.m - (IBAction)buttonDonePush:(id)sender { NSError *error = nil; // Check NSCharacterSet *charSet = [NSCharacterSet whitespaceAndNewlineCharacterSet]; // MASTERCODE NSString *mastercodeText = [self.textMASTERCODE.text stringByTrimmingCharactersInSet:charSet]; if ([mastercodeText isEqualToString:@&quot;&quot;]){ UIAlertView *alert = [[UIAlertView alloc] initWithTitle:self.title message:@&quot;Enter MASTERCODE&quot; delegate:nil cancelButtonTitle:nil otherButtonTitles:@&quot;OK&quot;, nil]; [alert show]; return; } // SSID NSString *ssidText = [self.textSSID.text stringByTrimmingCharactersInSet:charSet]; if ([ssidText isEqualToString:@&quot;&quot;]){ UIAlertView *alert = [[UIAlertView alloc] initWithTitle:self.title message:@&quot;Enter SSID&quot; delegate:nil cancelButtonTitle:nil otherButtonTitles:@&quot;OK&quot;, nil]; [alert show]; return; } // password NSString *password1Text = [self.textPassword1.text stringByTrimmingCharactersInSet:charSet]; NSString *password2Text = [self.textPassword2.text stringByTrimmingCharactersInSet:charSet]; if ([password1Text isEqualToString:@&quot;&quot;] || [password2Text isEqualToString:@&quot;&quot;]){ UIAlertView *alert = [[UIAlertView alloc] initWithTitle:self.title message:@&quot;Enter password&quot; delegate:nil cancelButtonTitle:nil otherButtonTitles:@&quot;OK&quot;, nil]; [alert show]; return; }else if(![password1Text isEqualToString:password2Text]){ UIAlertView *alert = [[UIAlertView alloc] initWithTitle:self.title message:@&quot;Password mismatch!&quot; delegate:nil cancelButtonTitle:nil otherButtonTitles:@&quot;OK&quot;, nil]; [alert show]; return; } // Set SSID and password // Make url NSString *urlStr = [@&quot;http://flashair/config.cgi?MASTERCODE=&quot; stringByAppendingString:mastercodeText]; urlStr = [urlStr stringByAppendingString:@&quot;&amp;APPNETWORKKEY=&quot;]; urlStr = [urlStr stringByAppendingString:password1Text]; urlStr = [urlStr stringByAppendingString:@&quot;&amp;APPSSID=&quot;]; urlStr = [urlStr stringByAppendingString:ssidText]; NSURL *url = [NSURL URLWithString:urlStr]; // Run cgi NSString *rtnStr =[NSString stringWithContentsOfURL:url encoding:NSUTF8StringEncoding error:&amp;error]; if ([error.domain isEqualToString:NSCocoaErrorDomain]){ NSLog(@&quot;config.cgi %@ n&quot;,error); return; }else{ if([rtnStr isEqualToString:@&quot;ERROR&quot;]){ UIAlertView *alert = [[UIAlertView alloc] initWithTitle:self.title message:@&quot;config.cgi failed&quot; delegate:nil cancelButtonTitle:nil otherButtonTitles:@&quot;OK&quot;, nil]; [alert show]; return; } } // Close this View [self.navigationController popToRootViewControllerAnimated:YES]; } -(BOOL)textFieldShouldReturn:(UITextField*)textField{ [textField resignFirstResponder]; return YES; } 5-42行目 チェック処理です。 未入力チェック、パスワードの不一致チェックを行っています。 46-52行目 使用するURLです。 config.cgi?MASTERCODE=（入力値）&amp;APPNETWORKKEY=（入力値）&amp;APPSSID=（入力値）を設定します。 54-55行目 CGIが実行されます。 返される文字のエンコードは、ここでは UTF-8 を使用します。 encoding:NSUTF8StringEncoding を指定しています。 70行目 登録が成功した場合に、最初の画面に戻ります。 74-77行目 キーボードの Done がタップされた際、キーボードが閉じるようにしています。 実行結果 プログラムが出来上がったら、確認をしてみましょう。 まずは Get をタップしてみます。 現在のSSIDとパスワードが表示されました。 次に、 Set をタップします。 ここで、前述したMASTERCODEの入力が必要になるので、FlashAirのCONFIGファイルを確認し、値を把握しておきます。 MASTERCODE、SSID、パスワードを入力します。 パスワードは同じもの２回入力してください。 注意: 入力したSSID、パスワードは必ず覚えておいてください。 Done をタップした後は、今までのSSID、パスワードは無効となり、FlashAirとの接続が切れます。 再度、接続をするためには、入力したSSID、パスワードが必要になります。 Done をタップします。 SSIDとパスワードが切り替わっているので、登録内容を確認する前に無線LANの接続先を、今回登録したSSIDに切り替えます。 Get をタップします。 新しく登録したSSIDとパスワードが表示されました。 以上で、SSIDとパスワードの変更 に関する解説はおわりです。 サンプルコード ios_tutorial_06.zip (25KB) このサイトのサンプルコードは二条項BSDライセンスで提供されています。",
    "url": "http://localhost:4000/docs/tutorials/ios/6.html",
    "relUrl": "/docs/tutorials/ios/6.html"
  },
  "42": {
    "id": "42",
    "title": "SSIDとパスワードの変更",
    "content": "SSIDとパスワードの変更 無線LANでやりとりされるデータを暗号化して安全に通信するために、 ネットワークパスワードを独自のものに変更することが望ましいでしょう。 また、FlashAirの無線LANを識別する名前 (SSID) も、 他の人のFlashAirなどの無線LANと区別しやすいわかりやすい名前に変えておくとよいでしょう。 このチュートリアルでは、FlashAirのSSIDとネットワークパスワードを取得および設定する方法について解説します。 現在の設定を読み込んで表示し、それを変更することができるウェブアプリを作成します。 FlashAirのSSIDとネットワークパスワードを取得するには command.cgiを、 設定するには config.cgiを使用します。 なお、ステーションモードではネットワークパスワードの取得ができません。 本チュートリアルは、アクセスポイントモードにて学習ください。 マスターコード FlashAirの設定を変更する場合には、マスターコードという設定変更専用のパスワードが必要です。 SSIDとパスワードは、誤って変更すると無線LAN接続ができなくなってしまう、重要な情報です。 そのため、マスターコードを管理者だけの秘密にしておくことで、変更を制限することができる仕組みになっているわけです。 標準のブラウザユーティリティやアプリを使った場合、 マスターコードには、初めて使うときに設定作業を行ったPC、またはスマートフォンのMACアドレスが使われます。 このサンプルプログラム中でもMACアドレスをマスターコードとして使用することとします。 以下、本チュートリアルでは、 あらかじめPC、またはスマートフォンのいずれかを用い、 初期設定は完了して、そのデバイスのMACアドレスがマスターコードとして設定されているものとします。 また、初期設定に使ったデバイスから操作するものとします。 画面レイアウトの作成 これまでと同様、JavaScriptを読み込む部分のほか、 マスターコード(MACアドレス)、SSID、ネットワークパスワードを表示する部分と、 変更した設定を反映するためのボタンを用意しています。 本チュートリアルでは、わかりやすいようにマスターコード(MACアドレス)を画面に表示していますが、 セキュリティ上、表示すべきでないでしょう。 同様に、パスワードも ********などと表示するのが良いでしょう。 作成したファイルは /SD_WLAN/Config.htmとして保存します。 /SD_WLAN/Config.htm &lt;!doctype html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;FlashAir&lt;/title&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Flash Air Configuration&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;/SD_WLAN/js/jquery.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;/SD_WLAN/js/config.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;header&quot;&gt; &lt;h1&gt;header&lt;/h1&gt; &lt;/div&gt; &lt;hr&gt; &lt;div&gt;&lt;a href=&quot;/&quot;&gt;Back to TopPage&lt;/a&gt;&lt;/div&gt; &lt;div id=&quot;formarea&quot;&gt; Mastercode&lt;br&gt; &lt;span id=&quot;mastercode&quot;&gt;&lt;/span&gt;&lt;br&gt; SSID&lt;br&gt; &lt;input name=&quot;appssid&quot; id=&quot;appssid&quot; type=&quot;text&quot; value=&quot;&quot; maxlength=&quot;32&quot; /&gt;&lt;br&gt; Password&lt;br&gt; &lt;input name=&quot;appnetworkkey&quot; id=&quot;appnetworkkey&quot; type=&quot;text&quot; value=&quot;&quot; maxlength=&quot;63&quot;/&gt;&lt;br&gt; &lt;button id=&quot;submit&quot;&gt;submit&lt;/button&gt;&lt;span id=&quot;result&quot;&gt;&lt;/span&gt; &lt;/div&gt; &lt;hr&gt; &lt;div id=&quot;footer&quot;&gt; footer &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 18, 20, 22行目 デバイスのマスターコード(MACアドレス)、SSID、ネットワークパスワードを表示または編集するための領域です。 idにJavaScriptからアクセスするための名前を設定しています。 22行目 type=&quot;password&quot;とすれば、********などと文字がそのまま表示されなくなります。 取得、表示、変更を行うコードの実装 ページの読み込み完了時にcommand.cgiを呼び、 デバイスのマスターコード(MACアドレス)、SSID、ネットワークパスワードをそれぞれ取得します。 ボタンクリック時にconfig.cgiを呼び出し、新たな設定値を送ります。 成功すると SUCCESSが、失敗すると ERRORが返ってきますので、それを画面に表示します。 /SD_WLAN/js/config.js // JavaScript Document function getMasterCode(){ var url=&quot;/command.cgi?op=106&quot;; $.get(url,function(data){ $(&#39;#mastercode&#39;).text(data); mastercode=data; }); } function getSSID(){ var url=&quot;/command.cgi?op=104&quot;; $.get(url,function(data){ $(&#39;#appssid&#39;).val(data); }); } function getAPPNETWORKKEY(){ var url=&quot;/command.cgi?op=105&quot;; $.get(url,function(data){ $(&#39;#appnetworkkey&#39;).val(data); }); } function setParams(){ var datetime = new Date(); var url=&quot;/config.cgi?MASTERCODE=&quot;+mastercode +&quot;&amp;APPSSID=&quot;+$(&quot;#appssid&quot;).val() +&quot;&amp;APPNETWORKKEY=&quot;+$(&quot;#appnetworkkey&quot;).val() +&quot;&amp;TIME=&quot;+datetime.getTime(); $.get(url,function(data){ $(&#39;#result&#39;).text(data); }); } //Document Ready $(function() { getMasterCode(); getSSID(); getAPPNETWORKKEY(); $(&quot;#submit&quot;).click(setParams); }); 2-8行目 /command.cgi?op=106を使用してデバイスのマスターコード(MACアドレス)を取得し、画面に表示しています。 また、変更する際に使うのでmastercodeという変数に保存しています。 9-14行目 command.cgi?op=104を使用してSSIDを取得し、画面に表示しています。 15-20行目 command.cgi?op=105を使用してネットワークパスワードを取得し、画面に表示しています。 21-30行目 編集されたSSIDとネットワークパスワードをFlashAirに設定する部分です。 config.cgiを使用します。 ブラウザがキャッシュを使わずに確実にCGIコマンドが発行されるよう、TIMEパラメータに現在時刻を付加して、毎回異なるリクエストを生成しています。 36行目 ボタンがクリックされたときに、設定を反映する関数(setParams())を呼び出す設定を行っています。 実行結果 FlashAirに無線LAN接続したPCまたはスマートフォンのブラウザで確認してみましょう。 ブラウザのURL入力ボックスに下記のように打ち込みます。 http://flashair/SD_WLAN/Config.htm 現在の設定が表示され(下図・左)、値を変更して submitボタンを押すと設定変更を行います。 うまくいけば SUCCESSと表示されます(下図・右)。 なお、設定変更CGIコマンドを実行すると、無線LAN接続が切断されます。変更後のSSIDでつなぎ直しましょう。 サンプルコード web_tutorial_06.zip (2KB) このサイトのサンプルコードは二条項BSDライセンスで提供されています。",
    "url": "http://localhost:4000/docs/tutorials/web/6.html",
    "relUrl": "/docs/tutorials/web/6.html"
  },
  "43": {
    "id": "43",
    "title": "OAUTH2を使ったDropboxへのアップロード",
    "content": "OAUTH2を使ったDropboxへのアップロード このチュートリアルでは、Dropboxへファイルをアップロードする方法をみていきます。このスクリプトは、アップロードとアクセストークンの保存を行います。 はじめに FlashAirにUploadフォルダを作成し、アップロードするファイルを設置します。 アップロード機能を有効にするために、CONFIGファイルにUPLOAD=1を追加します。 FlashAirでLuaを実行するを参考に、Luaスクリプト実行方法をCONFIGファイルに指定します。 アプリの登録 この作業は、インターネットに接続されたPC上で行います。 Dropbox Developersを開きます。 画面右上の”Sign in”をクリックし、Dropboxアカウントにログインします。 ログイン後、左ナビゲーションの”My apps”をクリックし、”Create apps”をクリックします。 APIの設定をすべて入力し、”Create app”をクリックしてください。 例: “Dropbox API”,”App folder”,”Lua Upload” appが作成できると、App keyとApp secretが取得できます。App secretは”Show”をクリックすると表示されます。これらの情報は取扱に注意し、他人と共有しないようにしてください。 以下のリンクより”authorization code”を取得します。ウェブブラウザから以下のURLにアクセスします。client_idには取得したApp keyを入力してください。 https://www.dropbox.com/oauth2/authorize?client_id=btbjfXxXxXxXxXx&amp;response_type=code APIリクエストの承認画面が出るので、”許可”をクリックします。 APIリクエストが承認されました。取得した”authorization code”を控えておきます。 さあはじめましょう これで準備ができました。もし最後に実行するスクリプトで、再認証が求められたら、取得したコードの期限が切れている可能性がありますので、再度”authorization code”を取得します。 /DropboxUpload.lua --[[ FlashAir Lua Dropbox example. This script uploads and files in a directory to dropbox, using oauth2. It will store the access token in dropbox_token.txt --]] local tokenfile = &quot;/dropbox_token.txt&quot; -- Where to log output on the FA local folder = &quot;/Upload&quot; -- What folder to upload files from local app_key = &quot;btbjfXxXxXxXxXx&quot; -- Your Dropbox app&#39;s key local app_secret = &quot;4k79gXxXxXxXxXx&quot; -- Your Dropbox app&#39;s secret --NOTE: Remember to authorize your app! local auth_code = &quot;XrfRXkfTNcXxXxXxXxXxXxXxXxXxXxXxXxXxXxXxXxX&quot; -- authorization code 次に、 fa.requestを使用して、アクセストークンを取得しましょう。 --[[ requestToken(app key, app secret, authorization code) requests the oath2 token, using fa.request(). returns the token, or nil on a failure. --]] local function requestToken(key, secret, auth_code) --Request a token message = &quot;grant_type=authorization_code&amp;code=&quot;..auth_code..&quot;&amp;client_id=&quot;..key..&quot;&amp;client_secret=&quot;..secret b, c, h = fa.request{ url = &quot;https://api.dropboxapi.com/oauth2/token&quot;, method = &quot;POST&quot;, headers = {[&quot;Content-Length&quot;] = string.len(message), [&quot;Content-Type&quot;] = &quot;application/x-www-form-urlencoded&quot;}, body = message } --Decode the response body (json format) response = cjson.decode(b) access_token = response[&quot;access_token&quot;] if access_token ~= nil then return access_token else error = response[&quot;error_description&quot;] print(&quot;Failed to get access token. Error: &quot;..c..&quot;: &quot;..error) return nil end end 取得したトークンを保存するために、2つの関数を用意ましょう。 Note: FlashAirをPCにマウントしてスクリプトを実行している場合、アクセストークンファイルを書き込めないことがあります。その場合は、一度FlashAir取り出して、もう一度実行してみてください。 --[[ These functions simply load or save the access token to/from a file (tokenfile). --]] local function saveToken(access_token) local file = io.open(tokenfile, &quot;w&quot; ) file:write(access_token) io.close(file) end local function loadToken() local file = io.open(tokenfile, &quot;r&quot; ) access_token = nil if file then access_token = file:read( &quot;*a&quot; ) end return access_token end 最後に、実際にファイルをアップロードする関数を書いてみましょう。ここでは、また fa.requestを使用して、PUTリクエストを実行します。 --[[ uploadFile(folder, file name, access token) Attempts to upload a file to dropbox! --]] local function uploadFile(folder, file, access_token) file_path=folder .. &quot;/&quot; .. file --get the size of the file local filesize = lfs.attributes(file_path,&quot;size&quot;) if filesize ~= nil then print(&quot;Uploading &quot;..file_path..&quot; size: &quot;..filesize) else print(&quot;Failed to find &quot;..file_path..&quot;... something wen&#39;t wrong!&quot;) return end --Upload! b, c, h = fa.request{ url = &quot;https://content.dropboxapi.com/2/files/upload&quot;, method = &quot;POST&quot;, headers = {[&quot;Authorization&quot;] = &quot;Bearer &quot;..access_token, [&quot;Content-Length&quot;] = filesize, [&quot;Content-Type&quot;] = &quot;application/octet-stream&quot;, [&quot;Dropbox-API-Arg&quot;] = &#39;{&quot;path&quot;:&quot;&#39;..file_path..&#39;&quot;,&quot;mode&quot;:{&quot;.tag&quot;:&quot;overwrite&quot;}}&#39;}, body = &quot;&lt;!--WLANSDFILE--&gt;&quot;, bufsize = 1460*10, file=file_path } print(c) print(b) end これで全てがそろいました。さあ実行してみましょう！保存しているトークンの読み込みを行います。読み込みが失敗した場合、トークンをリクエスト、もしくはauthorization codeの入力を要求します。 そして、LuaFileSystemを使ってディレクトリ内をスキャンし、 FTPチュートリアル同様にアップロードします。 --Script starts --Attempt to load a token from the file token = loadToken() --See if we loaded one, if not request one if token == nil then --Request an access token print(&quot;No token found, attempting to request one...&quot;) token = requestToken(app_key, app_secret, auth_code) --Was it successful? if token == nil then print(&quot;Failed to request token, do you need to authorize?&quot;) print(&quot;Auth url: https://www.dropbox.com/oauth2/authorize?client_id=&quot;..app_key..&quot;&amp;response_type=code&quot;) else print(&quot;New token: &quot;..token) saveToken(token) end end --Before continuing, make sure we have an access token if token ~= nil then print(&quot;INIT, with token: &quot;..token) -- For each file in folder... for file in lfs.dir(folder) do -- Get that file&#39;s attributes attr = lfs.attributes(folder .. &quot;/&quot; .. file) -- Don&#39;t worry about directories (yet) if attr.mode == &quot;file&quot; then --Attempt to upload the file! uploadFile(folder, file, token) end end end Dropboxにアクセスし、アプリフォルダをクリックします。 作成したアプリ名をクリックします。 アップロードしたファイルが表示されます。 サンプルコード リポジトリを見る（GitHub） このサイトのサンプルコードはLGPLv2または二条項BSDライセンスで提供されています。",
    "url": "http://localhost:4000/docs/tutorials/lua/6.html",
    "relUrl": "/docs/tutorials/lua/6.html"
  },
  "44": {
    "id": "44",
    "title": "Webページの取得",
    "content": "Webページの取得 本チュートリアルでは、iSDIOコマンドでFlashAirを制御し、 インターネット上のファイルを取得してみます。 概要 iSDIOの無線LAN仕様には、HTTP (HyperText Transfer Protocol) 通信を利用したデータの送受信機能が含まれています。 通信に必要な HTTPや TCP/IP (Transmission Control Protocol/Internet Protocol) の処理を、 Arduino自身が行うことなくすべてFlashAirに任せることができます。 逆に言えば、それ以外のプロトコルを使うことはできませんが、 Arduinoの小さいRAMの上では、このトレードオフは多くの場合でメリットの方が大きいのではないでしょうか。 本チュートリアルでは、Webページの取得を行ってみましょう。 HTTP通信コマンドの種類 HTTP通信コマンドには、プロトコルやデータの渡し方の違いなどにより、いくつかのバージョンがあります。 コマンドID 名称 プロトコル 送信データの種類 コマンドにデータを渡す方法 21h SendHTTPMessageByRegister HTTP テキスト メモリ上から 22h SendHTTPFileByRegister HTTP ファイル メモリ上から 23h SendHTTPSSLMessageByRegister HTTP over SSL テキスト メモリ上から 24h SendHTTPSSLFileByRegister HTTP over SSL ファイル メモリ上から 25h SendHTTPMessageByFile HTTP テキスト ファイルから 26h SendHTTPFileByFile HTTP ファイル ファイルから 27h SendHTTPSSLMessageByFile HTTP over SSL テキスト ファイルから 28h SendHTTPSSLFileByFile HTTP over SSL ファイル ファイルから いずれも Send から始まる名前ですが、送受信両方に使います。 HTTP通信は、クライアントからリクエストを送信し、サーバーが返信する、という仕組みだからです。 ファイルを返信してというリクエストであればサーバーからのファイル受信、 リクエストにファイルを付けて送るとサーバーへのファイル送信、となります。 HTTPに関しては Wikipediaをご覧ください。 なお、受信サイズは最大2048バイトとなっています。(iSDIOヘッダを除くと2024バイト。) 送信にはファイルを使う方法があるためサイズ制限は厳しくありません。 SendHTTPSSLMessageByRegisterコマンドの作成 この例では、FlashAir Developersのトップページのデータを取得することにします。 リクエストの送信 FlashAir Developersは、暗号化された通信を行うため HTTP over SSL (Secure Socket Layer) を使用しています。 データ取得には、HTTPの GETというコマンドを使います。 GETリクエストでは、リクエストヘッダのテキストデータのみが必要です。 以上の条件から、コマンドID 23hの、SendHTTPSSLMessageByRegisterコマンドを使います。 arduino_tutorial_6.ino (一部抜粋) boolean iSDIO_http(uint32_t sequenceId) { Serial.print(F(&quot; nhttp command: n&quot;)); memset(buffer, 0, 512); uint8_t* p = buffer; p = put_command_header(p, 1, 0); p = put_command_info_header(p, 0x23, sequenceId, 2); p = put_str_arg(p, &quot;flashair-developers.com&quot;); // Argument #1. p = put_str_arg(p, // Argument #2. &quot;GET /en/ HTTP/1.1 r n&quot; &quot;Host: flashair-developers.com r n&quot; &quot;User-Agent: Mozilla/5.0 (Windows NT 6.3; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/36.0.1985.125 Safari/537.36 r n&quot; &quot; r n&quot;); put_command_header(buffer, 1, (p - buffer)); printHex(buffer, (p - buffer)); return card.writeExtDataPort(1, 1, 0x000, buffer) ? true : false; } 7行目 サーバーのドメイン名を指定します。IPアドレスも指定できます。 9行目 GETコマンドです。GET &lt;取得したいデータのパス&gt; &lt;プロトコルとバージョン&gt;&lt;改行&gt; という書式です。 プロトコルとバージョンは通常HTTP/1.1でよいでしょう。改行は r nを使うのがHTTP通信のルールです。 10行目 ホスト名を指定します。 11行目 ユーザーエージェントを指定ています。FlashAir Developersは、ユーザーの使っているウェブブラウザを判別して 対応していないブラウザを使っている場合に警告を出しています。そのため、この例ではChromeのユーザーエージェント名を指定し（つまりChromeのふりをして）、 正しいデータが返ってくるようにしています。 12行名 最後に空行をつけます。 レスポンスの受信 コマンド完了を待機してから、取得したデータを読み取ります。 Response Dataに、サーバーから返されたデータが書かれています。 コマンド完了待機とデータの読み取り方法は、 APモードでの起動の コマンド処理状況の確認 を参照してください。 今回はWebページのテキストデータが書かれていることを期待していますので、そのまま画面出力してみます。 iSDIO Command Response Data (SD Specifications Part E7 Wireless LAN Simplified Addendum Version 1.10より抜粋) Response Registerポートは一度に512バイトまでしか読み出せないため、 レスポンスデータ (Size of iSDIO Command Response Data) が大きい場合は、適切な回数だけ読み出しを繰り返す必要があります。その場合、iSDIO Command Response Dataは読み出したデータを連結したものとして考えます。 つまり、繰り返し読んでもヘッダは一度しか現れません。 arduino_tutorial_6.ino (一部抜粋) boolean iSDIO_httpResponse() { // Read header and data. if (!card.readExtDataPort(1, 1, 0x200, buffer)) { return false; } uint32_t totalSize = get_u32(buffer + 20); uint32_t availableSize = totalSize &gt; 488 ? 488 : totalSize; uint32_t pos = 24; for (;;) { for (uint32_t i = 0; i &lt; availableSize; ++i) { Serial.print((char)buffer[pos + i]); } totalSize -= availableSize; // Have we read all data? if (totalSize == 0) break; // Read next data. if (!card.readExtDataPort(1, 1, 0x200, buffer)) { return false; } availableSize = totalSize &gt; 512 ? 512 : totalSize; pos = 0; } return true; } 3-8行目 レスポンスの最初の部分を読み出します。先頭24バイト分はデータサイズなどの情報が書かれています。 必要な情報を保存しています。 9-24行目 サーバから受信したHTMLデータを画面に表示する部分です。 サイズが大きい場合は残りの部分を512バイトずつ読み取っています。 メインプログラム メインプログラムに、追加します。 arduino_tutorial_06.ino (一部抜粋) void loop() { .. (snip) .. Serial.print(F(&quot; n5. HTTP Get&quot;)); .. (snip) .. case 5 : if (iSDIO_http(nextSequenceId) &amp;&amp; iSDIO_waitResponse(nextSequenceId)) { iSDIO_httpResponse(); Serial.println(F(&quot; nSuccess.&quot;)); } else { Serial.print(F(&quot; nFailed or waiting. errorCode=&quot;)); Serial.println(card.errorCode(), HEX); } nextSequenceId++; break; .. (snip) .. } } 実行結果 実行してみましょう。 注意点： 以降ではInternetにアクセスできる無線LANが必要です。準備してから先に進んでください。 注意点： もしFlashAirが別の機器につながっている場合は、まずDisconnectを実行してください。 Initializing SD card...OK Waiting response Process Succeeded ... (snip) ... 0. Show status 1. Disconnect 2. Establish 3. Connect 4. Scan 5. HTTP Get Command? (next sequence id = 1) Connectコマンドで、Internetの利用できる無線LANにつなぎます。 ここでは、iPhoneのインターネット共有（テザリング）を使ってみます。 シリアルターミナルのボックスに、 3、Enterと入力します。 つづいて、SSIDとパスワードを入力します。 (SSIDとパスワードの入力は、; (セミコロン) で終端することを忘れずに！) SSID? iPhone Network Key? 12345678 Connect command: 00: 01010000300000000000000000000200 01: 0200000002000000060000006950686F 02: 6E650000080000003132333435363738 Waiting response Command Processing............. Process Succeeded Success. ステータスで、IPアドレスが正しく得られていることを確認しましょう。 ... (snip) ... [0550h] IP Address: 172.20.10.4 ... (snip) ... 続いてHTTPによる受信です。 シリアルターミナルのボックスに、 5、Enterと入力します。 Command? (next sequence id = 2) http command: 00: 01010000E80000000000000000002300 01: 030000000200000017000000666C6173 02: 686169722D646576656C6F706572732E 03: 636F6D00AF000000474554202F656E2F 04: 20485454502F312E310D0A486F73743A 05: 20666C6173686169722D646576656C6F 06: 706572732E636F6D0D0A557365722D41 07: 67656E743A204D6F7A696C6C612F352E 08: 30202857696E646F7773204E5420362E 09: 333B20574F57363429204170706C6557 0A: 65624B69742F3533372E333620284B48 0B: 544D4C2C206C696B65204765636B6F29 0C: 204368726F6D652F33362E302E313938 0D: 352E313235205361666172692F353337 0E: 2E33360D0A0D0A00 Waiting response Command Processing... Process Succeeded HTTP/1.1 200 OK Date: Tue, 21 Oct 2014 06:25:10 GMT Server: Apache/2.2.15 (CentOS) X-Powered-By: PHP/5.3.3 Set-Cookie: FASSID=c637h0hs62jvc9055f5krvpfc4; path=/ Cache-Control: max-age=0, no-cache, no-store, must-revalidate, post-check=0, pre-check=0 Pragma: no-cache Set-Cookie: FASSID=o4365cm2e7nqf4afflk727flr3; path=/ Set-Cookie: FASSID=u5h3v3tf0ik7kn2jv3os2aakc4; path=/ X-Mod-Pagespeed: 1.8.31.4-4056 Vary: Accept-Encoding,User-Agent Content-Length: 25710 Connection: close Content-Type: text/html; charset=UTF-8 &lt;!DOCTYPE html&gt; &lt;!--[if lt IE 7]&gt; &lt;html class=&quot;no-js lt-ie9 lt-ie8 lt-ie7&quot; lang=&quot;en&quot;&gt; &lt;![endif]--&gt; &lt;!--[if IE 7]&gt; &lt;html class=&quot;no-js lt-ie9 lt-ie8&quot; lang=&quot;en&quot;&gt; &lt;![endif]--&gt; &lt;!--[if IE 8]&gt; &lt;html class=&quot;no-js lt-ie9&quot; lang=&quot;en&quot;&gt; &lt;![endif]--&gt; &lt;!--[if gt IE 8] --&gt; &lt;html lang=&quot;en&quot;&gt; &lt;!-- &lt;![endif] --&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;/&gt; &lt;!-- %meta{:content =&gt; &quot;IE=edge,chrome=1&quot;, &quot;http-equiv&quot; =&gt; &quot;X-UA-Compatible&quot;} --&gt; &lt;!--Google Apps verification--&gt; &lt;title&gt;FlashAir Developers - Home&lt;/title&gt; &lt;meta content=&quot;width=device-width, initial-scale=1.0&quot; name=&quot;viewport&quot;/&gt; &lt;!--[if lt IE 9]&gt; &lt;script src=&quot;http://html5shim.googlecode.com/svn/trunk/html5.js&quot;&gt;&lt;/script&gt; &lt;![endif]--&gt; &lt;link href=&quot;/images/flashair_favicon.ico&quot; rel=&quot;shortcut icon&quot;/&gt; &lt;link href=&quot;/images/apple-touch-icon-114x114-precomposed.png&quot; rel=&quot;apple-touch-icon-precomposed&quot; sizes=&quot;114x114&quot;/&gt; &lt;link href=&quot;/images/apple-touch-icon-72x72-precomposed.png&quot; rel=&quot;apple-touch-icon-precomposed&quot; sizes=&quot;72x72&quot;/&gt; &lt;link href=&quot;/images/apple-touch-icon-57x57-precomposed.png&quot; rel=&quot;apple-touch-icon-precomposed&quot;/&gt; &lt;link href=&quot;/css/bootstrap.css&quot; media=&quot;screen&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot;/&gt; &lt;link href=&quot;/css/responsive.css&quot; media=&quot;screen&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot;/&gt; &lt;link href=&quot;/css/font-awesome.css&quot; media=&quot;screen&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot;/&gt; &lt;link href=&quot;/css/theme.css&quot; media=&quot;screen&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot;/&gt; &lt;link href=&quot;/css/fonts.css&quot; media=&quot;screen&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot;/&gt; &lt;link href=&quot;/css/prett Success. ... (snip) ... HTTP/1.1 200 OKと書かれた行から、 Success.の上の行までが、受信したデータです。 受信サイズ制限のため切れてしまっていますが、FlashAir Developersのページが受信できました。 サンプルコード arduino_tutorial_06.zip (24KB) 本チュートリアルのサンプルコードはGPLv3および二条項BSDライセンスで提供されています。 詳細はダウンロードした各ファイルを参照してください。",
    "url": "http://localhost:4000/docs/tutorials/arduino/6.html",
    "relUrl": "/docs/tutorials/arduino/6.html"
  },
  "45": {
    "id": "45",
    "title": "SSIDとパスワードの変更",
    "content": "SSIDとパスワードの変更 このチュートリアルではSSIDとパスワードの取得と更新方法について学びます。 command.cgi と config.cgi を使用します。 ここでは、SSIDとパスワードを取得し表示する画面、SSIDとパスワードを新しい内容で更新する画面の、２つの画面を持つアプリケーションとして作ってみましょう。 １つ目の画面はボタンを２つ用意します: “Get” をクリック（タップ）すると、テキストフィールドに現在のSSIDとパスワードを表示することができます: “Set” をクリック（タップ）すると次の画面へ遷移し、 新しいSSIDとパスワードを設定することができます: アプリケーションを作成するために、次のファイルを作成します: MainActivity.java activity_main.xml SetScreenActivity.java activity_set_screen.xml 重要: Android application は、デフォルトの状態ではインターネットにアクセスすることができません。 そのため、設定ファイル AndroidManifest.xml を変更し、権限を与える必要があります。 パス: [Project_Folder]/AndroidManifest.xml AndroidManifest.xml に以下のコードを追加してください: &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt; ではまず、 activity_main.xml を記述して、レイアウトを決定します。 このファイルは、layout フォルダに配置されています。 パス: [Project_Folder]/res/layout/activity_main.xml Get 画面のレイアウト作成 activity_main.xml に以下のように記述してください: activity_main.xml &lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;fill_parent&quot; android:layout_height=&quot;match_parent&quot; android:gravity=&quot;center_horizontal&quot; android:orientation=&quot;vertical&quot; tools:context=&quot;.MainActivity&quot; &gt; &lt;Button android:id=&quot;@+id/button1&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:cacheColorHint=&quot;#00000000&quot; android:text=&quot;Get&quot; android:textColor=&quot;@android:color/white&quot; android:textSize=&quot;20sp&quot; /&gt; &lt;Button android:id=&quot;@+id/button2&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:cacheColorHint=&quot;#00000000&quot; android:text=&quot;Set&quot; android:textColor=&quot;@android:color/white&quot; android:textSize=&quot;20sp&quot; /&gt; &lt;TextView android:id=&quot;@+id/SSIDlabelView&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_gravity=&quot;left&quot; android:layout_marginTop=&quot;25dp&quot; android:paddingLeft=&quot;10dp&quot; android:text=&quot;SSID:&quot; android:textSize=&quot;18sp&quot; /&gt; &lt;TextView android:id=&quot;@+id/textView4&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:textSize=&quot;18sp&quot; android:text=&quot;Current SSID will be here&quot; /&gt; &lt;TextView android:id=&quot;@+id/passwordView&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_gravity=&quot;left&quot; android:layout_marginTop=&quot;25dp&quot; android:paddingLeft=&quot;10dp&quot; android:text=&quot;Password:&quot; android:textSize=&quot;18sp&quot; /&gt; &lt;TextView android:id=&quot;@+id/textView5&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:textSize=&quot;18sp&quot; android:text=&quot;Current password will be here&quot; /&gt; &lt;/LinearLayout&gt; Set 画面のレイアウト作成 次に、activity_set_screen.xml を記述して、SSIDとパスワードを設定できるレイアウトを決定します。 この画面は、ネットワークの変更に重要な役割をつとめる４つの入力欄から構成されます。 入力欄は、このXMLファイルに設定する方法となっており、テキスト入力欄を選択した際、キーボードが表示されるようにします このファイルは、layout フォルダに配置されています。 パス: [Project_Folder]/res/layout/activity_set_screen.xml activity_set_screen.xml &lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;fill_parent&quot; android:layout_height=&quot;match_parent&quot; android:gravity=&quot;center_horizontal&quot; android:orientation=&quot;vertical&quot; tools:context=&quot;.MainActivity&quot; &gt; &lt;Button android:id=&quot;@+id/button1&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:cacheColorHint=&quot;#00000000&quot; android:text=&quot;Back&quot; android:textColor=&quot;@android:color/white&quot; android:textSize=&quot;20sp&quot; /&gt; &lt;TextView android:id=&quot;@+id/mastercodeView&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_gravity=&quot;left&quot; android:layout_marginTop=&quot;12dp&quot; android:paddingLeft=&quot;10dp&quot; android:text=&quot;Mastercode:&quot; android:textSize=&quot;18sp&quot; /&gt; &lt;EditText android:id=&quot;@+id/editMC&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:ems=&quot;10&quot; android:hint=&quot;Mastercode&quot; android:inputType=&quot;text&quot; android:textStyle=&quot;italic&quot; /&gt; &lt;TextView android:id=&quot;@+id/warningView&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_gravity=&quot;left&quot; android:layout_marginTop=&quot;8dp&quot; android:paddingLeft=&quot;10dp&quot; android:text=&quot;Warning: We have displayed the Mastercode in this tutorial application to demonstrate how the FlashAir device works. This information is provided for tutorial purposes only. For security reasons, we highly discourage you from publicly displaying your Mastercode.&quot; android:textSize=&quot;12sp&quot; android:textStyle=&quot;italic&quot; /&gt; &lt;TextView android:id=&quot;@+id/SSIDlabelView&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_gravity=&quot;left&quot; android:layout_marginTop=&quot;20dp&quot; android:paddingLeft=&quot;10dp&quot; android:text=&quot;SSID:&quot; android:textSize=&quot;18sp&quot; /&gt; &lt;EditText android:id=&quot;@+id/editText1&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:ems=&quot;10&quot; android:hint=&quot;New SSID&quot; android:inputType=&quot;text&quot; android:textStyle=&quot;italic&quot; &gt; &lt;/EditText&gt; &lt;TextView android:id=&quot;@+id/passwordView&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_gravity=&quot;left&quot; android:layout_marginTop=&quot;20dp&quot; android:paddingLeft=&quot;10dp&quot; android:text=&quot;Password:&quot; android:textSize=&quot;18sp&quot; /&gt; &lt;EditText android:id=&quot;@+id/editText2&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:ems=&quot;10&quot; android:hint=&quot;New Password&quot; android:inputType=&quot;textPassword&quot; android:textStyle=&quot;italic&quot; /&gt; &lt;EditText android:id=&quot;@+id/editText3&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:ems=&quot;10&quot; android:hint=&quot;New Password&quot; android:inputType=&quot;textPassword&quot; android:textStyle=&quot;italic&quot; /&gt; &lt;Button android:id=&quot;@+id/button2&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginTop=&quot;12dp&quot; android:cacheColorHint=&quot;#00000000&quot; android:text=&quot;Done&quot; android:textColor=&quot;@android:color/white&quot; android:textSize=&quot;20sp&quot; /&gt; &lt;/LinearLayout&gt; Get 画面の作成 まず、SSIDとパスワードの取得と設定が可能な２つの Button を初期化します。 また、SSIDとパスワードの取得も実装します。このアプリケーションの他の部分でも使用します。 初期化 メンバ変数の宣言と画面の書式を設定します。 それから、各ボタンの onClickListener を設定します。 それぞれ動作が異なるので、２つの onClick() 関数を記述します: MainActivity.java (1) public class MainActivity extends Activity { TextView SSID; TextView password; Button getButton; Button setButton; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); getWindow().setTitleColor(Color.rgb(65, 183, 216)); getButton = (Button)findViewById(R.id.button1); setButton = (Button)findViewById(R.id.button2); getButton.getBackground().setColorFilter(Color.rgb(65, 183, 216), PorterDuff.Mode.SRC_IN); setButton.getBackground().setColorFilter(Color.rgb(65, 183, 216), PorterDuff.Mode.SRC_IN); try { getButton.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { // Set button to show current SSID and Password getSSID(); getPassword(); } }); } catch(Exception e) { Log.e(&quot;ERROR&quot;, &quot;ERROR: &quot; + e.toString()); e.printStackTrace(); } try { setButton.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { // Set button to start new intent to allow new SSID and password input Intent setSSIDPassword = new Intent(getBaseContext(), SetScreenActivity.class); MainActivity.this.startActivity(setSSIDPassword); } }); } catch(Exception e) { Log.e(&quot;ERROR&quot;, &quot;ERROR: &quot; + e.toString()); e.printStackTrace(); } } @Override public boolean onCreateOptionsMenu(Menu menu) { // Inflate the menu; this adds items to the action bar if it is present. getMenuInflater().inflate(R.menu.main, menu); return true; } 18-25行目 getButton のクリックリスナーを設定しています。 Buttonがクリックされた時、FlashAirから現在のSSIDを取得する関数と、FlashAirから現在のパスワードを取得する関数を呼びます(両方とも実装は後述します)。 33-38行目 setButton のクリックリスナーを設定しています。 SSIDとパスワードは他のclass と 別の画面を使用して設定するので、このリスナーは単に次の画面を開始するためのIntent を設定しています。 次の画面へ引き継ぐ情報はありませんので、追加でBundle データは送りません。 SSIDの取得 上記の関数から呼び出されている getSSID() 関数は、FlashAirから現在のSSIDを取得します。 FlashAirのSSIDは最大32文字まで設定可能です。 FlashAirの現在のSSIDを取得するためには、以下のコマンドを使用します: command.cgi にop=104 を指定します。 コマンド: http://flashair/command.cgi?op=104 コマンドが返す情報:&lt;SSID&gt; コマンドの実行には前項 Android Tutorial 3: コンテンツのダウンロードまでに作成した、 FlashAirRequest.java を使用します。 MainActivity.java (2) public void getSSID() { new AsyncTask&lt;String, Void, String&gt;(){ @Override protected String doInBackground(String... params) { return FlashAirRequest.getString(params[0]); } @Override protected void onPostExecute(String currentSSID) { SSID = (TextView)findViewById(R.id.textView4); SSID.setText(currentSSID); } }.execute(&quot;http://flashair/command.cgi?op=104&quot;); } パスワードの取得 前述した onClick() 関数から呼び出されている getPassword() は、FlashAirから現在のパスワードを取得します。 FlashAirのパスワードは最大64文字まで設定可能です。 FlashAirの現在のパスワードを取得するためには、以下のコマンドを使用します: command.cgi にop=105 を指定します。 コマンド: http://flashair/command.cgi?op=105 コマンドが返す情報: &lt;networkPassword&gt; コマンドの実行には前項 Android Tutorial 3: コンテンツのダウンロードまでに作成した、 FlashAirRequest.java を使用します。 MainActivity.java (3) public void getPassword() { new AsyncTask&lt;String, Void, String&gt;(){ @Override protected String doInBackground(String... params) { return FlashAirRequest.getString(params[0]); } @Override protected void onPostExecute(String currentPassword) { password = (TextView)findViewById(R.id.textView5); password.setText(currentPassword); } }.execute(&quot;http://flashair/command.cgi?op=105&quot;); } では、 setButton がクリックされた後の一連の処理を行う SetScreenActivity を、記述します。 設定画面の作成 注意: MASTERCODEは、FlashAirの新しいSSIDやパスワードを設定する際に使用します。 MASTERCODEを確認するには、PCなどにFlashAirを挿入し、”/SD_WLAN/” フォルダに保存されているCONFIGファイルを、お手持ちのテキストエディタなどで開きます（FlashAirの初期設定を終えていない場合は確認ができませんので、先に済ませるようにしてください）。 また、このフォルダは隠しフォルダとなっていますので、隠しフォルダを扱う事が出来るツールを使いましょう。 Mastercodeは、このファイルに保存されています: Mastercode を入手すれば、 config.cgi が使用できるようになります。 初期化 FlashAirに新しい SSID とパスワードを送るためのボタンを用意します。ラベルは ‘Done’ とし、全ての入力欄への入力が終わるまでは無効にします。 新しい画面ではユーザーの入力が必要なので、 ユーザーが入力ための EditText と 入力欄を監視するための TextWatcher を初期化します。 全部で４つの入力欄が必要であり、 Mastercode用、新しいSSID用, 新しいパスワード用、 新しいパスワードの確認用(ミスを避けるため)です。 TextWatcher class をオーバーライドし fieldWatcher をカスタマイズします。 fieldWatcher は全ての入力欄の入力内容をチェックし、その後 ‘Done’ ボタンを有効にします。 SetScreenActivity.java (1) public class SetScreenActivity extends Activity { EditText mastercodeField; EditText SSIDfield; EditText passwordField; EditText passwordField2; Button backButton; Button doneButton; String newSSID = &quot;&quot;; String newPassword = &quot;&quot;; String newPassword2 = &quot;&quot;; String mastercode = &quot;&quot;; Boolean SSIDset = false; Boolean passwordSet = false; TextWatcher fieldWatcher = new TextWatcher(){ @Override public void afterTextChanged(Editable e) { if(mastercodeField.getText().toString().isEmpty() || SSIDfield.getText().toString().isEmpty() || passwordField.getText().toString().isEmpty() || passwordField2.getText().toString().isEmpty() ) { doneButton.setEnabled(false); } else { doneButton.setEnabled(true); } } @Override public void beforeTextChanged(CharSequence cs, int start, int count, int after) { // Do nothing } @Override public void onTextChanged(CharSequence cs, int start, int before, int count) { // Do nothing } }; 17-27行目 入力欄で変更があるたび、fieldWatcher が 全ての入力欄に何かしらの入力があるかどうかをチェックします。 このチェックはdoneButton ボタンを制御するためのものです。 各フィールドに何かしらの入力があると判断した場合、 doneButton は有効になります: ユーザーがいずれかの入力欄をクリアした場合は、 doneButton は無効になります: 全ての Activityを初期化する onCreate(Bundle savedInstanceState) 関数をオーバーライドします。 この関数は、画面の書式、全ての .xml 要素の識別、そして class MainActivity から渡された Intent を設定します。 また、上記で記した fieldWatcher がそれぞれの EditText を監視するよう設定します。 SetScreenActivity.java (2) @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_set_screen); getWindow().setTitleColor(Color.rgb(65, 183, 216)); backButton = (Button)findViewById(R.id.button1); doneButton = (Button)findViewById(R.id.button2); backButton.getBackground().setColorFilter(Color.rgb(65, 183, 216), PorterDuff.Mode.SRC_IN); doneButton.getBackground().setColorFilter(Color.rgb(65, 183, 216), PorterDuff.Mode.SRC_IN); doneButton.setEnabled(false); // Disable until text fields have been filled mastercodeField = (EditText)findViewById(R.id.editMC); SSIDfield = (EditText)findViewById(R.id.editText1); passwordField = (EditText)findViewById(R.id.editText2); passwordField2 = (EditText)findViewById(R.id.editText3); mastercodeField.setHintTextColor(Color.rgb(65, 183, 216)); SSIDfield.setHintTextColor(Color.rgb(65, 183, 216)); passwordField.setHintTextColor(Color.rgb(65, 183, 216)); passwordField2.setHintTextColor(Color.rgb(65, 183, 216)); try { getIntent(); backButton.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { SetScreenActivity.this.finish(); } }); doneButton.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { getInput(); setNewSSIDPassword(); } }); mastercodeField.addTextChangedListener(fieldWatcher); SSIDfield.addTextChangedListener(fieldWatcher); passwordField.addTextChangedListener(fieldWatcher); passwordField2.addTextChangedListener(fieldWatcher); } catch(Exception e) { Log.e(&quot;ERROR&quot;, &quot;ERROR: &quot; + e.toString()); e.printStackTrace(); } } @Override public boolean onCreateOptionsMenu(Menu menu) { // Inflate the menu; this adds items to the action bar if it is present. getMenuInflater().inflate(R.menu.set_screen, menu); return true; } 10行目 doneButton はインスタンス化するとすぐに無効になります。ユーザーは全ての入力が終わるまで、FlashAirにCGIコマンドを送信することができなくなります。これにより、CGIコマンドを実行した際のエラーを回避することができます。 11-18行目 各入力欄にヒントを設定しています(ユーザーが入力を開始するまで表示します)。 34-37行目 各入力欄にfieldWatcherを追加しています。これによりユーザーが入力または削除をした際、処理を行えるようになります。 入力値の取得 次の関数は、ユーザーの入力値を取得します。 この関数は doneButtonの onClick() 関数に呼ばれます。 fieldWatcher が４つの入力欄全ての入力を見つけたときにのみ、値を取得し格納します。 SetScreenActivity.java (3) public void getInput() { mastercode = mastercodeField.getText().toString(); newSSID = SSIDfield.getText().toString(); newPassword = passwordField.getText().toString(); newPassword2 = passwordField2.getText().toString(); } 確認用パスワードの一致 新しいパスワードを入力する際の入力ミスを避けるために、このアプリケーションは２回パスワードを入力する必要があり、２つのパスワードが一致するかどうかを確認します。次の関数は、２つのパスワードが一致するかどうかをチェックし、一致する場合はCGIコマンドを送信しても安全であるということを示しています。 SetScreenActivity.java (4) public Boolean passwordConfirmed() { if(newPassword.equals(newPassword2)) { return true; } return false; } もし passwordConfirmed() が falseを返した場合は、 後述する関数 ( setNewSSIDPassword()) でパスワードをクリアし ( doneButton が無効になる)、 パスワードが異なっていることを指し示す Toastを表示します: SSIDとパスワードの設定 次の機能は、FlashAirにCGIコマンドを送信し、その応答を処理します。 コマンドを送信する前に、パスワードが正しく入力されていることを保証するため、上記の passwordConfirmed() を呼び出しています。 SSIDを設定するためには、以下のコマンドを使用します: config.cgi に Mastercode と 新しいSSIDを指定します。 Mastercode = 0123456789AB、SSID = flashair である場合は、このようになります: http://flashair/config.cgi?MASTERCODE=0123456789AB&amp;APPSSID=flashair コマンドが返す情報: SUCCESS SSIDの変更に成功 ERROR SSIDの変更に失敗 SSIDをパスワードを設定するためには、以下のコマンドを使用します: config.cgi に Mastercode と 新しいパスワードを指定します Mastercode = 0123456789AB、パスワード = 12345678 である場合は、このようになります: http://flashair/config.cgi?MASTERCODE=0123456789AB&amp;APPNETWORKKEY=12345678 コマンドが返す情報: SUCCESS パスワードの変更に成功 ERROR パスワードの変更に失敗 結合して同時に指定する場合はこのようになります: http://flashair/config.cgi?MASTERCODE=0123456789AB&amp;APPNETWORKKEY=12345678&amp;APPSSID=flashair 新しいSSIDは、1 ～ 32 文字でなければならず、パスワードは、8 ～ 64 文字の間でなければなりません。 これらの条件のいずれかに反した場合は、コマンドCGIは ERROR を返します。 コマンドの実行には前項 Android Tutorial 3: コンテンツのダウンロードまでに作成した、 FlashAirRequest.java を使用します。 SetScreenActivity.java (5) public void setNewSSIDPassword() { if(passwordConfirmed()) { // If passwords match, do HTTP command, catch and display if command fails new AsyncTask&lt;String, Void, String&gt;(){ @Override protected String doInBackground(String... params) { return FlashAirRequest.getString(params[0]); } @Override protected void onPostExecute(String result) { if(result.toUpperCase(Locale.getDefault()).equals(&quot;SUCCESS&quot;)) { Toast.makeText(SetScreenActivity.this, &quot;Remember to reconnect to your FlashAir device using the new SSID and password!&quot;, Toast.LENGTH_LONG).show(); SetScreenActivity.this.finish(); // Go back to Get screen } } }.execute(&quot;http://flashair/config.cgi?MASTERCODE=&quot; + mastercode + &quot;&amp;APPNETWORKKEY=&quot; + newPassword + &quot;&amp;APPSSID=&quot; + newSSID); } else { // If passwords don&#39;t match, display toast Toast.makeText(this, &quot;Password mismatch!&quot;, Toast.LENGTH_SHORT).show(); passwordField.setText(&quot;&quot;); passwordField2.setText(&quot;&quot;); } } 13行目 Toast を表示し、FlashAir に再接続する必要がある旨を伝えます。 元の画面（古いSSIDとパスワードデータを含む）に戻ってもToastはまだしばらくの間表示されます: 14行目 現在のActivity を終了し、最初の画面 (class MainActivity) へ戻り、再度新しいSSIDとパスワードを設定します。 SSIDとパスワードの変更に成功した場合は、AndroidはFlashAirのSSIDとパスワードが変わってしまっているので、FlashAirとの接続は切れます。 実行結果 Toastはこのように表示されます。 新しいSSIDとパスワードに変更しFlashAirに再接続した後、”Get”をタップすると、新たに変更されたSSIDとネットワークパスワードを取得します: サンプルコード android_tutorial_06.zip (532KB) このサイトのサンプルコードは二条項BSDライセンスで提供されています。",
    "url": "http://localhost:4000/docs/tutorials/android/6.html",
    "relUrl": "/docs/tutorials/android/6.html"
  },
  "46": {
    "id": "46",
    "title": "FlashAirからAmazon AWSに接続する1（準備編）",
    "content": "FlashAirからAmazon AWSに接続する1（準備編） このチュートリアルではFlashAirに保存されたデータを、インターネット経由で直接AWSに送信する方法を解説します。 概要 FlashAirをAWSに接続して使うことのメリット 準備するもの 全体の流れ 概要 AWS（Amazon Web Services）は、Amazonが提供しているWebサービスです。従量課金制なので安価なコストですぐに始められ、最新のセキュリティ状態を保ち、豊富なサービスを提供している大規模なクラウドサービスです。 個人ユーザーだけではなく多くの企業ユーザーも利用しています。 このチュートリアルでは2回に分けて、動体検知カメラで人物を定点撮影しFlashAirに書き込み、Luaスクリプトを使用して直接AWSにアップロードする方法を説明します。また、応用として撮影した顔写真から年齢や性別などをAIにより判定し、BIツールで可視化する方法を説明します。 カメラやセンサー等からFlashAirに書き込んだデータに対して高度な処理を実施したい、セキュアな環境に保存し共有したい、またはAWSの新たな使い道を探していた方等、サンプルソースと具体例を参考にぜひお試しください。 FlashAirをAWSに接続して使うことのメリット エッジデバイス（FlashAir）からクラウド（AWS）へ直接データを送信するIoTシステムを実現することができます。 FlashAir単体では難しい様々なコンピューティング処理をAWSで行うことができます。 既にAWSをお使いの場合は、既存のワークフローにFlashAirを組み合わせることができます。 準備するもの FlashAir W-04 16G 参考価格：￥5,918 FW4.00.03以降を使用してください。 Raspberry Pi 3スターターキット Amazon参考価格：￥5,480 FlashAirへの電源供給、撮影間隔の処理、FlashAirの再読み込みに使用します。 ウェブカメラLOGICOOL C270 参考価格：￥2,551 撮影に使用します。 USBカードリーダー SDカード対応の物を使用してください。Luaスクリプトの追加、修正に使用します。 クレジットカード AWS契約時に必要です。 参考今回のチュートリアルで必要なAWSの費用（リージョン：アジアパシフィック（東京））は約233円/年です（2018年9月現在）。アカウント新規登録後最初の 12 か月間は無料利用枠を利用できます。 参考合計価格：￥13,949（2018年9月現在） 全体の流れ Raspberry Pi 3 + ウェブカメラ FlashAirへの電源供給、写真撮影、FlashAirの再読み込みのために使用します。Raspberry Piとウェブカメラを接続し、動体検知のためのアプリ「Motion」をインストールしす。Raspberry Piの初期設定、アプリのインストールを済ませておいてください。 今回はハードウェア費用を抑えるためにRaspberry Piとウェブカメラを使用していますが、常時FlashAirに電源が供給されるカメラであれば同様のことを行うことができます（その場合FlashAirの再読み込みは行われません） FlashAir + Luaスクリプト 撮影した画像を一旦FlashAirに保存し、Luaスクリプトを使ってAWSへ接続し、画像をアップロードします。 Amazon S3 Amazon S3（Amazon Simple Storage Service）はインターネット用のストレージサービスです。カメラで撮影した画像や解析結果をS3内のバケット(入れ物)に格納します。 AWS Lambda AWS LambdaはS3等AWSのストレージのデータ変更に応じてコードを実行できるコンピューティングサービスです。あらかじめLambdaにアプリケーションコードを記述しておき、S3にファイルが追加されたことをLambdaが検知しRekognitionの顔認識処理を呼び出します。Rekognitionの解析処理を取得したらS3に解析結果を結果バケットに格納します。 Amazon Rekognition Amazon Rekognitionは画像認識サービスです。撮影画像から年齢、性別を判定し解析結果をLambdaに返します。 Amazon QuickSight Amazon QuickSightはファイルやAWSデータソース、外部のデータベースに対応しているビジネスインテリジェンスサービスです。S3内の解析結果を豊富なテンプレートから可視化、共有することが出来ます。 実行編では、実際にAWSアカウント作成からバケット作成、FlashAirから画像をアップロードするところまで実行してみましょう。実行編ではサンプルコードを入手することもできます。",
    "url": "http://localhost:4000/docs/tutorials/advanced/7.html",
    "relUrl": "/docs/tutorials/advanced/7.html"
  },
  "47": {
    "id": "47",
    "title": "画面デザインの改良",
    "content": "画面デザインの改良 画面デザインをより見やすいものに改良しましょう。 人気のあるWebサイト用画面デザインフレームワークである Bootstrapを使用してみます。 事前準備 Bootstrapと jQueryをダウンロードし、 ファイルをFlashAirにコピーします。 ファームウェアバージョン1系ではロングファイルネームが使えないため、短い名前にリネームします。 ファイルのコピー先とファイル名は例えば下記のようにします。 左が元々のファイル名、右がSDメモリカード内のパスを表しています。 jquery-x.yy.z.min.js --&gt; /SD_WLAN/js/jquery.js bootstrap/js/bootstrap.min.js --&gt; /SD_WLAN/js/bstrap.js bootstrap/css/bootstrap.min.css --&gt; /SD_WLAN/css/bstrap.css bootstrap/css/bootstrap-responsive.min.css --&gt; /SD_WLAN/css/bstrapr.css bootstrap/img/glyphicons-halflings.png --&gt; /SD_WLAN/img/bstrap.png bootstrap/img/glyphicons-halflings-white.png --&gt; /SD_WLAN/img/bstrapw.png ファイルをリネームしたので、 bstrap.css内を編集します。 ../img/glyphicons-halflings.png --&gt; /SD_WLAN/img/bstrap.png ../img/glyphicons-halflings-white.png --&gt; /SD_WLAN/img/bstrapw.png フォルダアイコン用の folder.pngと、画像以外のファイルのアイコン用の other.png、 ２つの画像を用意し、以下のパスに配置してください。 /SD_WLAN/img/folder.png /SD_WLAN/img/other.png 画面レイアウトの作成 HTMLファイルは コンテンツリストの取得1を元にしますが、 Bootstrap対応のためいくつか変更を加えます。 CSSの読み込み BootstrapのCSSを読み込みます。 HTML冒頭の &lt;head&gt;タグ内に置きます。 &lt;link href=&quot;/SD_WLAN/css/bstrap.css&quot; rel=&quot;stylesheet&quot; media=&quot;screen&quot;&gt; &lt;link href=&quot;/SD_WLAN/css/bstrapr.css&quot; rel=&quot;stylesheet&quot; media=&quot;screen&quot;&gt; JavaScriptの読み込み jQuery、Bootstrap、および本チュートリアルで作成するJavaScriptを読み込みます。 Bootstrapのルールにより、HTMLの本体部分の終わり（ &lt;/body&gt;の直前）で読み込みます。 &lt;script type=&quot;text/javascript&quot; src=&quot;/SD_WLAN/js/jquery.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;/SD_WLAN/js/main.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;/SD_WLAN/js/bstrap.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; wlansd = new Array(); &lt;!--WLANSDJLST--&gt; &lt;/script&gt; 表示領域の作成 &lt;body&gt;タグ内の適当な位置に、サムネイルを出力する領域を設定します。 &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;ul class=&quot;thumbnails&quot; id=&quot;list&quot;&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; メニューを付けてみる 多くのWebサイトが備えている、メニューバーを上部に表示してみましょう。 FlashAirまたはHomeと書かれたボタンを押すと、いつでもルートフォルダに戻れるようにします。 &lt;body&gt;タグ内の先頭に以下を追加します。 &lt;div class=&quot;navbar navbar-inverse navbar-fixed-top&quot;&gt; &lt;div class=&quot;navbar-inner&quot;&gt; &lt;div class=&quot;container&quot;&gt; &lt;a class=&quot;btn btn-navbar&quot; data-target=&quot;.nav-collapse&quot; data-toggle=&quot;collapse&quot;&gt; &lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt; &lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt; &lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt; &lt;/a&gt; &lt;a class=&quot;brand&quot; href=&quot;/&quot;&gt;FlashAir&lt;/a&gt; &lt;div class=&quot;nav-collapse collapse&quot;&gt; &lt;ul class=&quot;nav pull-right&quot;&gt; &lt;li class=&quot;active&quot;&gt;&lt;a href=&quot;/&quot;&gt;&lt;i class=&quot;icon-home&quot;&gt;&lt;/i&gt;Home&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#about&quot;&gt;About&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#contact&quot;&gt;Contact&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;!--/.nav-collapse --&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; さらに、メニューバーが使う余白を空けるため、 &lt;head&gt;タグ内に下記のコードを置きます。 &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;style&gt; body { padding-top: 60px; /* 60px to make the container go all the way to the bottom of the topbar */ } &lt;/style&gt; HTML全体としては次のようになります。 /SD_WLAN/List.htm &lt;!doctype html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;FlashAir&lt;/title&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;style&gt; body { padding-top: 60px; /* 60px to make the container go all the way to the bottom of the topbar */ } &lt;/style&gt; &lt;link href=&quot;/SD_WLAN/css/bstrap.css&quot; rel=&quot;stylesheet&quot; media=&quot;screen&quot;&gt; &lt;link href=&quot;/SD_WLAN/css/bstrapr.css&quot; rel=&quot;stylesheet&quot; media=&quot;screen&quot;&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;navbar navbar-inverse navbar-fixed-top&quot;&gt; &lt;div class=&quot;navbar-inner&quot;&gt; &lt;div class=&quot;container&quot;&gt; &lt;a class=&quot;btn btn-navbar&quot; data-target=&quot;.nav-collapse&quot; data-toggle=&quot;collapse&quot;&gt; &lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt; &lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt; &lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt; &lt;/a&gt; &lt;a class=&quot;brand&quot; href=&quot;/&quot;&gt;FlashAir&lt;/a&gt; &lt;div class=&quot;nav-collapse collapse&quot;&gt; &lt;ul class=&quot;nav pull-right&quot;&gt; &lt;li class=&quot;active&quot;&gt;&lt;a href=&quot;/&quot;&gt;&lt;i class=&quot;icon-home&quot;&gt;&lt;/i&gt;Home&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#about&quot;&gt;About&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#contact&quot;&gt;Contact&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;!--/.nav-collapse --&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;ul class=&quot;thumbnails&quot; id=&quot;list&quot;&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;/SD_WLAN/js/jquery.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;/SD_WLAN/js/main.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;/SD_WLAN/js/bstrap.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; wlansd = new Array(); &lt;!--WLANSDJLST--&gt; &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 5行目 日本語などを含むファイル名も正しく表示できるよう、UTF-8形式を指定しています。 19-31行目 スマートフォンなど画面が小さいデバイスの場合に、 メニューをタップ操作で開いたり閉じたりするようにしています。 37行目 この&lt;ul&gt;タグ内にサムネイル画像を追加していきます。 Bootstrapのthumbnailsクラスを設定しています。 44-47行目 FlashAirのコンテンツリストを受け取る部分です。主役を忘れないようにしましょう。 コードの変更 main.jsのサムネイルを出力する部分をBootstrap対応に改造します。 サムネイルスタイルの設定 画像のアンカータグに thumbnailクラスを設定すると、サムネイルに適した表示になります。 HTMLで設定した thumbnailsクラスとセットで使います。 var filelink = $(&#39;&lt;a class=&quot;thumbnail&quot;&gt;&lt;/a&gt;&#39;).attr(&#39;href&#39;, file[&quot;r_uri&quot;] + &#39;/&#39; + file[&quot;fname&quot;]); 画像の角を丸くする設定 イメージタグに img-roundedクラスを適用すると角丸になります。 var img = $(&#39;&lt;img class=&quot;img-rounded&quot;&gt;&#39;); その他にもクラスを設定して、調整を行います。 コード全体は次のようになります。 /SD_WLAN/js/main.js // Judge the card is V1 or V2. function isV1(wlansd) { if ( wlansd.length == undefined || wlansd.length == 0 ) { // List is empty so the card version is not detectable. Assumes as V2. return false; } else if ( wlansd[0].length != undefined ) { // Each row in the list is array. V1. return true; } else { // Otherwise V2. return false; } } // Convert data format from V1 to V2. function convertFileList(wlansd) { for (var i = 0; i &lt; wlansd.length; i++) { var elements = wlansd[i].split(&quot;,&quot;); wlansd[i] = new Array(); wlansd[i][&quot;r_uri&quot;] = elements[0]; wlansd[i][&quot;fname&quot;] = elements[1]; wlansd[i][&quot;fsize&quot;] = Number(elements[2]); wlansd[i][&quot;attr&quot;] = Number(elements[3]); wlansd[i][&quot;fdate&quot;] = Number(elements[4]); wlansd[i][&quot;ftime&quot;] = Number(elements[5]); } } // Callback Function for sort() function cmptime(a, b) { if( a[&quot;fdate&quot;] == b[&quot;fdate&quot;] ) { return a[&quot;ftime&quot;] - b[&quot;ftime&quot;]; }else{ return a[&quot;fdate&quot;] - b[&quot;fdate&quot;]; } } // Show file list function showFileList(path) { // Clear box. $(&quot;#list&quot;).html(&#39;&#39;); // Output a link to the parent directory if it is not the root directory. if ( path != &quot;/&quot; ) { // Make parent path var parentPath = path; if ( parentPath[parentPath.length - 1] != &#39;/&#39; ) { parentPath += &#39;/&#39;; } parentPath += &#39;..&#39;; // Make a link to the parent path. $(&quot;#list&quot;).append( $(&#39;&lt;li class=&quot;span2&quot;&gt;&lt;/li&gt;&#39;) .append($(&#39;&lt;a href=&quot;&#39; + parentPath + &#39;&quot; class=&quot;thumbnail&quot;&gt;&lt;/a&gt;&#39;) .append($(&#39;&lt;img class=&quot;img-rounded&quot; src=&quot;/SD_WLAN/img/folder.png&quot;&gt;&#39;)) .append($(&#39;&lt;div class=&quot;img-caption&quot;&gt;..&lt;/div&gt;&#39;))) ); } $.each(wlansd, function() { var file = this; // Skip hidden file if ( file[&quot;attr&quot;] &amp; 0x02 ) { return; } // Make a link to directories and files. var filelink = $(&#39;&lt;a class=&quot;thumbnail&quot;&gt;&lt;/a&gt;&#39;).attr(&#39;href&#39;, file[&quot;r_uri&quot;] + &#39;/&#39; + file[&quot;fname&quot;]); var caption = $(&#39;&lt;div class=&quot;img-caption&quot; style=&quot;text-align: center;&quot;&gt;&lt;/div&gt;&#39;).html(file[&quot;fname&quot;]); var fileobj = $(&#39;&lt;li class=&quot;span2&quot;&gt;&lt;/li&gt;&#39;); var img = $(&#39;&lt;img class=&quot;img-rounded&quot;&gt;&#39;); if ( file[&quot;attr&quot;] &amp; 0x10 ) { img.attr(&quot;src&quot;, &quot;/SD_WLAN/img/folder.png&quot;); } else { var array = file[&quot;fname&quot;].split(&quot;.&quot;); var ext = array.length &gt;= 2 ? array[array.length - 1] : &#39;&#39;; if ( ext.toUpperCase() == &quot;JPG&quot; ) { img.attr(&quot;src&quot;, &quot;/thumbnail.cgi?&quot; + file[&quot;r_uri&quot;] + &#39;/&#39; + file[&quot;fname&quot;]); } else { img.attr(&quot;src&quot;, &quot;/SD_WLAN/img/other.png&quot;); } filelink.addClass(&quot;file&quot;).attr(&quot;target&quot;,&quot;_blank&quot;); } // Append a file entry or directory to the end of the list. $(&quot;#list&quot;).append( fileobj.append( filelink.append( img ).append( caption ) ) ); }); } //Document Ready $(function() { if ( isV1(wlansd) ) { convertFileList(wlansd); } wlansd.sort(cmptime); showFileList(location.pathname); }); 実行結果 FlashAirに無線LAN接続したPCまたはスマートフォンのブラウザで確認してみましょう。 左はPCの画面です。サムネイル画像が画面に大きく表示されています。角も丸くなっています。 右はスマートフォンです。サムネイルが一列になり、メニューはアイコンに変わりました。 アイコンをタップすると、メニューの一覧が表示されます。 もっと 今回のような単純なタイル表示ではなく、コラージュ風に表示してもよいでしょう。 JavaScriptを駆使して、画像処理を行ったりすることもできるかもしれません。 皆さんのアイデアとテクニックで、様々なユーティリティを作ってみましょう。 サンプルコード web_tutorial_07.zip (5KB) このサイトのサンプルコードは二条項BSDライセンスで提供されています。",
    "url": "http://localhost:4000/docs/tutorials/web/7.html",
    "relUrl": "/docs/tutorials/web/7.html"
  },
  "48": {
    "id": "48",
    "title": "無線LAN設定",
    "content": "無線LAN設定 このチュートリアルでは、ネットワークのスキャン、接続、ファイルアップロードまで、LUAから無線LANデバイスを扱う基本的な操作をみていきます。 はじめに FlashAirにOAUTH2を使ったDropboxへのアップロードで作成したDropboxUpload.luaが無い場合は、サンプルコードよりファイルをダウンロードしてください。 アップロード機能を有効にするために、CONFIGファイルにUPLOAD=1を追加します。 FlashAirでLuaを実行するを参考に、Luaスクリプト実行方法をCONFIGファイルに指定します。 スキャン まず、スキャンして取得したローカルネットワークのリストを、ログファイルに記録してみましょう。このスクリプトは、FlashAir起動時に実行するのが良いでしょう。FlashAirが既にネットワークに接続している場合、fa.Scan及びfa.GetScanInfoは利用できないのでご注意ください。 /SSIDList.lua --[[ This script will scan for available WiFi networks, and output their SSIDs to a file. ]]-- local logfile = &quot;ssidList.txt&quot; count = fa.Scan() -- Open the log file local outfile = io.open(logfile, &quot;w&quot;) -- Write a header outfile:write(&quot;SSID list: n&quot;) --Note that the ssids start at 0, and go to (count-1) for i=0, (count-1), 1 do ssid, other = fa.GetScanInfo(i) outfile:write(i..&quot;: &quot;..ssid..&quot; n&quot;) end Luaスクリプト実行後、ルートフォルダにssidList.txtが表示されます。 接続 次に、特定のSSIDをスキャンし、接続してみましょう。接続すると、アップロードするためのスクリプトを実行します。アップロードには、Dropboxチュートリアルで作成したスクリプトを利用します。 /WifiConnect.lua --[[ This script will scan for a specific network, and if it sees it will connect... then trigger a dropbox uploading script! It logs to a file. ]]-- local logfile = &quot;wifiConnect.txt&quot; local SSID = &quot;VITP_Open&quot; -- SSID to connect to local PASSWORD = &quot;&quot; --A blank password should be used for an open network local uploader = &quot;DropboxUpload.lua&quot; -- Open the log file local outfile = io.open(logfile, &quot;w&quot;) while true do -- Initiate a scan count = fa.Scan(SSID) --count = fa.Scan() found=0 --See if we found it if count &gt; 0 then --ssid, other = fa.GetScanInfo(0) --Should return SSID provided for i=0, (count-1), 1 do found_ssid, other = fa.GetScanInfo(i) print(SSID..&quot;|&quot;..found_ssid) if SSID == found_ssid then --We did! print(&quot;Found: &quot;..SSID..&quot;... attempting to connect.&quot;) outfile:write(&quot;Found: &quot;..SSID..&quot;... attempting to connect.&quot;) found=1 break end end end if found == 1 then break end --If we found it, stop looping end --We should only get here if the above loop found the network --fa.Connect has no return, but if the SSID and password are correct it should work. fa.Connect(SSID, PASSWORD) --Execute the upload script dofile(uploader) --Close our log file outfile:close() Luaスクリプト実行後、ルートフォルダにwifiConnect.txtが表示されます。 サンプルコード リポジトリを見る（GitHub） このサイトのサンプルコードは二条項BSDライセンスで提供されています。",
    "url": "http://localhost:4000/docs/tutorials/lua/7.html",
    "relUrl": "/docs/tutorials/lua/7.html"
  },
  "49": {
    "id": "49",
    "title": "FlashAirへのアップロード",
    "content": "FlashAirへのアップロード このチュートリアルでは upload.cgiを使用して、CGI経由でFlashAirにファイルをアップロード（書き込み）する方法について学びます。 使用するCGIは upload.cgi です。 このチュートリアルは別項の Android Tutorial 4: サムネイルの表示 に基づいています。 概要 FlashAirに保存されている画像を、日付別にタイトル＆メモをつけて管理できるようにします。 注意: 本機能を誤って使用すると、FlashAirのファイルシステムを破壊してデータを失う恐れがあります。PCなどのSDメモリカードホスト機器はSDメモリカードの内容(FAT)をキャッシュしている場合がありますが、本CGIで行った変更をSDメモリカードホスト機器が認識する方法がありません。そのため、本CGIとSDメモリカードホスト機器から同時に変更を行うとFAT不整合が起こる可能性があります。 CGIからの書き込み後は必ずカードをいったん抜いて再挿入するなどしてSDメモリカードホスト機器に再認識させてください。 コンテンツのリストに Date List ボタンを配置します。 Date List ボタンをタップすると日付別のリストが表示されます。 日付をタップするとその日付の操作画面が表示されます。 アプリケーションを作成するにあたって、次のファイルを作成します。 MainActivity.java activity_main.xml ImageViewActivity.java activity_image_view.xml DateListActivity.java activity_date_list.xml list_view_item.xml MemoEditActivity.java activity_memo_edit.xml grid_view_item.xml FlashAirRequest.java 重要: Android application は、デフォルトの状態ではインターネットにアクセスすることができません。 そのため、設定ファイル AndroidManifest.xml を変更し、権限を与える必要があります。 パス: [Project_Folder]/AndroidManifest.xml AndroidManifest.xml に以下のコードを追加してください。 &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt; 画面レイアウトの作成 strings.xml修正 strings.xmlは以下のように記述してください。 このファイルは、values フォルダに配置されています。 パス: [Project_Folder]/res/values/strings.xml &lt;string name=&quot;app_name&quot;&gt;android_tutorial_07&lt;/string&gt; &lt;string name=&quot;action_settings&quot;&gt;Settings&lt;/string&gt; &lt;string name=&quot;title_activity_image_view&quot;&gt;ImageViewActivity&lt;/string&gt; &lt;string name=&quot;date_list&quot;&gt;Date List&lt;/string&gt; &lt;string name=&quot;back&quot;&gt;Back&lt;/string&gt; &lt;string name=&quot;directory_name&quot;&gt;Directory Name&lt;/string&gt; &lt;string name=&quot;view_image&quot;&gt;view image&lt;/string&gt; &lt;string name=&quot;image_would_be_here&quot;&gt;image would be here&lt;/string&gt; &lt;string name=&quot;date&quot;&gt;Date&lt;/string&gt; &lt;string name=&quot;title&quot;&gt;Title&lt;/string&gt; &lt;string name=&quot;title_&quot;&gt;Title:&lt;/string&gt; &lt;string name=&quot;memo&quot;&gt;Memo&lt;/string&gt; &lt;string name=&quot;memo_&quot;&gt;Memo:&lt;/string&gt; &lt;string name=&quot;save&quot;&gt;Save&lt;/string&gt; &lt;string name=&quot;grid_view_image&quot;&gt;grid_view_image&lt;/string&gt; コンテンツリストのレイアウト作成 activity_main.xml を記述して、レイアウトを決定します。 このファイルは、layout フォルダに配置されています。 パス: [Project_Folder]/res/layout/activity_main.xml activity_main.xml は Android Tutorial 3: コンテンツのダウンロードと同じ状態のレイアウトにボタンを１つ追加します。 activity_main.xml に以下の内容を追加してください。 activity_main.xml &lt;Button android:id=&quot;@+id/button2&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:cacheColorHint=&quot;#00000000&quot; android:text=&quot;@string/date_list&quot; android:textColor=&quot;@android:color/white&quot; android:textSize=&quot;20sp&quot; /&gt; イメージビューのレイアウト作成 次に、 activity_image_view.xml を記述して、レイアウトを決定します。 このファイルは、layout フォルダに配置されています。 パス: [Project_Folder]/res/layout/activity_image_view.xml activity_image_view.xml は Android Tutorial 3: コンテンツのダウンロードと同じになります。 実装の説明についてはそちらを参照してください。 日付一覧のレイアウト作成 次に、 activity_date_list.xml と list_view_item.xml を記述して、レイアウトを決定します。 list_view_item.xml は、リストの1行分のレイアウトです。 これらのファイルは、layout フォルダに配置されています。 パス: [Project_Folder]/res/layout/activity_date_list.xml [Project_Folder]/res/layout/list_view_item.xml activity_date_list.xml に以下のように記述してください。 activity_date_list.xml &lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;fill_parent&quot; android:layout_height=&quot;match_parent&quot; android:gravity=&quot;center_horizontal&quot; android:orientation=&quot;vertical&quot; tools:context=&quot;.DateListActivity&quot; &gt; &lt;Button android:id=&quot;@+id/button1&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:cacheColorHint=&quot;#00000000&quot; android:text=&quot;@string/back&quot; android:textColor=&quot;@android:color/white&quot; android:textSize=&quot;20sp&quot; /&gt; &lt;TextView android:id=&quot;@+id/textView1&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:gravity=&quot;center_horizontal&quot; android:scaleType=&quot;centerInside&quot; android:text=&quot;@string/directory_name&quot; android:textAlignment=&quot;center&quot; android:textAppearance=&quot;?android:attr/textAppearanceLarge&quot; /&gt; &lt;ListView android:id=&quot;@+id/listView1&quot; android:layout_width=&quot;fill_parent&quot; android:layout_height=&quot;match_parent&quot; android:cacheColorHint=&quot;#00000000&quot; android:clickable=&quot;true&quot; android:headerDividersEnabled=&quot;false&quot; /&gt; &lt;/LinearLayout&gt; list_view_item.xml に以下のように記述してください。 list_view_item.xml &lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot;&gt; &lt;TextView android:id=&quot;@+id/textView1&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;@string/date&quot; /&gt; &lt;TextView android:id=&quot;@+id/textView2&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;@string/title&quot; /&gt; &lt;/LinearLayout&gt; 操作画面のレイアウト作成 次に、 activity_memo_edit.xml と grid_view_item.xml を記述して、レイアウトを決定します。 grid_view_item.xml は、サムネイルの表示に使用します。 これらのファイルは、layout フォルダに配置されています。 パス: [Project_Folder]/res/layout/activity_memo_edit.xml [Project_Folder]/res/layout/grid_view_item.xml activity_memo_edit.xml に以下のように記述してください。 activity_memo_edit.xml &lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;fill_parent&quot; android:layout_height=&quot;match_parent&quot; android:gravity=&quot;center_horizontal&quot; android:orientation=&quot;vertical&quot; tools:context=&quot;.MemoEditActivity&quot; &gt; &lt;Button android:id=&quot;@+id/button1&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:cacheColorHint=&quot;#00000000&quot; android:text=&quot;@string/back&quot; android:textColor=&quot;@android:color/white&quot; android:textSize=&quot;20sp&quot; /&gt; &lt;TextView android:id=&quot;@+id/textView1&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:gravity=&quot;center_horizontal&quot; android:scaleType=&quot;centerInside&quot; android:text=&quot;@string/directory_name&quot; android:textAlignment=&quot;center&quot; android:textAppearance=&quot;?android:attr/textAppearanceLarge&quot; /&gt; &lt;TextView android:id=&quot;@+id/textView2&quot; android:layout_width=&quot;152dp&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginTop=&quot;12dp&quot; android:gravity=&quot;center&quot; android:hint=&quot;@string/date&quot; android:paddingLeft=&quot;10dp&quot; android:textSize=&quot;18sp&quot; /&gt; &lt;GridView android:id=&quot;@+id/gridView1&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;0dp&quot; android:layout_weight=&quot;0.01&quot; android:horizontalSpacing=&quot;10dp&quot; android:numColumns=&quot;5&quot; android:verticalSpacing=&quot;10dp&quot; &gt; &lt;/GridView&gt; &lt;TextView android:id=&quot;@+id/TextView01&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_gravity=&quot;left&quot; android:layout_marginTop=&quot;12dp&quot; android:paddingLeft=&quot;10dp&quot; android:text=&quot;@string/title_&quot; android:textSize=&quot;18sp&quot; /&gt; &lt;EditText android:id=&quot;@+id/editTitle&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:ems=&quot;10&quot; android:hint=&quot;@string/title&quot; android:inputType=&quot;text&quot; android:textStyle=&quot;italic&quot; &gt; &lt;/EditText&gt; &lt;TextView android:id=&quot;@+id/TextView02&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_gravity=&quot;left&quot; android:layout_marginTop=&quot;20dp&quot; android:paddingLeft=&quot;10dp&quot; android:text=&quot;@string/memo_&quot; android:textSize=&quot;18sp&quot; /&gt; &lt;EditText android:id=&quot;@+id/editMemo&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:ems=&quot;10&quot; android:hint=&quot;@string/memo&quot; android:inputType=&quot;text&quot; android:textStyle=&quot;italic&quot; /&gt; &lt;Button android:id=&quot;@+id/button2&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginTop=&quot;12dp&quot; android:cacheColorHint=&quot;#00000000&quot; android:text=&quot;@string/save&quot; android:textColor=&quot;@android:color/white&quot; android:textSize=&quot;20sp&quot; /&gt; &lt;/LinearLayout&gt; grid_view_item.xml に以下のように記述してください。 grid_view_item.xml &lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;ImageView android:id=&quot;@+id/imageView1&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:contentDescription=&quot;@string/grid_view_image&quot; /&gt; &lt;/LinearLayout&gt; コードの作成 コンテンツリストの作成 さて、 MainActivity.java を修正します。 Android Tutorial 4: サムネイルの表示の状態に、Date List ボタンをタップした際の処理を追加します。 またここでは画像ファイルのみを対象とするので、絞り込み条件の追加等も行います。 初期化 Android Tutorial 4: サムネイルの表示 の MainActivity.java をコピーし、それを新しい MainActivity.java として使用してください。 メンバ変数の追加と onCreate(Bundle savedInstanceState) 関数を下記のように置き換えます。 MainActivity.java (1) public class MainActivity extends Activity implements AdapterView.OnItemClickListener { ListView listView; ImageView imageView; TextView currentDirText; TextView numFilesText; Button backButton; Button datelistButton; String rootDir = &quot;DCIM&quot;; String directoryName = rootDir; // Initialize to rootDirectory SimpleAdapter listAdapter; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); try { // Set buttons backButton = (Button)findViewById(R.id.button1); getWindow().setTitleColor(Color.rgb(65, 183, 216)); backButton.getBackground().setColorFilter(Color.rgb(65, 183, 216), PorterDuff.Mode.SRC_IN); backButton.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { if(directoryName.equals(rootDir)) { listRootDirectory(); } else { int index = directoryName.lastIndexOf(&quot;/&quot;); directoryName = directoryName.substring(0, index); listDirectory(directoryName); } } }); backButton.setEnabled(false); // Disable in root directory datelistButton = (Button)findViewById(R.id.button2); getWindow().setTitleColor(Color.rgb(65, 183, 216)); datelistButton.getBackground().setColorFilter(Color.rgb(65, 183, 216), PorterDuff.Mode.SRC_IN); datelistButton.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { Intent dateList = new Intent(getBaseContext(), DateListActivity.class); dateList.putExtra(&quot;dir&quot;, currentDirText.getText()); MainActivity.this.startActivity(dateList); } }); listRootDirectory(); } catch(Exception e) { Log.e(&quot;ERROR&quot;, &quot;ERROR: &quot; + e.toString()); e.printStackTrace(); } } 作成済みの MainActivity に Date List ボタンのためのコードを追加します。 38-49行目 Date List ボタンをタップした際、日付一覧画面へ遷移するように設定しています。 残りの MainActivity.java はそのまま使用します。 対象ファイルの絞り込み 今回は画像ファイルのみを対象としたいので、 listDirectory() 内のファイル名を取得する部分で以下のように条件を追加します。 MainActivity.java (2) if( (allFiles[i].toString().toLowerCase(Locale.getDefault()).endsWith(&quot;.jpg&quot;)) || (allFiles[i].toString().toLowerCase(Locale.getDefault()).endsWith(&quot;.jpeg&quot;)) || (allFiles[i].toString().toLowerCase(Locale.getDefault()).endsWith(&quot;.jpe&quot;)) || (allFiles[i].toString().toLowerCase(Locale.getDefault()).endsWith(&quot;.png&quot;)) ) { // Image file fileNames.add(allFiles[i]); } 再表示時の設定 次の画面から戻ってきた場合など、画面が再表示された際にもリストが更新されるように設定しておきます。 MainActivity.java (3) @Override public void onRestart(){ super.onRestart(); listDirectory(directoryName); } 画像表示画面の作成 class ImageViewActivity は Android Tutorial 3: コンテンツのダウンロードと同じです。 実装の詳細についてはこのチュートリアルを参照してください。 日付一覧の作成 初期化 リストの項目をクリックした場合の処理を記述するため、クラス宣言にOnClickListenerを追加します。 DateListActivity.java (1) public class DateListActivity extends Activity implements AdapterView.OnItemClickListener { ビューの宣言、その他のクラス変数の宣言や画面の初期設定を行います。 また、 onCreate(Bundle savedInstanceState) をオーバーライドし、アクティビティクラスの初期化も行います。 リストの初期設定や一つ前の画面へ戻るための Buttonのクリックリスナーも設定します。 DateListActivity.java (2) ListView listView; ImageView imageView; TextView currentDirText; Button backButton; String rootDir = &quot;DCIM&quot;; String directoryName; SimpleAdapter listAdapter; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_date_list); try { Bundle extrasData = getIntent().getExtras(); directoryName = extrasData.getString(&quot;dir&quot;); if(!directoryName.equals(rootDir)) { int index = directoryName.lastIndexOf(&quot;/&quot;); directoryName = directoryName.substring(0, index); } // Set buttons backButton = (Button)findViewById(R.id.button1); getWindow().setTitleColor(Color.rgb(65, 183, 216)); backButton.getBackground().setColorFilter(Color.rgb(65, 183, 216), PorterDuff.Mode.SRC_IN); backButton.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { DateListActivity.this.finish(); // Go back to Get screen } }); listDirectory(directoryName); } catch(Exception e) { Log.e(&quot;ERROR&quot;, &quot;ERROR: &quot; + e.toString()); e.printStackTrace(); } } 22-31行目 ユーザーがButton をクリックした際、一つ前の画面へ戻るように設定しています。 リストの作成 基本的には command.cgiを使用して、コンテンツリストを取得するのと同様の処理になります。 ファイル名に変わり、日付を重複しないように取得しています。 DateListActivity.java (3) public void listRootDirectory() { directoryName = rootDir; listDirectory(directoryName); } public void listDirectory(String dir) { // Prepare command directory path currentDirText = (TextView)findViewById(R.id.textView1); currentDirText.setText(dir + &quot;/&quot;); // Fetch list of items in directory and display in a ListView new AsyncTask&lt;String, Void, ListAdapter&gt;(){ @Override protected ListAdapter doInBackground(String... params) { String dir = params[0]; String cmddir = &quot;/&quot; + dir; ArrayList &lt;NameValuePair&gt; httpParams = new ArrayList &lt;NameValuePair&gt; (); httpParams.add(new BasicNameValuePair(&quot;DIR&quot;, cmddir)); cmddir = URLEncodedUtils.format (httpParams, &quot;UTF-8&quot; ); Set &lt;Integer&gt; dates = new HashSet &lt;Integer&gt;(); String files = FlashAirRequest .getString(&quot;http://flashair/command.cgi?op=100&amp;&quot; + cmddir); String[] allFiles = files.split(&quot;([, n])&quot;); // split by newline or comma for(int i = 2; i &lt; allFiles.length; i= i + 6) { if(allFiles[i].contains(&quot;.&quot;)) { if( (allFiles[i].toString().toLowerCase(Locale.getDefault()).endsWith(&quot;.jpg&quot;)) || (allFiles[i].toString().toLowerCase(Locale.getDefault()).endsWith(&quot;.jpeg&quot;)) || (allFiles[i].toString().toLowerCase(Locale.getDefault()).endsWith(&quot;.jpe&quot;)) || (allFiles[i].toString().toLowerCase(Locale.getDefault()).endsWith(&quot;.png&quot;))){ // Image file Integer date = Integer.parseInt(allFiles[i+3]); dates.add(date); } } } // Get Title ArrayList&lt;Map&lt;String, Object&gt;&gt; data = new ArrayList&lt;Map&lt;String, Object&gt;&gt;(); for (Integer date : dates) { Map&lt;String, Object&gt; entry = new HashMap&lt;String, Object&gt;(); String dataStr = FlashAirRequest.getString(&quot;http://flashair/&quot; + dir + &quot;/&quot; + getDate(date, &quot;&quot;) + &quot;.txt&quot;); String[] dataStrAry = dataStr.split(&quot;([ n])&quot;); // split by newline or comma entry.put(&quot;date&quot;, getDate(date, &quot;/&quot;)); if (dataStrAry.length &gt;= 2) { entry.put(&quot;title&quot;, dataStrAry[0]); } data.add(entry); } // Set the file list to a widget listAdapter = new SimpleAdapter(DateListActivity.this, data, R.layout.list_view_item, new String[]{&quot;date&quot;, &quot;title&quot;}, new int[]{R.id.textView1, R.id.textView2}); return listAdapter; } @Override protected void onPostExecute(ListAdapter listAdapter) { listView = (ListView)findViewById(R.id.listView1); ColorDrawable divcolor = new ColorDrawable(Color.rgb(17, 19, 58)); listView.setDivider(divcolor); listView.setDividerHeight(1); listView.setAdapter(listAdapter); listView.setOnItemClickListener(DateListActivity.this); } }.execute(dir); 22-37行目 各ファイルの日付を取得しています。 40-51行目 取得した日付をもとにパスを作成し、ファイルをダウンロードします。 タイトルは、 YYYYMMDD.txt という形式で画像と同じフォルダに保存され、このファイルには1行目にタイトル、2行目にメモの情報が保存されています。 getDate() は、command.cgi のop=100 で返却された日付形式(16ビット整数を10進数表記)から、ファイル名用の日付文字列(YYYYMMDD)を生成する関数です。 54-58行目 レイアウトに作成済みの list_view_item.xml を設定し、取得した日付、タイトル、メモも設定しています。 これらは、64行目でListView にバインドされます。 63-68行目 ListViewを作成しています。 作成済みのlistAdapter 設定が設定され、日付とタイトルが view にバインドされています。 作成したViewをレイアウトに設定しています。 クリックリスナーの設定 Android Tutorial 4: サムネイルの表示 と同様の設定を行います。 日付をクリックした場合に、選択した日付の操作画面を表示します。 DateListActivity.java (4) @Override public void onItemClick(AdapterView&lt;?&gt; l, View v, int position, long id) { Object item = l.getItemAtPosition(position); if(item instanceof Map&lt;?, ?&gt;) { Map&lt;String, Object&gt; mapItem = (Map&lt;String, Object&gt;) item; Object selectDate = mapItem.get(&quot;date&quot;); // Next button to start new intent to allow day detail Intent memoEdit = new Intent(getBaseContext(), MemoEditActivity.class); memoEdit.putExtra(&quot;date&quot;, selectDate.toString()); memoEdit.putExtra(&quot;dir&quot;, directoryName); DateListActivity.this.startActivity(memoEdit); } } 4-6行目 Map オブジェクトを使用して、ListView で選択された日付を取得しています。 再表示時の設定 次の画面から戻ってきた場合など、画面が再表示された際にもリストが更新されるように設定しておきます。 DateListActivity.java (5) @Override public void onRestart(){ super.onRestart(); listDirectory(directoryName); } ファイル名用日付文字列の取得 前述した、16ビット整数を10進数表記の日付形式から、ファイル名用の文字列(YYYYMMDD)を生成する関数です。 DateListActivity.java (6) public String getDate(Integer date, String sep) { return String.format(&quot;%04d&quot;, ((date &gt;&gt; 9) &amp; 0x1FF)+1980)+sep+ String.format(&quot;%02d&quot;, (date &gt;&gt; 5) &amp; 0xF)+sep+ String.format(&quot;%02d&quot;, date &amp; 0x1F); } } // End DateListActivity class 操作画面の作成 初期化 ビューの宣言、その他のクラス変数の宣言や画面の初期設定を行います。 また、 onCreate(Bundle savedInstanceState) をオーバーライドし、アクティビティクラスの初期化も行います。 リストの初期設定や Button のクリックリスナーも設定します。 MemoEditActivity.java (1) public class MemoEditActivity extends Activity { TextView dateText; TextView currentDirText; Button backButton; Button saveButton; EditText titleField; EditText memoField; GridView gridView; String newTitle = &quot;&quot;; String newMemo = &quot;&quot;; String date; String rootDir = &quot;DCIM&quot;; String directoryName; ArrayList&lt;String&gt; fileNamelist; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_memo_edit); Bundle extrasData = getIntent().getExtras(); date = extrasData.getString(&quot;date&quot;); directoryName = extrasData.getString(&quot;dir&quot;); getWindow().setTitleColor(Color.rgb(65, 183, 216)); // Set backButton backButton = (Button) findViewById(R.id.button1); backButton.getBackground().setColorFilter(Color.rgb(65, 183, 216), PorterDuff.Mode.SRC_IN); backButton.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { MemoEditActivity.this.finish(); // Go back } }); // Set saveButton saveButton = (Button) findViewById(R.id.button2); saveButton.getBackground().setColorFilter(Color.rgb(65, 183, 216), PorterDuff.Mode.SRC_IN); saveButton.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { getInput(); saveNewTitleMemo(); } }); // Set titleField and memoField titleField = (EditText) findViewById(R.id.editTitle); titleField.setHintTextColor(Color.rgb(65, 183, 216)); memoField = (EditText) findViewById(R.id.editMemo); memoField.setHintTextColor(Color.rgb(65, 183, 216)); // Set dateText dateText = (TextView) findViewById(R.id.textView2); dateText.setText(date); // Get title and memo new AsyncTask&lt;String, Void, ArrayList&lt;String&gt;&gt;() { @Override protected ArrayList&lt;String&gt; doInBackground(String... params) { String dir = params[0]; ArrayList&lt;String&gt; rtnAry = new ArrayList&lt;String&gt;(); String files = FlashAirRequest.getString(&quot;http://flashair/&quot; + dir + &quot;/&quot; + date.replaceAll(&quot;/&quot;, &quot;&quot;) + &quot;.txt&quot;); String[] allFiles = files.split(&quot;([ n])&quot;); // split by newline or comma if (allFiles.length &gt;= 2) { // File rtnAry.add(allFiles[0]); rtnAry.add(allFiles[1]); } return rtnAry; } @Override protected void onPostExecute(ArrayList&lt;String&gt; strary) { // Set the data to a TextView titleField = (EditText) findViewById(R.id.editTitle); memoField = (EditText) findViewById(R.id.editMemo); if (strary.size() &gt; 0) { titleField.setText(strary.get(0)); memoField.setText(strary.get(1)); } else { titleField.setText(&quot;&quot;); memoField.setText(&quot;&quot;); } } }.execute(directoryName); // Set gridView gridView = (GridView) findViewById(R.id.gridView1); gridView.setOnItemClickListener(new OnItemClickListener() { public void onItemClick(AdapterView&lt;?&gt; parent, View v, int position, long id) { Object item = parent.getItemAtPosition(position); if (item instanceof Map&lt;?, ?&gt;) { Map&lt;String, Object&gt; mapItem = (Map&lt;String, Object&gt;) item; Object downloadFile = mapItem.get(&quot;fname&quot;); if ((downloadFile.toString().toLowerCase(Locale.getDefault()).endsWith(&quot;.jpg&quot;)) || (downloadFile.toString().toLowerCase(Locale.getDefault()).endsWith(&quot;.jpeg&quot;)) || (downloadFile.toString().toLowerCase(Locale.getDefault()).endsWith(&quot;.jpe&quot;)) || (downloadFile.toString().toLowerCase(Locale.getDefault()).endsWith(&quot;.png&quot;))) { // Image file, download using ImageViewActivity Intent viewImageIntent = new Intent(MemoEditActivity.this, ImageViewActivity.class); viewImageIntent.putExtra(&quot;downloadFile&quot;,downloadFile.toString()); viewImageIntent.putExtra(&quot;directoryName&quot;, directoryName); MemoEditActivity.this.startActivity(viewImageIntent); } // Not an image file, do nothing } } }); listDirectory(directoryName); } 37-45行目 save ボタン をタップした際、保存処理が実行されるように設定しています。 58-88行目 前画面で選択された日付の、タイトル&amp;メモを取得し画面に設定しています。 91-113行目 ファイルをダウンロードし、ダウンロードした画像を表示しした画面を表示します。 サムネイル表示 基本的には今まで行ってきたサムネイルの取得方法と同様になります。 ここでは、 ListView ではなく、 GridView を使用してサムネイルを表示しています。 MemoEditActivity.java (2) public void listDirectory(String dir) { // Prepare command directory path currentDirText = (TextView)findViewById(R.id.textView1); currentDirText.setText(dir + &quot;/&quot;); final ProgressDialog waitDialog; // Setting ProgressDialog waitDialog = new ProgressDialog(this); waitDialog.setMessage(&quot;Now downloading...&quot;); waitDialog.setProgressStyle(ProgressDialog.STYLE_SPINNER); waitDialog.show(); ArrayList&lt;NameValuePair&gt; httpParams = new ArrayList&lt;NameValuePair&gt;(); httpParams.add(new BasicNameValuePair(&quot;DIR&quot;, dir)); dir = URLEncodedUtils.format(httpParams, &quot;UTF-8&quot;); // Fetch list of items in directory and display in a ListView new AsyncTask&lt;String, Void, ListAdapter&gt;() { @Override protected ListAdapter doInBackground(String... params) { String dir = params[0]; ArrayList&lt;String&gt; fileNames = new ArrayList&lt;String&gt;(); fileNamelist = new ArrayList&lt;String&gt;(); String files = FlashAirRequest .getString(&quot;http://flashair/command.cgi?op=100&amp;&quot; + dir); String[] allFiles = files.split(&quot;([, n])&quot;); // split by newline　or comma for (int i = 2; i &lt; allFiles.length; i = i + 6) { if (allFiles[i].contains(&quot;.&quot;) &amp;&amp; allFiles[i+3].contains(getDate16(date))) { if( (allFiles[i].toString().toLowerCase(Locale.getDefault()).endsWith(&quot;.jpg&quot;)) || (allFiles[i].toString().toLowerCase(Locale.getDefault()).endsWith(&quot;.jpeg&quot;)) || (allFiles[i].toString().toLowerCase(Locale.getDefault()).endsWith(&quot;.jpe&quot;)) || (allFiles[i].toString().toLowerCase(Locale.getDefault()).endsWith(&quot;.png&quot;))){ // Image file fileNames.add(allFiles[i]); } } } // Get thumbnails ArrayList&lt;Map&lt;String, Object&gt;&gt; data = new ArrayList&lt;Map&lt;String, Object&gt;&gt;(); for (int i = 0; i &lt; fileNames.size(); i++) { String url = &quot;&quot;; url = &quot;http://flashair/thumbnail.cgi?&quot; + directoryName + &quot;/&quot; + fileNames.get(i); Map&lt;String, Object&gt; entry = new HashMap&lt;String, Object&gt;(); Bitmap thumbnail = null; BitmapDrawable drawnIcon = null; if ((url.toLowerCase(Locale.getDefault()).endsWith(&quot;.jpg&quot;)) || (url.toLowerCase(Locale.getDefault()).endsWith(&quot;.jpeg&quot;))) { thumbnail = FlashAirRequest.getBitmap(url); drawnIcon = new BitmapDrawable(getResources(), thumbnail); } if(thumbnail == null) { entry.put(&quot;thmb&quot;, R.drawable.ic_launcher); } else { entry.put(&quot;thmb&quot;, drawnIcon); } entry.put(&quot;fname&quot;, fileNames.get(i)); // Put file name onto the map data.add(entry); } // Set the file list to a widget SimpleAdapter listAdapter = new SimpleAdapter( MemoEditActivity.this, data, R.layout.grid_view_item, new String[] { &quot;thmb&quot;, &quot;fname&quot; }, new int[] {R.id.imageView1, android.R.id.text1 }); listAdapter.setViewBinder(new CustomViewBinder()); return listAdapter; } @Override protected void onPostExecute(ListAdapter adapter) { waitDialog.dismiss(); gridView.setAdapter(adapter); } }.execute(dir); } 20-36行目 対象となっている日付のファイル名を取得しています。 getDate16() は、対象となっている日付文字列(YYYY/MM/DD)から、16ビット整数を10進数表記した日付形式の日付文字列を生成する関数です。 62-66行目 レイアウトに作成済みの grid_view_item.xml を設定し、取得したサムネイルとファイル名も設定しています。 これらは、68行目でGridView にバインドされます。 72-75行目 日付とタイトルとメモが view にバインドされています。 作成したViewをレイアウトに設定しています。 ViewBinderの作成 カスタムの ViewBinder を作成します。 GridView を使用してサムネイルを表示するのに使用します。 MemoEditActivity.java (3) class CustomViewBinder implements ViewBinder { @Override public boolean setViewValue(View view, Object obj, String text) { if((view instanceof ImageView) &amp;&amp; (obj instanceof Drawable)) { ImageView imageView = (ImageView) view; BitmapDrawable thumbnail = (BitmapDrawable) obj; imageView.setImageDrawable((Drawable)thumbnail); return true; } return false; } } アップロード タイトル&amp;メモを保存するために、以下のコマンドを使用します。 アップロードは、upload.cgi を使用して以下の手順で行います。 CONFIGファイルに、UPLOAD=1を書き込む FlashAirを再起動する FlashAirに無線LAN接続する WRITEPROTECTコマンドで、SDメモリカードホスト機器からの書き込みを禁止する UPDIRコマンドで、アップロード先フォルダを設定する FTIMEコマンドで、ファイルの作成日時を設定する upload.cgiにファイルをPOSTし、ファイルをアップロードする upload.cgi をPOSTする upload() を前項 Android Tutorial 3: コンテンツのダウンロード で作成した FlashAirRequest.java に追加します。 FlashAirRequest.java static public String upload(String command, String filename, String saveString) { String result = &quot;&quot;; final String boundary = &quot;========================&quot;; try { URL url = new URL(command); HttpURLConnection httpUrlCon = (HttpURLConnection)url.openConnection(); httpUrlCon.setDoInput(true); httpUrlCon.setDoOutput(true); httpUrlCon.setUseCaches(false); httpUrlCon.setRequestMethod(&quot;POST&quot;); httpUrlCon.setRequestProperty(&quot;Charset&quot;, &quot;UTF-8&quot;); httpUrlCon.setRequestProperty(&quot;Content-Type&quot;, &quot;multipart/form-data;boundary=&quot;+ boundary); DataOutputStream ds = new DataOutputStream(httpUrlCon.getOutputStream()); ds.writeBytes(&quot;--&quot; + boundary + &quot; r n&quot;); ds.writeBytes(&quot;Content-Disposition: form-data; name= &quot;upload.cgi &quot;; filename= &quot;&quot; + filename +&quot; &quot;&quot;+&quot; r n&quot;); ds.writeBytes( &quot; r n&quot; ); ds.write(saveString.getBytes(&quot;UTF-8&quot;)); ds.writeBytes( &quot; r n&quot; ); ds.writeBytes(&quot;--&quot; + boundary + &quot;--&quot; + &quot; r n&quot;); ds.flush(); ds.close(); if(httpUrlCon.getResponseCode() == HttpURLConnection.HTTP_OK){ StringBuffer sb = new StringBuffer(); InputStream is = httpUrlCon.getInputStream(); byte[] data = new byte[1024]; int leng = -1; while((leng = is.read(data)) != -1) { sb.append(new String(data, 0, leng)); } result = sb.toString(); } } catch (MalformedURLException e) { Log.e(&quot;ERROR&quot;, &quot;ERROR: &quot; + e.toString()); e.printStackTrace(); } catch (IOException e) { Log.e(&quot;ERROR&quot;, &quot;ERROR: &quot; + e.toString()); e.printStackTrace(); } return result; } 12-13行目 multipartform-data形式を指定しています。 MemoEditActivity.java (4) public void saveNewTitleMemo() { new AsyncTask&lt;String, Void, String&gt;(){ @Override protected String doInBackground(String... params) { String parameter = &quot;?WRITEPROTECT=ON&amp;UPDIR=/&quot; + rootDir; parameter = parameter + &quot;&amp;FTIME=&quot; + getDateTime16(); String filename = date.replaceAll(&quot;/&quot;, &quot;&quot;) + &quot;.txt&quot;; String rtnStr = &quot;&quot;; rtnStr = FlashAirRequest.getString(params[0] + parameter); if(rtnStr.toUpperCase(Locale.getDefault()).equals(&quot;SUCCESS&quot;)) { rtnStr = FlashAirRequest .upload( params[0], filename, newTitle + &quot; n&quot; + newMemo); } return rtnStr; } @Override protected void onPostExecute(String result) { if(result.toUpperCase(Locale.getDefault()).indexOf(&quot;SUCCESS&quot;) &gt;= 0) { Toast.makeText(MemoEditActivity.this, &quot;Save Completed.&quot;, Toast.LENGTH_LONG).show(); } } }.execute(&quot;http://flashair/upload.cgi&quot;); } 5-9行目 手順の4-6を実行しています。 getDateTime16() は、現在の日付からファイルの作成日時を指定するための日付文字列を生成する関数です。 日付、時刻をそれぞれ16ビットの16進数として作成し、合わせて32ビットの1つの値として渡しています。 11-12行目 作成したupload() を使用して、タイトル&amp;メモをアップロードしています。 ファイル作成日時用の日付文字列の取得 前述した、現在の日付からファイルの作成日時用の日付文字列を生成する関数です。 MemoEditActivity.java (5) public String getDateTime16() { Calendar calendar = Calendar.getInstance(); int year = (calendar.get(Calendar.YEAR) - 1980) &lt;&lt; 9; int month = (calendar.get(Calendar.MONTH) + 1) &lt;&lt; 5; int day = calendar.get(Calendar.DAY_OF_MONTH); int hours = calendar.get(Calendar.HOUR_OF_DAY) &lt;&lt; 11; int minites = calendar.get(Calendar.MINUTE) &lt;&lt; 5; int seconds = calendar.get(Calendar.SECOND) / 2; String rtnStr = &quot;0x&quot; + Integer.toHexString(year + month + day) + Integer.toHexString(hours + minites + seconds); return rtnStr; } ファイル名用日付文字列の取得 対象となっている日付文字列(YYYY/MM/DD)から、16ビット整数を10進数表記した日付形式の日付文字列を生成する関数です。 MemoEditActivity.java (6) public String getDate16(String date) { String rtnStr = &quot;&quot;; try{ int year = (Integer.parseInt(date.substring(0,4)) - 1980) &lt;&lt; 9; int month = (Integer.parseInt(date.substring(5,7))) &lt;&lt; 5; int day = Integer.parseInt(date.substring(8,10)); rtnStr = String.valueOf(year + month + day); } catch(Exception e) { Log.e(&quot;ERROR&quot;, &quot;ERROR: &quot; + e.toString()); e.printStackTrace(); } return rtnStr; } 実行結果 メモ&amp;タイトルを保存してみます。 メモ&amp;タイトルを入力し、Save ボタンをタップして保存します。 Back ボタン をタップし前画面に戻ると、保存した内容が表示されました。 サンプルコード android_tutorial_07.zip (533KB) このサイトのサンプルコードは二条項BSDライセンスで提供されています。",
    "url": "http://localhost:4000/docs/tutorials/android/7.html",
    "relUrl": "/docs/tutorials/android/7.html"
  },
  "50": {
    "id": "50",
    "title": "FlashAirへのアップロード",
    "content": "FlashAirへのアップロード このチュートリアルでは、CGI経由でFlashAirにファイルをアップロード（書き込み）する方法について学びます。 使用するCGIはupload.cgi です。 このチュートリアルは別項のiOS Tutorial 4: サムネイルの表示 に基づいています。 概要 FlashAirに保存されている画像を、日付別にタイトル＆メモをつけて管理できるようにします。 注意: 本機能を誤って使用すると、FlashAirのファイルシステムを破壊してデータを失う恐れがあります。PCなどのSDメモリカードホスト機器はSDメモリカードの内容(FAT)をキャッシュしている場合がありますが、本CGIで行った変更をSDメモリカードホスト機器が認識する方法がありません。そのため、本CGIとSDメモリカードホスト機器から同時に変更を行うとFAT不整合が起こる可能性があります。 CGIからの書き込み後は必ずカードをいったん抜いて再挿入するなどしてSDメモリカードホスト機器に再認識させてください。 画面レイアウトの作成 レイアウトはこのように作ります。 iOS Tutorial 4: サムネイルの表示に、画面3:日付一覧、画面4:操作画面を追加します。 画面1:コンテンツリストに Date List ボタンを追加します。 Date List ボタンをタップされると画面3:日付一覧を表示します。 日付一覧の日付がタップされると、その日付の画面4:操作画面を表示します。 コードの作成 画面1:コンテンツリストの作成 iOS Tutorial 4: サムネイルの表示の状態に、Date List ボタンをタップした際の処理を追加します。 また、ここでは画像ファイルのみを対象とするので、絞り込み条件の追加等も行います。 詳しい内容についてはサンプルコードを確認してください。 画面2:画像表示画面の作成 画像表示画面 はiOS Tutorial 3: コンテンツのダウンロードと同じです。 実装の詳細についてはこのチュートリアルを参照してください。 画面3:日付一覧の作成 コンテンツリストで選択していたフォルダ内にある画像ファイルの、保存日付をタイトルとともに一覧で表示するようにします。 タイトルは、1行目にタイトル、2行目にメモの情報を書き込んだテキストファイルから取得します。 ファイルはYYYYMMDD.txt という名前（YYYYMMDDは日付が入ります）で、保存画像と同じフォルダに、画面4:操作画面から保存します(保存部分については後述します)。 まずは画像の日付を取得します。 FSDatelistViewController.m (1) NSMutableDictionary *ret = nil; // Find unique dates of files NSMutableSet *dates = [NSMutableSet set]; for (NSString *fileInfo in self.files) { NSArray *tokens = [fileInfo componentsSeparatedByString:@&quot;,&quot;]; // Skip if it is the signature line or an empty line or not image file. NSString *dir = [tokens objectAtIndex:0]; NSString *filename = [tokens objectAtIndex:1]; NSString *ext = [[filename pathExtension] lowercaseString]; if([dir isEqualToString:@&quot;&quot;] || [dir isEqualToString:@&quot;WLANSD_FILELIST r&quot;] || !([ext isEqualToString:@&quot;jpg&quot;] || [ext isEqualToString:@&quot;jpeg&quot;] || [ext isEqualToString:@&quot;png&quot;] || [ext isEqualToString:@&quot;jpe&quot;])){ continue; } // Add date. [dates addObject:[tokens objectAtIndex:4]]; } 次に、各日付のタイトルを取得します。 FSDatelistViewController.m (2) // Load existing memo. ret = [NSMutableDictionary dictionary]; NSDateFormatter *toFormatter = [[NSDateFormatter alloc] init]; [toFormatter setDateFormat:@&quot;yyyyMMdd&quot;]; //for filename NSDateFormatter *tostrFormatter = [[NSDateFormatter alloc] init]; [tostrFormatter setDateFormat:@&quot;yyyy/MM/dd&quot;]; //for show display for (NSString *date in dates) { NSError *error = nil; // Convert date number to string. NSString *sDate= [toFormatter stringFromDate:[self dateAsDate:date]]; NSString *strDate= [tostrFormatter stringFromDate:[self dateAsDate:date]]; // Make up URL to the memo file. NSURL *url=[NSURL URLWithString:[NSString stringWithFormat:@&quot;http://flashair%@/%@.txt&quot;, self.path, sDate]]; // Get memo contents from the FlashAir. NSString *title = @&quot;&quot;; NSString *body = @&quot;&quot;; NSString *memoData =[NSString stringWithContentsOfURL:url encoding:NSUTF8StringEncoding error:&amp;error]; if ( ![error.domain isEqualToString:NSCocoaErrorDomain] &amp;&amp; [memoData rangeOfString:@&quot;DOCTYPE&quot; options:NSCaseInsensitiveSearch].location == NSNotFound) { // Success to get existing memo. NSArray *data = [memoData componentsSeparatedByString:@&quot; n&quot;]; title = [data objectAtIndex:0]; body = [data objectAtIndex:1]; } // Add this memo to the list. NSDictionary *memo = [NSDictionary dictionaryWithObjectsAndKeys: title, @&quot;title&quot;, body, @&quot;body&quot;, strDate, @&quot;date&quot;, nil]; [ret setObject:memo forKey:sDate]; } 15-29行目 日付をもとにパスを作成し、タイトルとメモが保存されたファイルをダウンロードします。 画面4:操作画面の作成 日付一覧で選択した日付のタイトル、メモの編集と保存を行います。 アップロード タイトル&amp;メモを保存するためには、upload.cgiを使用します。 アップロードは、以下の手順で行います。 CONFIGファイルに、UPLOAD=1を書き込む FlashAirを再起動する FlashAirに無線LAN接続する WRITEPROTECTコマンドで、SDメモリカードホスト機器からの書き込みを禁止する UPDIRコマンドで、アップロード先フォルダを設定する FTIMEコマンドで、ファイルの作成日時を設定する upload.cgiにファイルをPOSTし、ファイルをアップロードする 3.までは完了しているものとして解説していきますので、事前に手動で設定をしておきましょう。 設定は、一度だけで構いません。 では、手順の4-6を行います。 FSMemoEditViewController.m (1) // Set Write-Protect and upload directory and System-Time // Make System-Time NSDate *systemdate = [NSDate date]; NSCalendar *calendar = [NSCalendar currentCalendar]; NSDateComponents *dateCompnents; dateCompnents =[calendar components:NSYearCalendarUnit | NSMonthCalendarUnit | NSDayCalendarUnit | NSHourCalendarUnit | NSMinuteCalendarUnit | NSSecondCalendarUnit fromDate:systemdate]; NSInteger year =([dateCompnents year]-1980) &lt;&lt; 9; NSInteger month = ([dateCompnents month]) &lt;&lt; 5; NSInteger day = [dateCompnents day]; NSInteger hour = [dateCompnents hour] &lt;&lt; 11; NSInteger minute = [dateCompnents minute]&lt;&lt; 5; NSInteger second = floor([dateCompnents second]/2); NSString *datePart = [@&quot;0x&quot; stringByAppendingString:[NSString stringWithFormat:@&quot;%x%x&quot; , year+month+day,hour+minute+second]]; // Make Filename NSString *filename=[[self.date stringByReplacingOccurrencesOfString:@&quot;/&quot; withString:@&quot;&quot;] stringByAppendingString :@&quot;.txt&quot;]; // Make url NSString *urlStr = @&quot;http://flashair/upload.cgi&quot;; urlStr = [urlStr stringByAppendingString:@&quot;?WRITEPROTECT=ON&amp;UPDIR=&quot;]; urlStr = [urlStr stringByAppendingString:self.path]; urlStr = [urlStr stringByAppendingString:@&quot;&amp;FTIME=&quot;]; urlStr = [urlStr stringByAppendingString:datePart]; NSURL *url = [NSURL URLWithString:urlStr]; // Run cgi NSError *error; NSString *rtnStr =[NSString stringWithContentsOfURL:url encoding:NSUTF8StringEncoding error:&amp;error]; if ([error.domain isEqualToString:NSCocoaErrorDomain]){ NSLog(@&quot;upload.cgi %@ n&quot;,error); return; }else{ if(![rtnStr isEqualToString:@&quot;SUCCESS&quot;]){ UIAlertView *alert = [[UIAlertView alloc] initWithTitle:self.title message:@&quot;upload.cgi:setup failed&quot; delegate:nil cancelButtonTitle:nil otherButtonTitles:@&quot;OK&quot;, nil]; [alert show]; return; } } 3-21行目 現在の日付からファイルの作成日時を指定するための日付文字列を生成しています。 日付、時刻をそれぞれ16ビットの16進数として作成し、合わせて32ビットの1つの値として渡しています。 次に、手順の7を行います。 FSMemoEditViewController.m (2) // File upload // Make Data self.memoTitle = self.textFieldTitle.text; self.memoBody = self.textViewMemo.text; NSString *memoData = [[self.memoTitle stringByAppendingString:@&quot; n&quot;] stringByAppendingString:self.memoBody]; NSData *textData=[memoData dataUsingEncoding:NSUTF8StringEncoding ]; //url url=[NSURL URLWithString:@&quot;http://flashair/upload.cgi&quot;]; //boundary CFUUIDRef uuid = CFUUIDCreate(nil); CFStringRef uuidString = CFUUIDCreateString(nil, uuid); CFRelease(uuid); NSString *boundary = [NSString stringWithFormat:@&quot;flashair-%@&quot;,uuidString]; //header NSString *header = [NSString stringWithFormat:@&quot;multipart/form-data; boundary=%@&quot;, boundary]; //body NSMutableData *body=[NSMutableData data]; [body appendData:[[NSString stringWithFormat:@&quot;--%@ r n&quot;,boundary] dataUsingEncoding:NSUTF8StringEncoding]]; [body appendData:[[NSString stringWithFormat:@&quot;Content-Disposition: form-data; name= &quot;file &quot;; filename= &quot;%@ &quot; r n&quot;,filename] dataUsingEncoding:NSUTF8StringEncoding]]; [body appendData:[[NSString stringWithFormat:@&quot;Content-Type: text/plain r n r n&quot;] dataUsingEncoding:NSUTF8StringEncoding]]; [body appendData:textData]; [body appendData:[[NSString stringWithFormat:@&quot; r n--%@-- r n&quot;, boundary] dataUsingEncoding:NSUTF8StringEncoding]]; //Request NSMutableURLRequest *request =[NSMutableURLRequest requestWithURL:url]; [request setHTTPMethod:@&quot;POST&quot;]; [request addValue:header forHTTPHeaderField:@&quot;Content-Type&quot;]; [request setHTTPBody:body]; NSURLResponse *response; NSData *result = [NSURLConnection sendSynchronousRequest:request returningResponse:&amp;response error:&amp;error]; rtnStr=[[NSString alloc] initWithData:result encoding:NSUTF8StringEncoding]; if ([error.domain isEqualToString:NSCocoaErrorDomain]){ NSLog(@&quot;upload.cgi %@ n&quot;,error); return; }else{ if([rtnStr rangeOfString:@&quot;Success&quot;].location==NSNotFound){ //v2.0 UIAlertView *alert = [[UIAlertView alloc] initWithTitle:self.title message:@&quot;upload.cgi: POST failed&quot; delegate:nil cancelButtonTitle:nil otherButtonTitles:@&quot;OK&quot;, nil]; [alert show]; return; } } 19行目 multipart/form-data形式を指定しています。 実行結果 メモ&amp;タイトルを保存してみます。 Date List ボタンをタップします。 2013/03/03 をタップします。 2013/03/03 の操作画面が表示されました。 メモ&amp;タイトルを入力し、Done ボタンをタップして保存します。 Back ボタン をタップし前画面に戻ると、保存した内容が表示されました。 サンプルコード ios_tutorial_07.zip (62KB) このサイトのサンプルコードは二条項BSDライセンスで提供されています。",
    "url": "http://localhost:4000/docs/tutorials/ios/7.html",
    "relUrl": "/docs/tutorials/ios/7.html"
  },
  "51": {
    "id": "51",
    "title": "フォトシェア",
    "content": "フォトシェア このチュートリアルでは、フォトシェアについて学びます。 command.cgi の フォトシェアモードの有効化 と フォトシェアモードの解除 を使用します。 このチュートリアルは別項の iOS Tutorial 7: FlashAirへのアップロード に基づいています。** 概要 フォトシェアとは、FlashAirの指定したフォルダと日付の画像だけを、公開できるようにする機能です。 メモ: フォトシェアを行う際には、フォトシェア専用のSSIDに変更することをおすすめします。 フォトシェアを解除した瞬間に全ての画像の閲覧が可能になりますが、直後に元のSSIDに戻すことで、強制的に共有状態を解除するためです。 SSIDの変更の詳細は iOS Tutorial 6: SSIDとパスワードの変更 を参考にしてください。 画面レイアウトの作成 レイアウトはこのように作ります。 iOS Tutorial 7: FlashAirへのアップロード に、画面5:フォトシェア実行中画面を追加します。 画面4:操作画面に PhotoShare ボタンを追加します。 PhotoShare ボタンがタップされると画面5:フォトシェア実行中画面を表示します。 コードの作成 画面4:操作画面の作成 iOS Tutorial 7: FlashAirへのアップロードの状態に、PhotoShare ボタンをタップした際の処理を追加します。 フォトシェアの有効化 フォトシェアを行うためには、以下のコマンドを使用します。 フォトシェアは、command.cgiにop=200とフォルダパス、日付を指定することで設定できます。 コマンド: http://flashair/command.cgi?op=200&amp;DIR=/DCIM/100__TSB&amp;DATE=17153 コマンドが返す情報: OK フォトシェアの有効化に成功 400 Bad Request フォトシェアの有効化に失敗 では、フォトシェアを設定します。 FSMemoEditViewController.m (1) - (IBAction) photoshareButton:(id)sender { NSError *error = nil; // Set photoshare // Make url NSString *urlStr = [@&quot;http://flashair/command.cgi?op=200&amp;DIR=&quot; stringByAppendingString:self.path ]; urlStr = [urlStr stringByAppendingString:@&quot;&amp;DATE=&quot;]; urlStr = [urlStr stringByAppendingString: [self getDate16: self.date]]; NSURL *url = [NSURL URLWithString:urlStr]; //Run cgi NSString *rtnStr = [NSString stringWithContentsOfURL:url encoding:NSUTF8StringEncoding error:&amp;error]; if ([error.domain isEqualToString:NSCocoaErrorDomain]) { NSLog(@&quot;command.cgi %@ n&quot;, error); } else { if ([rtnStr isEqualToString:@&quot;OK&quot;]) { // Segue [self performSegueWithIdentifier:@&quot;toPhotoshare&quot; sender:self]; } else { NSLog(@&quot;%@&quot;, rtnStr); UIAlertView *alert = [[UIAlertView alloc] initWithTitle:@&quot;PhotoShare&quot; message:@&quot; command.cgi failed&quot; delegate:nil cancelButtonTitle:nil otherButtonTitles:@&quot;OK&quot;, nil]; [alert show]; return; } } } 6-13行目 フォトシェアを設定しています。 17-19行目 フォトシェアを設定した結果が成功であった場合は、フォトシェア実行中画面へ遷移するように設定しています。 FSMemoEditViewController.m (2) - (void) prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender { // Pass next View the Data if ([segue.identifier isEqualToString:@&quot;toImageView&quot;]) { FSImageViewController *imageViewController = segue.destinationViewController; imageViewController.fileInfo = rowdata; } if ([segue.identifier isEqualToString:@&quot;toPhotoshare&quot;]) { FSPhotoShareViewController *photoShareViewController = segue.destinationViewController; photoShareViewController.path = [self.path stringByAppendingString:@&quot;/&quot;]; photoShareViewController.date = self.date; } } 7-11行目 フォトシェア実行中画面に、現在対象となっているフォルダと日付を渡します。 画面5:フォトシェア実行中画面の作成 フォトシェア設定後に遷移する画面を作成します。 Back ボタン がタップされた際には、メッセージを表示した後、フォトシェアを解除します。 フォトシェア解除 フォトシェアの解除を行うためには、以下のコマンドを使用します。 フォトシェアは、command.cgiにop=201を指定することで解除できます。 コマンド: http://flashair/command.cgi?op=201 コマンドが返す情報: OK フォトシェアの解除に成功 400 Bad Request フォトシェアの解除に失敗 FSPhotoShareViewController.m(1) - (IBAction)backButton:(id)sender { // back button was pressed. UIAlertView *alert = [[UIAlertView alloc] initWithTitle:@&quot;PhotoShare&quot; message: @&quot;Do you disable PhotoShare?&quot; delegate:self cancelButtonTitle:@&quot;Cancel&quot; otherButtonTitles:@&quot;OK&quot;, nil]; [alert show]; } - (void) disablePhotoShare { // Disable photoshare // Make url NSError *error; NSString *urlStr = @&quot;http://flashair/command.cgi?op=201&quot;; NSURL *url = [NSURL URLWithString:urlStr]; //Run cgi NSString *rtnStr = [NSString stringWithContentsOfURL:url encoding: NSUTF8StringEncoding error:&amp;error]; if ([error.domain isEqualToString:NSCocoaErrorDomain]) { NSLog(@&quot;command.cgi %@ n&quot;, error); } else { if ([rtnStr isEqualToString:@&quot;OK&quot;]) { [self.navigationController popViewControllerAnimated:YES]; } else { NSLog(@&quot;%@&quot;, rtnStr); UIAlertView *alert = [[UIAlertView alloc] initWithTitle:@&quot;PhotoShare&quot; message:@&quot;command.cgi failed&quot; delegate:nil cancelButtonTitle:nil otherButtonTitles:@&quot;OK&quot;, nil]; [alert show]; return; } } } -(void)alertView:(UIAlertView*)alertView clickedButtonAtIndex:(NSInteger)buttonIndex { switch (buttonIndex) { case 1: [self disablePhotoShare]; break; default: break; } } 13-17行目 フォトシェアを解除しています。 21-22行目 フォトシェアを解除した結果が成功であった場合は、前の画面へ戻します。 実行結果 フォトシェアを設定してみます。 その前に、フォトシェアを解除しておきます。 Date List ボタンをタップします。 2013/03/03を選択してみます。 PhotoShare ボタンをタップし、フォトシェアを設定します。 成功し、フォトシェア実行中画面に遷移しました。 フォトシェアが設定されているか、確認してみます。 指定したフォルダと日付の画像だけが表示されました。 サンプルコード ios_tutorial_08.zip (63KB) このサイトのサンプルコードは二条項BSDライセンスで提供されています。",
    "url": "http://localhost:4000/docs/tutorials/ios/8.html",
    "relUrl": "/docs/tutorials/ios/8.html"
  },
  "52": {
    "id": "52",
    "title": "フォトシェア",
    "content": "フォトシェア このチュートリアルでは、フォトシェアについて学びます。 command.cgi の フォトシェアモードの有効化 と フォトシェアモードの解除 を使用します。 このチュートリアルは別項の android Tutorial 7: FlashAirへのアップロード に基づいています。 概要 フォトシェアとは、FlashAirの指定したフォルダと日付の画像だけを、公開できるようにする機能です。 メモ: フォトシェアを行う際には、フォトシェア専用のSSIDに変更することをおすすめします。 フォトシェアを解除した瞬間に全ての画像の閲覧が可能になりますが、直後に元のSSIDに戻すことで、強制的に共有状態を解除するためです。 SSIDの変更の詳細は iOS Tutorial 6: SSIDとパスワードの変更 を参考にしてください。 日付の操作画面に PhotoShare ボタンを配置します。 PhotoShare ボタンをタップするとPhotoShare中の画面が表示されます。 この状態でFlashAirに接続すると、操作していたフォルダ及び日付の画像のみが表示されます。 アプリケーションを作成するにあたって、次のファイルを作成します。 MainActivity.java activity_main.xml ImageViewActivity.java activity_image_view.xml DateListActivity.java activity_date_list.xml list_view_item.xml MemoEditActivity.java activity_memo_edit.xml grid_view_item.xml FlashAirRequest.java PhotoShareActivity.java activity_photoshare.xml 重要: Android application は、デフォルトの状態ではインターネットにアクセスすることができません。 そのため、設定ファイル_AndroidManifest.xml_ を変更し、権限を与える必要があります。 パス:[Project_Folder]/AndroidManifest.xml AndroidManifest.xml に以下のコードを追加してください。 &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt; 画面レイアウトの作成 strings.xml修正 strings.xmlは以下の記述を追加してください。 このファイルは、values フォルダに配置されています。 パス: [Project_Folder]/res/values/strings.xml strings.xmlは Android Tutorial 7: FlashAirへのアップロードと同じ状態のファイルに追加をします。 &lt;string name=&quot;photoshare&quot;&gt;PhotoShare&lt;/string&gt; &lt;string name=&quot;photoshare_enabled_&quot;&gt;PhotoShare Enabled.&lt;/string&gt; コンテンツリストのレイアウト作成 activity_main.xml を記述して、レイアウトを決定します。 このファイルは、layout フォルダに配置されています。 パス: [Project_Folder]/res/layout/activity_main.xml activity_main.xml は Android Tutorial 7: FlashAirへのアップロードと同じになります。 実装の説明についてはそちらを参照してください。 イメージビューのレイアウト作成 次に、 activity_image_view.xml を記述して、レイアウトを決定します。 このファイルは、layout フォルダに配置されています。 パス: [Project_Folder]/res/layout/activity_image_view.xml activity_image_view.xml は Android Tutorial 3: コンテンツのダウンロードと同じになります。 実装の説明についてはそちらを参照してください。 日付一覧のレイアウト作成 次に、 activity_date_list.xml と list_view_item.xml を記述して、レイアウトを決定します。 list_view_item.xml は、リストの1行分のレイアウトです。 これらのファイルは、layout フォルダに配置されています。 パス: [Project_Folder]/res/layout/activity_date_list.xml [Project_Folder]/res/layout/list_view_item.xml activity_date_list.xml と list_view_item.xml は Android Tutorial 7: FlashAirへのアップロードと同じになります。 実装の説明についてはそちらを参照してください。 操作画面のレイアウト作成 次に、 activity_memo_edit.xml と grid_view_item.xml を記述して、レイアウトを決定します。 grid_view_item.xml は、サムネイルの表示に使用します。 これらのファイルは、layout フォルダに配置されています。 パス: [Project_Folder]/res/layout/activity_memo_edit.xml [Project_Folder]/res/layout/grid_view_item.xml grid_view_item.xml は Android Tutorial 7: FlashAirへのアップロードと同じになります。 activity_memo_edit.xml は Android Tutorial 7: FlashAirへのアップロードと同じ状態のレイアウトにボタンを１つ追加します。 activity_memo_edit.xml に以下の内容を追加してください。 activity_memo_edit.xml &lt;Button android:id=&quot;@+id/button3&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginTop=&quot;12dp&quot; android:cacheColorHint=&quot;#00000000&quot; android:text=&quot;@string/photoshare&quot; android:textColor=&quot;@android:color/white&quot; android:textSize=&quot;20sp&quot; /&gt; フォトシェア実行中画面のレイアウト作成 次に、 activity_photoshare.xml を記述して、レイアウトを決定します。 このファイルは、layout フォルダに配置されています。 パス: [Project_Folder]/res/layout/activity_photoshare.xml activity_photoshare.xml に以下のように記述してください。 activity_photoshare.xml &lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:gravity=&quot;center_horizontal&quot; android:orientation=&quot;vertical&quot; tools:context=&quot;.PhotoShareActivity&quot; &gt; &lt;Button android:id=&quot;@+id/button1&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:cacheColorHint=&quot;#00000000&quot; android:text=&quot;@string/back&quot; android:textColor=&quot;@android:color/white&quot; android:textSize=&quot;20sp&quot; /&gt; &lt;TextView android:id=&quot;@+id/textView1&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:gravity=&quot;center_horizontal&quot; android:scaleType=&quot;centerInside&quot; android:text=&quot;@string/directory_name&quot; android:textAlignment=&quot;center&quot; android:textAppearance=&quot;?android:attr/textAppearanceLarge&quot; /&gt; &lt;TextView android:id=&quot;@+id/textView2&quot; android:layout_width=&quot;152dp&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginTop=&quot;12dp&quot; android:gravity=&quot;center&quot; android:hint=&quot;@string/date&quot; android:paddingLeft=&quot;10dp&quot; android:textSize=&quot;18sp&quot; /&gt; &lt;TextView android:id=&quot;@+id/textView3&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginTop=&quot;12dp&quot; android:gravity=&quot;center&quot; android:paddingLeft=&quot;10dp&quot; android:text=&quot;@string/photoshare_enabled_&quot; android:textSize=&quot;18sp&quot; /&gt; &lt;/LinearLayout&gt; コードの作成 コンテンツリストの作成 class MainActivity は Android Tutorial 7: FlashAirへのアップロードと同じです。 実装の詳細についてはこのチュートリアルを参照してください。 画像表示画面の作成 class ImageViewActivity は Android Tutorial 3: コンテンツのダウンロードと同じです。 実装の詳細についてはこのチュートリアルを参照してください。 日付一覧画面の作成 class DateListActivity は Android Tutorial 7: FlashAirへのアップロードと同じです。 実装の詳細についてはこのチュートリアルを参照してください。 操作画面の作成 MemoEditActivity.java を修正します。 Android Tutorial 7: FlashAirへのアップロードの状態に、PhotoShare ボタンをタップした際の処理を追加します。 初期化とフォトシェアの有効化 Android Tutorial 7: FlashAirへのアップロード の MemoEditActivity.java をコピーし、それを新しい MemoEditActivity.java として使用してください。 フォトシェアを行うためには、以下のコマンドを使用します。 フォトシェアは、command.cgi にop=200 とフォルダパス、日付を指定することで設定できます。 コマンド: http://flashair/command.cgi?op=200&amp;DIR=/DCIM/100__TSB&amp;DATE=17153 コマンドが返す情報: OK フォトシェアの有効化に成功 400 Bad Request フォトシェアの有効化に失敗 メンバ変数の追加と onCreate(Bundle savedInstanceState) 関数に以下の内容の追加をします。 MemoEditActivity.java (1) public class MemoEditActivity extends Activity { Button photoShareButton; @Override protected void onCreate(Bundle savedInstanceState) { // Set photoShareButton photoShareButton = (Button)findViewById(R.id.button3); photoShareButton.getBackground().setColorFilter(Color.rgb(65, 183, 216), PorterDuff.Mode.SRC_IN); photoShareButton.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { // new AsyncTask&lt;String, Void, String&gt;(){ @Override protected String doInBackground(String... params) { return FlashAirRequest.getString(params[0]); } @Override protected void onPostExecute(String result) { if(result.toUpperCase(Locale.getDefault()).equals(&quot;OK&quot;)) { Intent photoShare = new Intent(getBaseContext(), PhotoShareActivity.class); photoShare.putExtra(&quot;date&quot;, date); photoShare.putExtra(&quot;dir&quot;, directoryName); MemoEditActivity.this.startActivity(photoShare); }else{ Toast.makeText(MemoEditActivity.this, &quot;Enable failed.&quot;, Toast.LENGTH_LONG).show(); } } }.execute(&quot;http://flashair/command.cgi?op=200&amp;DIR=/&quot; + directoryName + &quot;&amp;DATE=&quot; + getDate16(date)); } }); } } // End SetScreenActivity class 作成済みの MemoEditActivity に PhotoShare ボタンのためのコードを追加します。 18行目 フォトシェアを設定しています。 22-30行目 フォトシェアを設定した結果が成功であった場合は、フォトシェア実行中画面へ遷移するように設定しています。 残りの MemoEditActivity.java はそのまま使用します。 フォトシェア実行中画面の作成 初期化 ビューの宣言、その他のクラス変数の宣言や画面の初期設定を行います。 また、 onCreate(Bundle savedInstanceState) をオーバーライドし、アクティビティクラスの初期化も行います。 リストの初期設定や Button のクリックリスナーも設定します。 PhotoShareActivity.java (1) public class PhotoShareActivity extends Activity { ImageView imageView; Button backButton; TextView dateText; TextView currentDirText; String date; String rootDir = &quot;DCIM&quot;; String directoryName; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_photoshare); Bundle extrasData = getIntent().getExtras(); date = extrasData.getString(&quot;date&quot;); directoryName = extrasData.getString(&quot;dir&quot;); // Set backButton backButton = (Button) findViewById(R.id.button1); backButton.getBackground().setColorFilter(Color.rgb(65, 183, 216), PorterDuff.Mode.SRC_IN); backButton.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { disablePhotoShare(); } }); currentDirText = (TextView)findViewById(R.id.textView1); currentDirText.setText(directoryName); dateText = (TextView) findViewById(R.id.textView2); dateText.setText(date); } 24-29行目 ユーザーが Back ボタン をタップした際は、メッセージを表示した後、フォトシェアを解除します。 フォトシェア解除 フォトシェアの解除を行うためには、以下のコマンドを使用します。 フォトシェアは、command.cgi にop=201 を指定することで解除できます。 コマンド: http://flashair/command.cgi?op=201 コマンドが返す情報: OK フォトシェアの解除に成功 400 Bad Request フォトシェアの解除に失敗 PhotoShareActivity.java (2) private void disablePhotoShare() { AlertDialog.Builder alertDialog=new AlertDialog .Builder(PhotoShareActivity.this); alertDialog.setTitle(R.string.app_name); alertDialog.setMessage(&quot;Do you disable PhotoShare?&quot;); // in case clicked OK alertDialog.setPositiveButton(&quot;OK&quot;,new DialogInterface.OnClickListener() { @Override public void onClick(DialogInterface dialog,int whichButton) { new AsyncTask&lt;String, Void, String&gt;(){ @Override protected String doInBackground(String... params) { return FlashAirRequest.getString(params[0]); } @Override protected void onPostExecute(String result) { if(result.toUpperCase(Locale.getDefault()).equals(&quot;OK&quot;)) { Toast.makeText(PhotoShareActivity.this, &quot;Disable completed.&quot;, Toast.LENGTH_LONG).show(); PhotoShareActivity.this.finish(); // Go back }else{ Toast.makeText(PhotoShareActivity.this, &quot;Disable failed.&quot;, Toast.LENGTH_LONG).show(); } } }.execute(&quot;http://flashair/command.cgi?op=201&quot;); } }); // in case clicked Cancel alertDialog.setNegativeButton(&quot;Cancel&quot;, new DialogInterface.OnClickListener() { @Override public void onClick(DialogInterface dialog,int whichButton) { } }); alertDialog.setCancelable(false); alertDialog.create(); alertDialog.show(); } 13行目 フォトシェアを解除しています。 17-24行目 フォトシェアを解除した結果が成功であった場合は、前の画面へ戻します。 backキーの制御 Androidのbackキーをタップした際にも、Back ボタンをタップした時と同じように動くように設定します。 PhotoShareActivity.java (3) @Override public boolean onKeyDown(int keyCode, KeyEvent event) { if(keyCode == KeyEvent.KEYCODE_BACK){ disablePhotoShare(); return false; }else{ return super.onKeyDown(keyCode, event); } } 実行結果 フォトシェアを設定してみます。 その前に、フォトシェアを解除し ておきます。 2013/03/03を選択してみます。 PhotoShare ボタンをタップし、フォトシェアを設定します。 フォトシェアが設定されているか、確認してみます。 指定したフォルダと日付の画像だけが表示されました。 サンプルコード android_tutorial_08.zip (533KB) このサイトのサンプルコードは二条項BSDライセンスで提供されています。",
    "url": "http://localhost:4000/docs/tutorials/android/8.html",
    "relUrl": "/docs/tutorials/android/8.html"
  },
  "53": {
    "id": "53",
    "title": "FlashAirからAmazon AWSに接続する2（実行編）",
    "content": "FlashAirからAmazon AWSに接続する2（実行編） このチュートリアルではFlashAirに保存されたデータを、インターネット経由で直接AWSに送信する方法を解説します。準備編はこちらをご覧下さい。 AWSの設定 FlashAirの設定 保存するファイルについて 実行、結果 応用 サンプルコード AWSの設定 実際にAWSアカウント作成からバケット作成、FlashAirから画像をアップロードするところまで実行してみましょう。AWS内での設定のほとんどは公式サイトに詳しい説明があるので、本チュートリアルでは簡易的にまとめています。 既にアカウント作成済み、S3に他アプリからアップロードを行ったことがある場合はFlashAirの設定に進んでください。 AWSアカウントを作成 AWS アカウントの作成からアカウントを作成を行います。 連絡先情報、クレジットカード情報登録、アカウント認証、AWSサポートプランの選択を行いアカウントを作成します。詳細はAWS アカウント作成の流れをご覧ください。 必要に応じてAWS セキュリティの認証情報 __等を設定してください。 S3にバケットを作成する Amazon S3にログインし、「Amazon S3 の使用を開始する」を選択します。画面の指示通りに進みます。 「バケットを作成する」ボタンをクリックします。 ダイアログからバケットを作成します。任意のバケット名、リージョンを入力し「作成」ボタンをクリックします。 例 flashair-bkt アジアパシフィック（東京） S3へファイルをアップロードするために必要なアクセスキーとシークレットキーを取得します。 AWSメニューバーからアカウント名をクリックし、「セキュリティ認証情報」をクリックします。 IAM ユーザーのアクセスキーの管理を参考に、アクセスキー、シークレットキーを取得、控えておきます。これらの情報は取扱に注意し、他人と共有しないようにしてください。 これでS3の準備が完了しました。 FlashAirの設定 FlashAirの設定を行います。FlashAirをステーションモードにして無線LAN子機として使用します。ステーションモードの詳細はステーションモードの利用をご覧ください。 CONFIGの設定 CONFIGを編集するには、/SD_WLAN/CONFIGをエディタ等で開き、前述のパラメータを編集します。 このフォルダは隠しフォルダとなっていますので、隠しフォルダを扱う事が出来るツールを使いましょう。 (Macの場合は/Volumes/(ボリュームラベル名)/SD_WLAN/CONFIGです。) CONFIG内で以下の3つの情報を変更する必要があります。 括弧内は CONFIGの対応するパラメータ名です。 パラメータが存在しない場合は新しく行を追加してください。 パラメータの順序は問いません。 動作モード (APPMODE) パラメータに5を指定し、インフラストラクチャ・モードのステーション動作に変更します。 無線LAN SSID (APPSSID) 接続先無線LANのSSIDを指定します。 無線LAN ネットワークパスワード (APPNETWORKKEY) 接続先無線LANのネットワークキーを指定します。 編集後は、たとえば下記のようになります。 APPMODE=5 APPNAME=flashair APPSSID=FOOSSID APPNETWORKKEY=password0123 CIPATH=/DCIM/100__TSB/FA000001.JPG VERSION=F15DBW3BW4.00.03 CID=02544d535730384708c00b7d7800d201 PRODUCT=FlashAir VENDOR=TOSHIBA MASTERCODE=18002d4ff0a2 LOCK=1 ファイルの設置、設定 ページ下部のサンプルコードをダウンロードし、FlashAirのルートフォルダ内に展開します。 s3-put.luaをテキストエディタで開きます。 3-6行目をバケット作成時のリージョン、バケット名、「S3にバケットを作成する」で取得したアクセスキー、シークレットキーで上書きします。 s3-put.lua local s3Util = require(&quot;s3-util&quot;) local REGION = &quot;ap-northeast-1&quot; --リージョン名 local ACCESS_KEY = &quot;AKIAIXXXXXXXXXXXXXXX&quot; --アクセスキー local SECRET_KEY = &quot;/id3EXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX+&quot; --シークレットキー local BACKET = &quot;flashair-bkt&quot; --バケット名 保存するファイルについて DATAフォルダ アップロードするファイルを格納するフォルダです。 s3-exec.lua sendtime.datファイルに保存されている日付以降に作成されたファイルがDATAフォルダ内に見つかった場合、s3-put.luaファイルのS3Putクラスにファイルパスとファイル名を引渡します。10秒ごとにフォルダ内をチェックします。 s3-put.lua S3のバケットにファイルをアップロードします。 s3-util.lua ユーティリティクラスです。現在時刻、ハッシュ値等を、計算・取得します。 sendtime.dat s3-exec.luaでファイルを検索した後に現在日付を保存します。 注意 ファイルがアップロードされない場合は、ファイル内に1を記入（ファイル検索用日時の初期化）し上書き保存してから再度DATAフォルダにファイルを作成、コピーしてください。 それでは、サンプルプログラムがどのように動作するかをみていきます。 s3-exec.lua local s3Put = require(&quot;s3-put&quot;) local dir = &quot;/DATA&quot; 3行目 s3-put.luaをインクルードします。 5行目 アップロードするファイルの格納フォルダを指定します。変更する場合は&quot;/DATA&quot;を任意の場所に修正してください。 function readSendTime() local sendtime = 0 local file = io.open(timefile, &quot;r&quot;) if file ~= nil then sendtime = file:read() file.close() else debug(&quot;file == nil&quot;) end if sendtime == nil then debug(&quot;sendtime == nil&quot;) sendtime = 0 end debug(&quot;r = &quot; .. sendtime) return sendtime end sendtime.datファイルの内容を読み込み、内容を返します。 function writeSendTime(sendtime) local file = io.open(timefile, &quot;w+&quot;) if file ~= nil then file:write(sendtime) file:close() debug(&quot;w = &quot; .. sendtime) end end sendtime.datファイルにファイル検索を行った日時を書き込みます。 function getFilePath(sendtime) local filepath, filename = nil local result, filelist, sendtime = fa.search(&quot;file&quot;, dir, sendtime) if result == 1 or filelist ~= nil then filepath = string.match(filelist, &quot;(.-),&quot;) if filepath ~= nil then filename = string.match(filepath, &quot;[^/]*$&quot;) end end return filepath, filename, sendtime end fa.searchで、引数sendtimeと更新日時が一致するファイル、若しくは引数sendtimeより新しいファイルのうち最も古いファイル（指定された日時の次に新しいファイル）のファイルを取得し、返します。 function execute() local temptime = readSendTime() if temptime == 0 then print(&quot;temptime == 0&quot;) return end local sendtime = tonumber(readSendTime()) + 1 local filepath, filename, time = getFilePath(sendtime) if filepath == nil then return end writeSendTime(time) debug(&quot;filepath = &quot; .. filepath .. &quot;, filename = &quot; .. filename) local s3 = s3Put:new(filepath, filename) s3:put() end 47行目 sendtime.datファイルを読み込みます。日時が取得できなかった場合は終了します。 52-53行目 sendtime.datに保存されている日時の0.5秒後以降のファイルを検索します。 57行目 該当ファイルが見つかった場合、ファイルの更新日付をsendtime.datに書き込みます。 59行目 S3Putクラスにファイルパスとファイル名を引き渡します。 function debug(msg) --print(msg) end デバッグメッセージを表示します。必要な場合はコメントを削除してください。 while(1) do execute() sleep(10000) collectgarbage(&quot;collect&quot;) end sleepを使用し、10秒毎にファイル検索を行います。 s3-put.lua local s3Util = require(&quot;s3-util&quot;) s3-util.luaをインクルードします。 local S3Put = {} S3Put.new = function(self, fpath, fname) local this = {} local SERVICE = &quot;s3&quot; local METHOD = &quot;PUT&quot; local PAYLOAD_HASH = &quot;UNSIGNED-PAYLOAD&quot; local ALGORITHM = &quot;AWS4-HMAC-SHA256&quot; local CONTENT_TYPE = &quot;image/jpeg&quot; local util = s3Util:new() local filepath = fpath local filename = fname local nowtime = util:currentTime() local date = os.date(&#39;!%Y%m%d&#39;, nowtime) local datetime = os.date(&#39;!%Y%m%dT%H%M00Z&#39;, nowtime) local dataPath = &quot;/&quot; .. filename local host = SERVICE .. &quot;-&quot; .. REGION .. &quot;.amazonaws.com&quot; local canonicalURI = &quot;/&quot; .. BACKET .. dataPath local endpoint = &quot;https://&quot; .. host local canonicalQuery = &quot;&quot; local signedHeader = &quot;content-type;host;x-amz-content-sha256;x-amz-date&quot; local credentialScope = date .. &quot;/&quot; .. REGION .. &quot;/&quot; .. SERVICE .. &quot;/&quot; .. &quot;aws4_request&quot; function this:getSignatureKey() local kDate = util:sha256Hmac(&quot;AWS4&quot; .. SECRET_KEY, date) debug(&quot;kDate=&quot; .. kDate) kDate = util:hex2Bytes(kDate) local kRegion = util:sha256Hmac(kDate, REGION) debug(&quot;kRegion=&quot; .. kRegion) kRegion = util:hex2Bytes(kRegion) local kService = util:sha256Hmac(kRegion, SERVICE) debug(&quot;kService=&quot; .. kService) kService = util:hex2Bytes(kService) local kSigning = util:sha256Hmac(kService, &quot;aws4_request&quot;) debug(&quot;kSigning=&quot; .. kSigning) kSigning = util:hex2Bytes(kSigning) return kSigning end function this:getStringToSign() local canonicalHeader = &quot;content-type:&quot; .. CONTENT_TYPE .. &quot; n&quot; .. &quot;host:&quot; .. host .. &quot; n&quot; .. &quot;x-amz-content-sha256:&quot; .. PAYLOAD_HASH .. &quot; n&quot; .. &quot;x-amz-date:&quot; .. datetime .. &quot; n&quot; local canonicalRequest = METHOD .. &quot; n&quot; .. canonicalURI .. &quot; n&quot; .. canonicalQuery .. &quot; n&quot; .. canonicalHeader .. &quot; n&quot; .. signedHeader .. &quot; n&quot; .. PAYLOAD_HASH debug(&quot;canonicalRequest=&quot; .. canonicalRequest) local stringToSign = ALGORITHM .. &quot; n&quot; .. datetime .. &quot; n&quot; .. credentialScope .. &quot; n&quot; .. util:sha256(canonicalRequest) debug(&quot;-stringToSign-&quot;) debug(stringToSign) debug(&quot;-&quot;) return stringToSign end function this:getAuthorizationHeader() local signingKey = this:getSignatureKey() local signingSign = this:getStringToSign() local signature = util:sha256Hmac(signingKey, signingSign) local authorizationHeader = ALGORITHM .. &quot; &quot; .. &quot;Credential=&quot; .. ACCESS_KEY .. &quot;/&quot; .. credentialScope .. &quot;, &quot; .. &quot;SignedHeaders=&quot; .. signedHeader .. &quot;, &quot; .. &quot;Signature=&quot; .. signature debug(&quot;-authorizationHeader-&quot;) debug(authorizationHeader) debug(&quot;-&quot;) return authorizationHeader end function this:put() local filesize = lfs.attributes(filepath, &quot;size&quot;) local headers = {[&quot;content-type&quot;]=CONTENT_TYPE, [&quot;content-length&quot;]=filesize, [&quot;x-amz-date&quot;]=datetime, [&quot;x-amz-content-sha256&quot;]=PAYLOAD_HASH, [&quot;Authorization&quot;]=this:getAuthorizationHeader()} local requestURL = endpoint .. canonicalURI local body, code, header = fa.request{ url=requestURL, method=&quot;PUT&quot;, headers=headers, file=filepath, body=&#39;&lt;!--WLANSDFILE--&gt;&#39;, bufsize=1460*10, } debug(&quot;resultCode=&quot; .. code) debug(&quot;headers=&quot; .. cjson.encode(header)) debug(&quot;body=&quot; .. body) end return this end S3Putクラスを定義します。 35-49行目 シークレットキー、リージョン等から署名を暗号化するためのキーを作成します。署名キーの詳細はこちらをご覧ください。 51-60行目 正規リクエストを作成します。正規リクエストの詳細はこちらをご覧ください。 62-71行目 署名キーと正規リクエストを用いて、署名バージョン4の署名文字列を作成し、正規ヘッダーを作成します。 73-89行目 fa.requestを使用してAWS APIへリクエストを送信します。 実行、結果 FlashAirの設定が終わったら、FlashAirを抜き差しして修正を反映させます。 書き込み後は必ずカードをいったん抜いて再挿入するなどしてSDメモリカードホスト機器に再認識させてください。PCなどのSDメモリカードホスト側のOSがSDメモリカードの内容をキャッシュしていると、その変更をOSが認識する事が出来ません。その為、SDメモリカードホスト機器とLuaやCGIから同時に変更を行うとFAT不整合が起きる可能性があります。 ブラウザから http://flashair/s3-exec.lua を実行します。 DATAフォルダにファイルを作成またはコピーします。 アップロードが行われたか確認します。 「S3にバケットを作成する」で作成したバケット名をクリックします。 DATAフォルダ内のファイルがアップロードされていることが確認できました。 応用 準備編で解説したLambda、Rekognition、QuickSightを使用すると、取得したデータを加工、可視化、共有することが出来ます。 今回は、動体検知カメラで撮影した顔写真から年齢や性別、笑顔の有無などをRekognitionにより判定し、QuickSightで可視化してみました。 Lambda内でS3にファイルが追加されたらRekognitionの顔認識処理を呼び出す関数を作成します。関数の作成方法はLambda 関数を作成するをご覧ください。 あらかじめS3内に解析結果を格納するためのバケットを準備しておきます。Rekognitionの解析処理を取得したらS3に解析結果を解析バケットに格納する関数も用意します。 QuickSightでは、上記で作成した解析バケットのデータを用いてグラフを作成することが出来ます。QuickSightの使用方法はAmazon QuickSight とはをご覧ください。 Lambda QuickSight サンプルコード advanced_tutorial_08.zip (4KB) このサイトのサンプルコードは二条項BSDライセンスで提供されています。",
    "url": "http://localhost:4000/docs/tutorials/advanced/8.html",
    "relUrl": "/docs/tutorials/advanced/8.html"
  },
  "54": {
    "id": "54",
    "title": "Webインターフェースの作成",
    "content": "Webインターフェースの作成 LuaでHTML/JavaScriptをprintすることで、動的にHTMLコンテンツを作成します。PHPでWebコンテンツを作成するのと似ています。 このチュートリアルでは、2つの基本的な例をみていきましょう。 画像のダウンロードと表示 まず、 fa.HTTPGetFileを使用して、画像をダウンロードしてみましょう。ダウンロードが成功すると、画像を表示します。それでは、FlashAirのロゴを表示してみましょう。 /ImageDownload.lua --HTTP request result = fa.HTTPGetFile(&quot;https://flashair-developers.com/images/assets/flashairLogo_official_small.png&quot;, &quot;logo.png&quot;) print(&quot;&lt;!DOCTYPE html&gt;&quot;) print(&quot;&lt;html&gt;&quot;) print(&quot;&lt;body&gt;&lt;center&gt;&quot;) print(&quot;&lt;h2&gt;Hello HTML!&lt;/h2&gt;&quot;) if result ~= nil then --Display the image print(&quot;&lt;img src= &quot;logo.png &quot; alt= &quot;FlashAir Developers Logo &quot;&gt;&quot;) else print(&quot;File failed to download...&quot;) end print(&quot;&lt;/body&gt;&quot;) print(&quot;&lt;/html&gt;&quot;) これで終わりです!ブラウザからスクリプトを呼び出すと、画像が表示されます。 FlashAirステータス表示 次に、ステータスを表示する画面を作成してみましょう。このページには、SSID、ディレクトリ等FlashAirの情報をいくつか表示します。Luaで情報を集め、それをHTMLで表示します。 それでは、loadConfig()関数を使って、SD_WLAN/CONFIGファイルから情報を取得してみましょう。 /ShowStatus.lua --Read the FlashAir config file, store it in a table local function loadConfig() local file = io.open(&quot;/SD_WLAN/CONFIG&quot;, &quot;r&quot; ) config = {} for line in file:lines() do --Split the config file into variables and values --ie: APPMODE=5 var, value = line:match(&quot;([^,]+)=([^,]+)&quot;) if var ~= nil and value ~= nil then config[var] = value end end return config end 次に、ディレクトリ内のファイルリストを作成します。再帰的にファイルの合計数をカウントするために、2つの関数を作成します。 --Returns a list of files in a directory, as well as their size local function getfileSize(path) size=0 for file in lfs.dir(path) do attr = lfs.attributes(path..&quot;/&quot;..file) if attr ~= nil and attr.mode == &quot;file&quot; then size = size + math.floor( attr.size / 1024 * math.pow( 10, 1 ) ) / math.pow( 10, 1 ) end end return size end local function getfileList(path) file_list = {} for file in lfs.dir(path) do attr = lfs.attributes(path..&quot;/&quot;..file) file_list[file] = getfileSize(path..&quot;/&quot;..file) end return file_list end --Recursively counts the number of files in a directory (not including folders) local function countFiles(path) --print(&quot;Counting: &quot;..path) count=0 for file in lfs.dir(path) do attr = lfs.attributes(path..&quot;/&quot;..file) if attr ~= nil and attr.mode == &quot;file&quot; then count = count +1 end if attr ~= nil and attr.mode == &quot;directory&quot; then count = count + countFiles(path..&quot;/&quot;..file) end end return count end fa.requestを使ってcommand.cgiを呼び出すことで、これらの情報を得ることはできますが、LuaFileSystemを使用する方が高速に処理できます。 では、これらの2つの関数が準備できたので、残りのスクリプトを書いていきましょう。基本的なHTMLを使用し、ページを再読み込みするためにリフレッシュタグも使います。 reloadTime = &quot;60&quot; --How often (in seconds) the status page should update. monitorDir = &quot;/DCIM&quot; --What directory to monitor --load the config file config_table=loadConfig() file_count=countFiles(monitorDir) file_list=getfileList(monitorDir) print(&quot;&lt;!DOCTYPE html&gt;&quot;) print(&quot;&lt;html&gt;&quot;) --Set the page to reload every x seconds print(&quot;&lt;meta http-equiv= &quot;refresh &quot; content= &quot;&quot;..reloadTime..&quot; &quot; /&gt;&quot;) print(&quot;&lt;body&gt;&lt;center&gt;&quot;) if config_table[&quot;APPNAME&quot;] ~= nil then print(&quot;&lt;h2&gt;&quot;..config_table[&quot;APPNAME&quot;]..&quot; Status Page&lt;/h2&gt;&quot;) else print(&quot;&lt;h2&gt;FlashAir Status Page&lt;/h2&gt;&quot;) end if config_table[&quot;APPMODE&quot;] ~= nil and config_table[&quot;APPSSID&quot;] ~= nil and config_table[&quot;VERSION&quot;] ~= nil then print(&quot;&lt;b&gt;APPMODE:&lt;/b&gt; &quot;..config_table[&quot;APPMODE&quot;]..&quot;&lt;b&gt;SSID:&lt;/b&gt; &lt;i&gt;&quot;..config_table[&quot;APPSSID&quot;]..&quot;&lt;/i&gt;&quot;) print(&quot;&lt;br&gt;&quot;) print(&quot;&lt;b&gt;Version: &lt;/b&gt;&quot;..config_table[&quot;VERSION&quot;]) else print(&quot;&lt;b&gt;Error loading CONFIG file!&lt;/b&gt;&quot;) end print(&quot;&lt;br&gt;&lt;br&gt;&quot;) print(&quot;&lt;h2&gt;&quot;..monitorDir..&quot;&lt;/h2&gt;&quot;) print(&quot;&lt;div&gt;&quot;) for file,size in pairs(file_list) do if file ~= &quot;&quot; and size ~= &quot;&quot; then print(&quot;&lt;a href=&quot;..monitorDir..&quot;/&quot;..file..&quot;&gt;&quot;..file..&quot;&lt;/a&gt;: &quot;..size..&quot;kb&lt;br&gt;&quot;) end end print(&quot;&lt;/div&gt;&quot;) print(&quot;Total files: &quot;..file_count) print(&quot;&lt;/body&gt;&quot;) print(&quot;&lt;/html&gt;&quot;) Note: print文で表示する引用符をすべて’&#39;でエスケープしているか確認してください！ サンプルコード リポジトリを見る（GitHub） このサイトのサンプルコードは二条項BSDライセンスで提供されています。",
    "url": "http://localhost:4000/docs/tutorials/lua/8.html",
    "relUrl": "/docs/tutorials/lua/8.html"
  },
  "55": {
    "id": "55",
    "title": "Googleドライブへのアップロード",
    "content": "Googleドライブへのアップロード 本記事はFixstars Solutions Incの許可を得て転載したものです。 転載元：http://www.fixstars.com/en/news/?p=451 はじめに FlashAirにtestfile.jpgを設置します。 FlashAirでLuaを実行するを参考に、Luaスクリプト実行方法をCONFIGファイルに指定します。 導入 このチュートリアルでは、LUAとGoogle device APIを使ってGoogleドライブへイメージデータをアップロードする方法を紹介いたします。これはFlashAirのような限られた入力機能を持つものから実行するアイデアになります。残念ながらすべての設定が完了するまでは入力機能デバイスが必要となりますが、一度設定が完了したら、ヘッドレス運用で無制限にアップロードすることができます。 手順 1. Googleでプロジェクトを設定 GoogleのAPI Consoleを開き、”プロジェクトを選択”をクリックします。 ”+”をクリックします。 “プロジェクト名”を入力し”作成”をクリックします。 例: “My Project 1” プロジェクトの作成が終了したら、画面上部の”プロジェクトを選択”をクリックします。 作成したプロジェクト名をクリックします。 左ナビゲーションの”ライブラリ”をクリックし、”Drive API”をクリックします。 Google Drive API画面に切り替わったら、”有効にする”をクリックします。 “認証情報を作成”をクリックします。 プロジェクトへの認証情報の追加画面が表示されます。”必要な設定を決定します”と”アクセスするデータの種類”を入力し、”必要な認証情報”をクリックします。 “名前”を入力し、”クライアントIDの作成”クリックします。 例: “flashair” “ユーザーに表示するサービス名”を入力し、”次へ”クリックします。 例: “Lua Upload” “完了”をクリックします。 認証情報が作成されました。OAuth 2.0 クライアントIDの”flashair”をクリックします。 アプリの情報を控えます。これらの情報は取扱に注意し、他人と共有しないようにしてください。 クライアント ID クライアント シークレット 2. 使用デバイスの承認 セットアップでは、Googleに2段階のプロセスでデバイスを承認させる必要があります。まず、「accounts.google.com/o/oauth2/device/code」にPOSTリクエストの送信が必要です。Content-Typeに「application/x-www-form-urlencoded」を入れて、client_id（上の手順で作成したOAuthクライアントID内の「クライアントID」を入れる）とscope（「https://docs.google.com/feeds」を入れてください）の２つのフィールドを付与します。この作業のためにいくつかのツールの使用が考えられますが、GoogleChrome拡張機能「postman」がすごく使いやすいでしょう。 例: POST /o/oauth2/device/code HTTP/1.1 Host: accounts.google.com Cache-Control: no-cache Content-Type: application/x-www-form-urlencoded client_id={Your client ID} scope=http://docs.google.com/feeds/ postmanのHeaders設定 postmanのBody設定 注：Googleではscopeに「https://www.googleapis.com/auth/drive」を使用するように指示していますが、「Invalid_scope：Not authorized to request the scop」で返ってきます。代わりに/feeds/を使用すると、Googleドライブの許可が付与されます。 レスポンスには、user_codeとverification_urlが含まれるでしょう。そのurl（おそらくhttps://www.google.com/device）へ移動し、user_codeを入力します。すると、device_codeも返ってきます。 レスポンス例: &quot;device_code&quot;: {Device code}, &quot;user_code&quot;: {Your user code}, &quot;verification_url&quot;: &quot;https://www.google.com/device&quot;, &quot;expires_in&quot;: 1800, &quot;interval&quot;: 5 ウェブブラウザからhttps://www.google.com/deviceにアクセスすると、端末の接続画面が表示されます。 取得したuser_codeを入力し、”次へ”をクリックします。 “許可”をクリックします。 Googleドライブの許可が付与されました。 3. 永続リフレッシュトークンの取得 これまですべて適切に承認されてもまだ、使用しようとしているアプリのリフレッシュトークンを取得する必要があります。Googleドライブにアップロードできる一時的な「認証」トークンとは別のトークンを取得します。Googleにはたくさんのトークンがあります。リフレッシュトークンを取得するには、以下のようなPOSTリクエストを送信します。 POST /o/oauth2/token HTTP/1.1 Host: accounts.google.com Cache-Control: no-cache Content-Type: application/x-www-form-urlencoded client_id={Your full client ID} client_secret={Your client secret} code={Your device code} grant_type=http://oauth.net/grant_type/device/1.0 postmanのBody設定 あなたは以下のような形で受信します: &quot;access_token&quot;: {Your access token here}, &quot;token_type&quot;: &quot;Bearer&quot;, &quot;expires_in&quot;: 3600, &quot;refresh_token&quot;: {Your refresh token here} 最後に、ヘッドレス運用のアップロードスクリプトを作成します！私たちに本当に必要なトークンは、リフレッシュトークンです。アクセストークンは動作が短く有効期限が切れます。リフレッシュトークンを使えば、必要な時（許可が長く続かない場合がかなりある）に新しいアクセスコードを取得できます。 refresh_tokenを控えておきます。 4. Luaのインポート必須事項 取得しているすべての必要な情報を含むローカル変数を使い、以下のコードを作成します。 コード例: /GoogleDriveUpload.lua -- Basic account info local client_id = &quot;{Your full client ID}&quot; local client_secret = &quot;{Your client secret}&quot; local refresh_token = &quot;{Your refresh token}&quot; -- For refresh local scope = &quot;https://docs.google.com/feeds&quot; local response_type = &quot;code&quot; local access_type = &quot;offline&quot; 5. リフレッシュトークンを使用して再認証 何かをアップロードする前に、サーバーに再認証する必要があるので、まずはgetAuth()関数と一緒に入れてみましょう。本手法では、（必要なパラメータとしての）長さを考えHTTPリクエストを作成し、送信するメッセージを設定します。 「配列」としてレスポンスが来ますが、それは実際にLuaがJSONへデコードすることができない、最初で唯一の大きな文字列です。ですが便利なことに、JSONライブラリを入れる前にテーブルでそれを解析し、新しいアクセストークンを取得するために使用することができます。 関数例: local function getAuth() -- Set our message local mes=&quot;client_id=&quot;..client_id mes=mes..&quot;&amp;client_secret=&quot;..client_secret mes=mes..&quot;&amp;refresh_token=&quot;..refresh_token mes=mes..&quot;&amp;grant_type=refresh_token&quot; local length = string.len(mes) print(&quot;Sending: [&quot;..mes..&quot;]&quot;) print &quot; n&quot; b, c, h = fa.request{ url = &quot;https://accounts.google.com/o/oauth2/token&quot;, headers = { [&quot;Content-Type&quot;] = &quot;application/x-www-form-urlencoded&quot;, [&quot;Content-Length&quot;] = length, }, method = &quot;POST&quot;, body=mes, } local tempTable = {} tempTable = cjson.decode(b) access_token = tempTable[&quot;access_token&quot;] end 6. アップロード用Lua関数 これで新しいアクセストークンを取得して、アップロードの準備が整いました！別のHTTP POSTリクエストでssl.httpsを使用して行います。アップロードするイメージファイルを用意し、認証コードを設定して行います。 例: local function uploadTest(token) filePath=&quot;testfile.jpg&quot; local fileSize = lfs.attributes(filePath,&quot;size&quot;) b, c, h = fa.request{ url = &quot;https://www.googleapis.com/upload/drive/v2/files&quot;, headers = { [&quot;Content-Type&quot;] = &quot;image/jpeg&quot;, [&quot;Content-Length&quot;] = fileSize, -- calculate file size [&quot;authorization&quot;] = &quot;Bearer &quot;..token, [&quot;uploadType&quot;]=&quot;media&quot; }, method = &quot;POST&quot;, --NOTE: You probably want to set your own file here, --or maybe even pass it as a parameter! file=filePath } end ここまでの例を掲載順に組み合わせて最後に以下の２つの関数コードを付け足して実行すれば、Googleドライブへファイルがアップロードされるでしょう（accounts.google.comを参照してください）。 最後に動かす関数コード: getAuth() uploadTest(access_token) 7. 実行結果 サンプルコード リポジトリを見る（GitHub） このサイトのサンプルコードは二条項BSDライセンスで提供されています。",
    "url": "http://localhost:4000/docs/tutorials/lua/9.html",
    "relUrl": "/docs/tutorials/lua/9.html"
  },
  "56": {
    "id": "56",
    "title": "秘匿領域について",
    "content": "秘匿領域について 本チュートリアルでは、FlashAirの秘匿領域にスクリプトを配置し、CONFIGから動作させる方法を解説します。 スクリプトを秘匿領域に保存する 秘匿領域のスクリプトを実行する サンプルコードの使い方 サンプルコード スクリプトを秘匿領域に保存する fa.control(“hid_set_pass”)でパスワードを設定した後、fa.control(“hid_store”)で秘匿領域に保存します。 -- パスワード password=&quot;qwerty&quot; -- 入力ファイル filename_org = { &quot;test.lua&quot; } -- 入力フォルダ foldername = &quot;p:&quot; (中略) fa.control(&quot;hid_clear&quot;) fa.control(&quot;hid_set_pass&quot;, password) -- 秘匿領域へファイルを送る for i,v in ipairs(filename_org) do send_name = foldername..v fa.control(&quot;hid_store&quot;, send_name, password) end 秘匿領域のスクリプトを実行する SD_WLAN/CONFIGに下記のように記述することで秘匿領域のスクリプトを実行することが可能です。 LUA_RUN_SCRIPT=H:filename LUA_SD_EVNET=H:filename サンプルコードの使い方 サンプルコードを使うことで秘匿領域にスクリプトを配置し、CONFIGをセットアップすることが可能です。パスワードと入力ファイル、入力フォルダを設定したsetting.lua、秘匿領域に設置したスクリプトを実行するサンプルとしてtest.luaをFlashAirのルートディレクトリに配置します。 SD_WLAN/CONFIGをコピーし、SD_WLAN/_CONFIGという名前のファイルを作成します。 SD_WLAN/CONFIGに下記を追記し、起動時にスクリプトを実行するように設定します。 LUA_RUN_SCRIPT=setting.lua 秘匿領域に保存されたtest.luaを実行するために、SD_WLAN/_CONFIGを下記のように設定します。 LUA_RUN_SCRIPT=H:test.lua FlashAirを抜き差しすることでスクリプトが秘匿領域に保存されます。test.luaとsetting.lua、SD_WLAN/_CONFIGが削除されていれば問題ありません。10秒程度経過した後、再度FlashAirを抜き差しすることで秘匿領域に保存されたスクリプトが実行されます。 ウェブブラウザからFlashAirに接続するとtest.luaが実行され、ルートフォルダにHello.txtが作成されていることが確認できます。 setting.luaでは、スクリプトを秘匿領域に保存した後、秘匿領域から読み出し、コンペアを行っています。コンペアに失敗した場合はそこでスクリプトが停止します。該当部分のソースコードを示します。 -- 秘匿領域のファイルを読み出してコンペアする for i,v in ipairs(filename_org) do hid_name = hid_drv..v comp_name = foldername..add_name..v org_name = foldername..v -- 秘匿から読み出してコンペアする fa.control(&quot;hid_get&quot;, hid_name, comp_name, password) ret = compfile(org_name, comp_name) -- 内容が間違ってたらそこで止める -- 正しければ、書き込みファイルとコンペアファイルを消す if ret ~= true then print(v..&quot; is hidden write fail...&quot;) break else print(v..&quot; is OK&quot;) -- コンペアファイル削除 fa.remove(comp_name) -- 元ファイル削除 fa.remove(org_name) end end -- CONFIGファイルを削除 fa.remove(&quot;p:SD_WLAN/CONFIG&quot;) -- CONFIGファイルをリネームする fa.rename(&quot;p:SD_WLAN/_CONFIG&quot;, &quot;p:SD_WLAN/CONFIG&quot;) サンプルコード advanced_tutorial_09.zip (4KB) このサイトのサンプルコードは二条項BSDライセンスで提供されています。",
    "url": "http://localhost:4000/docs/tutorials/advanced/9.html",
    "relUrl": "/docs/tutorials/advanced/9.html"
  },
  "57": {
    "id": "57",
    "title": "上級者向けチュートリアル",
    "content": "上級者向けチュートリアル 高度な機能やカスタマイズのためのチュートリアルを紹介しています。 ステーションモードの利用 FlashAirへのアップロード インターネット同時接続モードの利用 FlashAirを使ったセンサーデータの無線モニタリング 複数のFlashAirを同じ無線LANへ接続して利用する FlashAirを再読み込みする FlashAirからAmazon AWSに接続する1（準備編） FlashAirからAmazon AWSに接続する2（実行編） 秘匿領域について FlashAirに書き込まれたcsvファイルをAmazon S3に転送し、さらにデータをDynamoDBに書き込む",
    "url": "http://localhost:4000/docs/tutorials/advanced.html",
    "relUrl": "/docs/tutorials/advanced.html"
  },
  "58": {
    "id": "58",
    "title": "Airio",
    "content": "Airio Airio（えありお）はFlashAir評価ボードです。 概要 FlashAirのGPIO機能を使用して、ブラウザからフルカラーLEDを駆動したり、スイッチの値を取得することが可能です。 AirioをSDカードシールドとして使用することで、FlashAirとArduinoを接続することが可能です。 サポートページ 余熱＠れすぽん http://yone2.net/airio ※取扱説明書、サンプルスクリプト等は上記ページをご確認ください。 購入 Airioは、以下よりご購入いただけます。 マルツエレック http://www.marutsu.co.jp/pc/i/435575/ スイッチサイエンス https://www.switch-science.com/catalog/2241/ 共立エレショップ http://eleshop.jp/shop/g/gG3U124/ 家電のケンちゃん http://kadenken.com/shopdetail/000000000586/ 千石電商 https://www.sengoku.co.jp/mod/sgk_cart/detail.php?code=EEHD-5BPX",
    "url": "http://localhost:4000/docs/resources/airio.html",
    "relUrl": "/docs/resources/airio.html"
  },
  "59": {
    "id": "59",
    "title": "Airio Play",
    "content": "Airio Play FlashAirでゲームを作ろう！ Airio Play（えありおぷれい） はFlashAir のGPIO 機能を使うための基板です。 概要 JavaScript などを利用したHTML ゲームを動作させることが可能です。 方向キーは、斜め押しは効きません。 サポートページ 余熱＠れすぽん http://yone2.net/airio_play ※取扱説明書、サンプルゲーム等は上記ページをご確認ください。 購入 Airio Playは、以下よりご購入いただけます。 家電のケンちゃん http://kadenken.com/shopdetail/000000000587/ 千石電商 https://www.sengoku.co.jp/mod/sgk_cart/detail.php?code=EEHD-5BPY",
    "url": "http://localhost:4000/docs/resources/airioplay.html",
    "relUrl": "/docs/resources/airioplay.html"
  },
  "60": {
    "id": "60",
    "title": "Airio RP",
    "content": "FlashAirプロトタイピングボード「Airio RP」 Airio RP（えありおあーるぴー）はFlashAir でプロトタイピングを行うためのボードです。 特徴 DIP形状 900mil DIP形状でFlashAirの全端子が外ピンに出ており、ブレッドボードを用いて簡単に外部回路と接続することができます。 SPI-I2Cブリッジ IC CP2120 を搭載しており、I2C デバイスと接続することが可能です。スライドスイッチを使い、CP2120の有効/無効を切り替えることができます。 リセットスイッチ・リセット端子 基板上にリセットスイッチがあり、外ピンにリセット端子が出ています。FlashAirを抜き差しせずにリセット可能です。 LEDピン 外ピンの LEDピンをGNDに落とすことで電源を消灯させることが可能です。 FlashAirのピンアサイン ピン SD I/F SPI I/F GPIO Lua SPI 8 DAT1 - 0x04 CS 7 DAT0 DO 0x02 CLK 6 Vss2       5 CLK SCLK - - 4 Vcc       3 Vss1       2 CMD DI 0x01 DO 1 DAT3 CS 0x10 - 9 DAT2 - 0x08 DI 購入 Airio RPは、以下よりご購入いただけます。 マルツエレック http://www.marutsu.co.jp/pc/i/557784/ スイッチサイエンス https://www.switch-science.com/catalog/2373/ 取り扱い説明書をダウンロード (452KB) ダウンロード サンプルHTM FlashAirに接続し、GPIOを操作します。下記のList.htmを/SD_WLAN/ に配置してください。 /SD_WLAN/CONFIG にIFMODE=1 を追記してください。 Airio RPのスライドスイッチは2-3にしてください。 サンプルHTMをダウンロード (3KB) SPI→I2CブリッジIC サンプルスクリプト（GPIO） Airio RPのブリッジICを使いGPIOを動作させます。 FlashAirの/SD_WLAN/CONFIG にIFMODE=1 を追記してください。 Airio RPのスライドスイッチは1-2にしてください。 サンプルスクリプトをダウンロード (0.5KB) SPI→I2CブリッジIC サンプルスクリプト（温度センサ/LCDモジュール） Airio RPのブリッジICを使い温度センサの値をLCDモジュールに表示します。下記の部品表を参考に部品をI2C接続してください。 I2Cの信号線には10kΩ程度のプルアップ抵抗を挿入してください。 FlashAirの/SD_WLAN/CONFIG にIFMODE=1 を追記してください。 Airio RPのスライドスイッチは1-2にしてください。 サンプルスクリプトをダウンロード (5KB) 部品表 名称 参考URL 温度センサ https://www.switch-science.com/catalog/1813/http://www.marutsu.co.jp/pc/i/227596/ LCDモジュール http://akizukidenshi.com/catalog/g/gK-06795/https://www.switch-science.com/catalog/1405/ 注意事項 Airio RPに搭載されているSPI→I2C変換IC CP2120は、起動時にGPIOが入力に設定されています。起動直後にGPIOポートに電流を流さないようにご注意ください。 電源の立ち上がり時間が遅い（1ms超）ときにはCP2120のpower on resetに失敗する場合があります。Airio RPのUSBコネクタを使わず、外部から3.3Vを給電する際にはご注意ください。",
    "url": "http://localhost:4000/docs/resources/airiorp.html",
    "relUrl": "/docs/resources/airiorp.html"
  },
  "61": {
    "id": "61",
    "title": "Android向けチュートリアル",
    "content": "Android向けチュートリアル Androidアプリ開発向けのチュートリアルを紹介しています。",
    "url": "http://localhost:4000/docs/tutorials/android.html",
    "relUrl": "/docs/tutorials/android.html"
  },
  "62": {
    "id": "62",
    "title": "APIガイド",
    "content": "APIガイド FlashAirを外部デバイスから利用するための基本的なAPIを無償で提供しています。",
    "url": "http://localhost:4000/docs/api",
    "relUrl": "/docs/api"
  },
  "63": {
    "id": "63",
    "title": "FlashAirアプリ開発の概要",
    "content": "FlashAirアプリ開発の概要 FlashAirと対応アプリの開発 FlashAirはWebサーバーを内蔵しています。無線LAN親機（アクセスポイント, AP）として動作しているFlashAirに、無線LAN子機（ステーション, STA）として動作しているPCやスマートフォンといった無線LAN機器から接続し、HTTP (HyperText Transfer Protocol) 経由で通信することができます。 HTTPによる制御では、以下のことができます。 Webサーバー FlashAir内のファイルにHTTP GETリクエストを発行することで、ファイルをダウンロードすることができます。また、FlashAirの情報を読み取る、設定を変更するなどの操作が行えるCGI (Common Gateway Interface) が用意されています。 スクリプト Luaスクリプトの実行ができます。 GPIO SD端子のGPIO制御ができます。 その他 SRAMの読み書きができます。 FlashAirとのHTTP通信の種類 無線LANを使ったHTTP通信を用いてFlashAirのデータにアクセスする方法が、Application Programming Interface (API) として定義されています。 ファイルに対するGETコマンド HTTPクライアントがFlashAir内のファイルに対してHTTP GETコマンドを発行すると、FlashAirはそのファイルのデータを返します。 フォルダに対するGETコマンド HTTPクライアントがフォルダに対してHTTP GETコマンドを発行すると、ブラウザユーティリティというWebページを返します。ブラウザユーティリティは、通常そのフォルダのファイル一覧を表示するページですが、変更することができます。詳しくは、APIガイドのブラウザユーティリティを参照してください。 CGI (Common Gateway Interface) 特定のURLに対してHTTP GETコマンドまたはHTTP POSTコマンドを発行すると、FlashAirの情報を読み取る、設定を変更するなどの特別な操作が行えます。以下の4種類があります。 command.cgiFlashAirの情報を取得するためのAPIです。 config.cgiFlashAirの設定を変更するためのAPIです。 thumbnail.cgi画像のサムネイルを取得するためのAPIです。 upload.cgiネットワーク越しにSDメモリカードの中身を変更するためのAPIです。 FlashAirの設定ファイル SDメモリカードホスト機器から参照できる /SD_WLAN/CONFIGというテキストファイルを変更することで、FlashAirの動作を制御することができます。詳細はAPIガイドのCONFIGを参照してください。",
    "url": "http://localhost:4000/docs/discover/app.html",
    "relUrl": "/docs/discover/app.html"
  },
  "64": {
    "id": "64",
    "title": "初心者向け技術ガイド",
    "content": "初心者向け技術ガイド 初心者向け技術ガイド 無線LAN機能とWebサーバーを内蔵するFlashAirは、そのしくみを理解することで、画像だけではなく動画や文書、音声データを取得したり、FlashAir APIを利用して様々な設定のカスタマイズを行ったり、FlashAir対応のアプリを開発したり、既存アプリの機能を拡張したりすることができます。 必要とされる基礎知識 HTTP HTML CSS JavaScript / jQuery CGI 無線LAN Android iOS Lua Arduino HTTP HTTPとは、World Wide Webで用いられるプロトコル（規定）であり、WebサーバーとWebブラウザとが通信する際の様々なコマンドに対する処理を定義しています。 FlashAirはWebサーバーを内蔵していますので、無線LAN上でHTTP経由の通信を行うことができます。 HTTPによる制御については、こちらに紹介されています。 FlashAirアプリ開発の概要 参考 IT用語辞典、Wikipedia HTML HTMLとは、World Wide Web上のドキュメントを作成するために用いられるマークアップ言語です。HTMLは、様々なタグと属性によってWebドキュメントの文書構造やレイアウトなどを定義します。 HTMLを編集することで、WebブラウザでFlashAirコンテンツを見る場合のデザインを変えたり、独自のブラウザユーティリティを作成することができます。 詳しくは、こちらに紹介されています。 ブラウザユーティリティ ウェブブラウザ向けFlashAirアプリ開発の概要 参考 HTMLの基本：HTMLクイックリファレンス WEBレッスンを受ける：HTML入門 CSS CSSとは、どのようなスタイルでWEBページが表示されるかをHTMLに加えて指定するための規格です。HTMLが文書構造を定義するのに対し、CSSは見栄えを定義します。 CSSを編集することで、WebブラウザでFlashAirコンテンツを見る場合のデザインを変えたり、独自のブラウザユーティリティを作成することができます。 詳しくは、こちらに紹介されています。 ブラウザユーティリティ ウェブブラウザ向けFlashAirアプリ開発の概要 参考 CSSの書き方：HTMLクイックリファレンス スタイルシートリファレンス（目的別）：HTMLクイックリファレンス WEBレッスンを受ける：ドットインストール - CSS入門 JavaScript / jQuery JavaScriptとは、Webサイトにインタラクティブなデザインを作成することができるスクリプト言語です。HTMLのソースコードに埋め込んで記述することができ、コンテンツに動的な効果をつけることができます。 参考 IT用語辞典、Wikipedia また、jQueryは、JavaScriptの無料のオープンソースのライブラリーです。jQueryを利用することで、JavaScriptのコード量を減らし、手軽にインタラクティブなデザインを作成することができます。 使用例については、こちらに紹介されています。 コンテンツリストの取得1 参考 jQuery公式ページ（英語） WEBレッスンを受ける：ドットインストール - jQuery入門 CGI CGIプログラムはWebサーバーがユーザーと双方向で動的なやりとりをする方法として一般的です。CGIはWebサーバー上で処理を行います。 FlashAirでは、FlashAirの情報を読み取る、設定を変更するなどの特別な操作が行えるCGI（FlashAir API）をご提供しています。 詳しくは、こちらに紹介されています。 command.cgi：無線LAN経由でFlashAirの情報を取得したり、設定を変更したりできます。 config.cgi：FlashAirの設定を変更するために使います。 thumbnail.cgi：画像のサムネイルを取得するために使います。 upload.cgi：ネットワーク越しにSDメモリカードの中身を変更するために使います。 参考 IT用語辞典、Wikipedia 無線LAN 無線LANとは、無線方式によりデータの送受信を行うLAN（local-area network）の形式です。 FlashAirは、無線LAN機能を内蔵しており、ネットワークに接続する方法には、アクセスポイントモード、ステーションモード、インターネット同時接続モードがあります。通常、FlashAirはアクセスポイント（AP）モードになっており、いわゆる無線LAN親機として動作しています。 詳しくは、こちらに紹介されています。 ステーションモードの利用：FlashAirを無線LAN子機として使うモードです。 インターネット同時接続モードの利用：PCやスマートフォンなどのデバイスからFlashAirを経由して、インターネットなどの別のネットワークと通信することができるモードです。 参考 IT用語辞典、Wikipedia Android Androidとは、グーグル社がライセンスフリーで提供する、携帯情報端末向けのオペレーティングシステムです。 FlashAirデベロッパーズでは、Androidアプリ開発向けのチュートリアルを紹介しています。 Android向けチュートリアル 参考 Android公式ページ、Android Developers - Android 入門 iOS iOSとは、アップル社が提供する、iPhoneやiPad、iPod touch、Apple TVなどの携帯情報端末向けのオペレーティングシステムです。 FlashAirデベロッパーズでは、iOSアプリ開発向けのチュートリアルを紹介しています。 iOS向けチュートリアル 参考 iOS公式ページ、iOS Developers（英語） Lua Luaは、パワフルで、高速で、軽量で、埋め込み可能な、スクリプト言語です。 Lua言語で書かれたスクリプトファイルをFlashAirに保存することで、以下のような簡易なバッチ処理が行えます。 FlashAirに保存されたファイルを、任意のサーバー等にアップロード。（ダイレクトアップロード） FlashAirにファイルを生成する。 動的にHTMLファイルを生成する。 詳しくは、こちらに紹介されています。 Lua機能 参考 Lua公式ページ - Getting started（英語）、Wikipedia Arduino Arduinoは、製品プロトタイピングなどの用途でとても人気のあるマイコンボードです。オープンハードウェアプラットフォームを謳って、設計や回路図が公開されており、ユーザーがクローンを製造したり、改造して独自のArduino互換ボードを作ることが容易です。 FlashAirをSDメモリカードホスト機器から制御して、 無線LANのON/OFFやAPモード・STAモードの切り替え、あるいはHTTP通信をArduinoから行うことができます。 詳しくは、こちらに紹介されています。 ArduinoでFlashAir制御の概要 参考 Arduino 公式ページ（英語）、 Wikipedia",
    "url": "http://localhost:4000/docs/discover/beginners.html",
    "relUrl": "/docs/discover/beginners.html"
  },
  "65": {
    "id": "65",
    "title": "FlashAir Doujinshi (FlashAirの同人誌)",
    "content": "FlashAir Doujinshi (FlashAirの同人誌) FlashAir Doujinshiは、FlashAirの開発やマーケティングに関わる人や社内外サポーターたちが書いた、その名のとおり同人誌です。開発秘話や評価基板のお話、開発チュートリアルから漫画まで、他では読めないコンテンツ満載です。 FlashAir Doujinshi 6 FlashAir Doujinshi 5 FlashAir Doujinshi 4 FlashAir Doujinshi 3 FlashAir Doujinshi 2 FlashAir Doujinshi 1 FlashAir Doujinshi 6 FlashAirの同人誌 6号 発行日: 2019年8月3日 第1版第1刷発行 著者: 高田/伊藤 晋朗/土居/Pochio/じむ/あおいさや/ながしま/余熱/GPS_NMEA_JP/いしかわゆうじ/めむ/寺田 賢司/綾瀬 ヒロ/こたまご a.k.a ひなたん/高橋 祐介/Takehiro Yamaguchi/長船 俊/福屋 新吾/ほげじゅん/高瀬 秀樹/上岡 裕一/エヌ氏/宮内 表紙・本文イラスト: じむ 表紙デザイン: 余熱/ じむ 編集: 余熱 / Pochio / ながしま 発行: FlashAir Developers 目次 ありがとう、FlashAir Developers！ FlashAir Developers was here 大事なことはすべてDevelopers が教えてくれた Maker Faire Tokyo の6年間の戦い 「マイクロSDでも負けません」の巻 帰ってきたFlashAir 活用テクニック fa.pwmを使ってみよう FlashAirが音源チップに? PWM で矩形波を演奏! fa.serialを使ってPomera からプリンタに直接印刷 fa.udpで遊ぼう FlashAirブラウザアプリのAndroid-9 対応 ファイルシステム不整合を回避するUSB-SD リーダの製作 FlashAir + LINEで簡単に写真をシェアしよう!! FlashAirとAzure IoT Central で簡単IoT FlashAirで写真をリアルタイムに表示する 世界初？FlashAir 羽ばたき飛行機！ FlashAirの電波強度レベルを確認しよう FlashAirでFPGA を操れ！ Airio-BaseでMbed OS 5 Mbed de iSDIO FlashAirの進化（AirLapse 編） FlashAirとLuaと自作のツールと 煌めく空との九年史（ノンフィクションとフィクションの間に） 悲しみは思い出とともに FlashAir同人誌の長い編集後記 PDF版をダウンロード (9.5MB) FlashAir Doujinshi 5 FlashAirの同人誌 5号 発行日: 2018年8月4日 第1版第1刷発行 著者: 上岡裕一/伊藤晋朗/Pochio/じむ/福屋新吾/綾瀬ヒロ/Yaasan/南/noitak/高野修一/せいみまさみ/いしかわきょーすけ/矢野均/TakehiroYamaguchi/高田/品川秀司/高瀬秀樹/GPS_NMEA_JP/蒼さや/余熱/宮内 表紙・本文イラスト: じむ/宮内 表紙デザイン: 余熱/じむ 編集: 余熱/Pochio 発行: FlashAir Developers 目次 FlashAir も独立（ひとりだち） 変わる スポンサーからの陥落と2 回目のサミット開催 タミヤ「カム・プログラム・ロボット」をFlashAirで制御してみた ハンズオン@ 大阪とAirio-Base FlashAir とAI スピーカーで鉄道模型を動かそう！ デジタル鉄道模型コントローラ DSair デジカメで撮った写真をVR 空間で閲覧する デジカメ内の画像をHoloLens で表示する 小さなゲームミュージックプレイヤー FlashAir リズムマシン Lua スクリプトとI2C バスでペンプロッタを動かす TOY Board とSensorTag でデータの見える化！ 画像ファイルもFlashAir IoT Hub へ プログラミング不要！ FlashAir のちょっと便利な使い方 FlashAir 用のWindows アプリを組んでみよう！ FlashAir W-03 とW-04 の消費電力と電波強度 FlashAir にシリアル通信機能が付きました FlashTools Lua Editor v1.07b のご紹介 FlashAir 活用テクニック FlashAir 活用テクニック －実践編－ FlashAir ルーレット基板の設計 枯れた技術の水平思考とおまけ基板 PDF版をダウンロード (5.3MB) FlashAir Doujinshi 4 FlashAirの同人誌 4号 発行日: 2017年8月5日 第1版第1刷発行 2017年10月11日 第1版第2刷発行 著者: 上岡裕一/伊藤晋朗/Pochio/じむ/GPS_NMEA/寺西/綾瀬ヒロ/村口/たぞえ/南/寺田賢司/矢野均/大松良司/余熱/Okamiya/TakehiroYamaguchi/高瀬秀樹/野秋拓也/せいみまさみ 表紙・本文イラスト: じむ/宮内 表紙デザイン: 余熱/じむ 編集: 余熱/Pochio 発行: FlashAir Developers 目次 FlashAir 同人誌も 04( ゼロヨン )世代に W-04 の開発にあたり Maker Faire Tokyo とサミットと分社化と FlashAir + e-Paper FlashAir W-04 の進化点 W-04 の新機能 UDP 通信の活用例 新 FlashTools Lua Editor v1.03 のご紹介 新しくなった Lua で自動アップロード FlashAir W-04 のI2C 機能を使おう！ W-04 でも SPI Master FlashAir で WebSocket FlashAir IoT Hub 爆誕 FlashAir IoT Hub を始めよう！！ TOY Board で簡単 IoT をはじめよう！ 冷蔵庫ドアの見守りセンサーを作ろう！ シンプルなリモートカメラから始める FlashAir は IoT の牛丼屋 IoT 完全自立 定点撮影「AirLapse」 FlashAir でスマートロック！ 初心に帰って (?) L チカしよう！ PDF版をダウンロード (5.0MB) FlashAir Doujinshi 3 FlashAirの同人誌 3号 発行日: 2016年8月6日 第1版第1刷発行 著者: 高田真里/じむ/伊藤晋朗/tnk/Pochio/くーら/余熱/だん/Hiro/GPS_NMEA/南/日髙謙太朗/寺田賢司/大阪/清水正行/村口/せいみまさみ/寺西/宮内/綾瀬ヒロ 表紙・本文イラスト: じむ/lxy/くーら 表紙デザイン: 余熱/じむ 編集: 余熱/Pochio 発行: FlashAir Developers 目次 FlashAir 同人誌 3号によせて FlashAir でライブ配信 FlashAir のよもやま話 FlashAir と秋月 Maker Faire Tokyo からニコニコ超会議まで ソラちゃん in 超会議！ 「酔ったー」 と 「TISPY」 クラウドファンディングに向けた製品続々！ FlashAir との出会いと自作ツールのお話 FlashAir IoT Hub FlashAir から Google ドライブへのファイル転送 猫でもできる！見守りシステム FlashAir を使って地図アプリを作成する Lua の SPI 機能でサイドハンドつき SPI Master FlashAir で音楽を鳴らそう ゲームコントローラ基板 Airio Playの設計 FlashAir でゲームを作って、遊ぶ FlashAir ゲームで使える小ネタ 鉄道模型も FlashAir リモコンで！ PDF版をダウンロード (4.8MB) FlashAir Doujinshi 2 FlashAirの同人誌 2号 発行日: 2015年8月1日 第1版第1刷発行 2015年11月7日 第1版第2刷発行 著者: 高田真里/じむ/伊藤晋朗/笠原/ Pochio/GUGEN崔/Julie Watai/土居/寺西/余熱/村口/綾瀬ヒロ/西田ラヂオ/村口/ペンギンキャット/せいみまさみ/Cerevo 押切眞人 表紙イラスト: じむ 表紙デザイン: 余熱/じむ 編集: 余熱 発行: FlashAir Developers 目次 Maker Faire Tokyo2015 出展にあたり FlashAir でゲーム?! FlashAir と Lua FlashAir 年表 Maker Faire Tokyo 初出展とFlashAir ハッカソン FlashAir の新たな可能性をハッカソンから探る！ FlashAir との出会い FlashAir Developers へようこそ FlashAir お悩み相談室 FlashAir を使ったプロトタイプを作ろう！ FlashAir の共有メモリを使い倒せ！ FlashAir のレトロPCへの応用 Lua の PIO 機能でSPI Master FlashAir でホビーロボットをIoT対応に！ ATARI 仕様 Wi-Fiコントローラーの制作 名刺サイズはもう古い!? IoT モジュールの大本命！BlueNinja誕生！ PDF版をダウンロード (4.3MB) お詫びと訂正 本書の以下の部分に誤りがありました。ここに訂正するとともに、ご迷惑をおかけしたことを深くお詫び申し上げます。（2015年11月6日更新） P36 表1 最下段　※ 第1版第2刷(PDF版)にて修正済み 誤 col 1 col 2 col 3 col 4 col 5 col 6 0 DAT2 - 0x08 Green DI 正 col 1 col 2 col 3 col 4 col 5 col 6 9 DAT2 - 0x08 Green DI FlashAir Doujinshi 1 FlashAirの同人誌 1号 発行日: 2014年11月23日 著者: 高田/伊藤/Pochio/余熱/土居/村口/じむ 表紙イラスト: じむ 表紙デザイン: 余熱/じむ 編集: 余熱 発行: FlashAir Developers 目次 Maker Faire Tokyo出展にあたり FlashAirとGPIO OSCで、ソラちゃんと、GPIOができるまで FlashAir 評価基板Airio(えありお)の設計 Arduinoで FlashAirを制御せよ！ FlashAirで無線SPI Master Raspberry PiでFlashAirを動かそう！ PDF版をダウンロード (2.2MB)",
    "url": "http://localhost:4000/docs/books.html",
    "relUrl": "/docs/books.html"
  },
  "66": {
    "id": "66",
    "title": "command.cgi",
    "content": "command.cgi command.cgiを使うと、スマートフォン、PCなどから、 無線LAN経由でFlashAirの情報を取得したり、設定を変更したりできます。 CGI (Common Gateway Interface)という仕組みを利用しており、 FlashAirに接続した状態で、下記のURLにHTTP GETリクエストを発行することでコマンドを実行できます。 http://flashair/command.cgi?&lt;パラメータ&gt; 利用できるコマンドは下記のとおりです。 機能 パラメータ例 ファームウェアバージョン ファイルリストの取得 op=100&amp;DIR=/DCIM 1.00.00+ ファイル数の取得 op=101&amp;DIR=/DCIM 1.00.00+ アップデート情報の取得 op=102 1.00.00+ SSIDの取得 op=104 1.00.00+ ネットワークパスワードの取得 op=105 1.00.00+ MACアドレスの取得 op=106 1.00.00+ ブラウザ言語の取得 op=107 1.00.00+ ファームウェアバージョン情報の取得 op=108 1.00.00+ 制御イメージの取得 op=109 2.00.00+ 無線LANモードの取得 op=110 2.00.00+ 無線LANタイムアウト時間の取得 op=111 2.00.00+ アプリケーション独自情報の取得 op=117 2.00.00+ アップロード機能の有効状態の取得 op=118 2.00.02+ CIDの取得 op=120 1.00.03+ アップデート情報の取得 (タイムスタンプ形式) op=121 2.00.02+ 共有メモリからのデータの取得 op=130&amp;ADDR=0&amp;LEN=8 2.00.00+ 共有メモリへのデータの書き込み op=131&amp;ADDR=0&amp;LEN=8&amp;DATA=0123ABCD 2.00.00+ 空セクター数の取得 op=140 1.00.03+ SDインターフェース端子のI/O利用 op=190&amp;CTRL=0x1f&amp;DATA=0x1f 2.00.03+ フォトシェアモードの有効化 op=200&amp;DIR=/DCIM/100__TSB&amp;DATE=17153 2.00.00+ フォトシェアモードの解除 op=201 2.00.00+ フォトシェアモードの状態の取得 op=202 2.00.00+ フォトシェアモードのSSIDの取得 op=203 2.00.00+ FlashAirドライブ(WebDAV)情報の取得 op=220 3.00.00+ タイムゾーンの取得 op=221 3.00.00+ ファイルリストの取得 (op=100) 指定したディレクトリ内のファイルリストを返します。 リクエスト例: http://flashair/command.cgi?op=100&amp;DIR=/DCIM パラメータ: DIR ディレクトリパス レスポンス例: WLANSD_FILELIST /DCIM,100__TSB,0,16,9944,129 /DCIM,0126_1.jpg,70408,32,17071,28040 レスポンスの各行は下記のフォーマットで返されます。 &lt;directory&gt;, &lt;filename&gt;, &lt;size&gt;, &lt;attribute&gt;, &lt;date&gt;, &lt;time&gt; ファイル名にカンマ(,)を含む場合がありますので、レスポンスを解析する場合はご注意ください。 DIR=/ (root)を指定した場合、ディレクトリ名は空になりますのでご注意ください。 &lt;directory&gt; ファイルのあるディレクトリ名 &lt;filename&gt; ファイル名 &lt;size&gt; ファイルサイズ (数字は10進法) &lt;attribute&gt; ファイルの属性 (数字は10進法) &lt;date&gt; ファイルの日時 (数字は10進法) &lt;time&gt; ファイルの時間 (数字は10進法) Attribute (属性)は下記のフォーマットの16ビット整数を10進数表記で指定します。 ビット 5 アーカイブ ビット 4 ディレクトリ ビット 3 ボリューム ビット 2 システムファイル ビット 1 隠しファイル ビット 0 読み取り専用 Date (日付)は下記のフォーマットの16ビット整数を10進数表記で指定します。 ビット 15-9 年。1980年を0とした値で指定します。 ビット 8-5 月。1～12の値を指定します。 ビット 4-0 日。1～31の値を指定します。 Time (時刻)は下記のフォーマットの16ビット整数を10進数表記で指定します。 ビット 15-11 時 ビット 10-5 分 ビット 4-0 秒/2 この機能は、ファームウェアバージョン1.00.00以上で利用可能です。 ファイル数の取得 (op=101) 指定したディレクトリ内のファイル数を返します。 リクエスト例: http://flashair/command.cgi?op=101&amp;DIR=/DCIM レスポンス例: 2 この機能は、ファームウェアバージョン1.00.00以上で利用可能です。 アップデート情報の取得 (op=102) FlashAirメモリがアップデートされているかどうかを返します。アップデートされている場合は1 、されていない場合は0 を返します。一度呼ばれるとステイタスはクリアされます。 リクエスト例: http://flashair/command.cgi?op=102 レスポンス例: 1 この機能は、ファームウェアバージョン1.00.00以上で利用可能です。 SSIDの取得 (op=104) FlashAirのSSIDを返します。 (最大32文字) リクエスト例: http://flashair/command.cgi?op=104 レスポンス例: flashair_e8e0b756a7fb この機能は、ファームウェアバージョン1.00.00以上で利用可能です。 ネットワークパスワードの取得 (op=105) FlashAirがAPモードに設定されている場合のネットワークキーを、 最大63桁の半角英数字で返します。 ただし、連携デジタルカメラなどのSDメモリカードホスト機器から設定されたネットワークキーは表示されません。 リクエスト例: http://flashair/command.cgi?op=105 レスポンス例: 12345678 この機能は、ファームウェアバージョン1.00.00以上で利用可能です。 MACアドレスの取得 (op=106) リクエストを発行したクライアントのMACアドレスを返します。 リクエスト例: http://flashair/command.cgi?op=106 レスポンス例: a41731f4d880 この機能は、ファームウェアバージョン1.00.00以上で利用可能です。 ブラウザ言語の取得 (op=107) ブラウザの言語設定で利用可能な言語(Accept-Languageパラメータ)を返します。 リクエスト例: http://flashair/command.cgi?op=107 レスポンス例: Accept-Language: ja,en-US;q=0.8,en;q=0.6 この機能は、ファームウェアバージョン1.00.00以上で利用可能です。 ファームウェアバージョン情報の取得 (op=108) FlashAirのファームウェアのバージョンを返します。F24で始まるバージョンはW-01カード用の1.00系列、F19で始まるバージョンはW-02カード用の2.00系列です。 リクエスト例: http://flashair/command.cgi?op=108 レスポンス例: F19BAW3AW2.00.00 この機能は、ファームウェアバージョン1.00.00以上で利用可能です。 制御イメージの取得 (op=109) 無線起動画面として使う画像ファイルのフルパス(CIPATH)を取得します。 無線起動画面とは、無線LANモードが0,2,3のいずれかである場合に、無線LAN機能のON/OFFを制御するための画像ファイルです。 CIPATHについては、CONFIGのCIPATHに関する記述を参照してください。 リクエスト例: http://flashair/command.cgi?op=109 レスポンス例: /DCIM/100__TSB/FA000001.JPG この機能は、ファームウェアバージョン2.00.00以上で利用可能です。 無線LANモードの取得 (op=110) デフォルトの無線LANモード(APPMODE)を返します。APPMODEについては、CONFIGのAPPMODEに関する記述を参照してください。 リクエスト例: http://flashair/command.cgi?op=110 レスポンス例: 4 この機能は、ファームウェアバージョン2.00.00以上で利用可能です。 無線LANタイムアウト時間の取得 (op=111) 無線LANにアクセスがない場合に自動的に電源を切るまでのタイムアウト時間(APPAUTOTIME)をミリ秒単位で返します。 無線LANモードが自動起動APモードに設定されている場合のみ有効です。APPAUTOTIMEについては、CONFIGのAPPAUTOTIMEに関する記述を参照してください。 リクエスト例: http://flashair/command.cgi?op=111 レスポンス例: 300000 この機能は、ファームウェアバージョン2.00.00以上で利用可能です。 アプリケーション独自情報の取得 (op=117) アプリケーションが独自の目的で使用することができる16ケタの英数字(APPINFO)を取得します。APPINFOについては、CONFIGのAPPINFOに関する記述を参照してください。 リクエスト例: http://flashair/command.cgi?op=117 レスポンス例: 0123ABCD4567EFGH この機能は、ファームウェアバージョン2.00.00以上で利用可能です。 アップロード機能の有効状態の取得 (op=118) CONFIGファイルのUPLOADの値を返します。 1 アップロード機能は有効になっています。 それ以外 アップロード機能は無効になっています。 詳しくは、CONFIGのUPLOADに関する記述を参照してください。 リクエスト例: http://flashair/command.cgi?op=118 レスポンス例: 1 この機能は、ファームウェアバージョン2.00.02以上で利用可能です。 Card Identifierの取得 (op=120) CID(Card Identification number register)を返します。CIDは32ケタの16進数で、SDメモリカード仕様により定められています。 APPINFOについては、CIDのCIDに関する記述を参照してください。 リクエスト例: http://flashair/command.cgi?op=120 レスポンス例: 02544d535730384708c00b78700d201 この機能は、ファームウェアバージョン1.00.03以上で利用可能です。 アップデート情報の取得 (タイムスタンプ形式) (op=121) SDメモリカードホスト機器から、FlashAirに対する書き込みイベントが発生した時の内部タイムスタンプを取得します。 タイムスタンプはカードの起動時からの経過ミリ秒です。 リクエスト例: http://flashair/command.cgi?op=121 レスポンス例: 174428 この機能は、ファームウェアバージョン2.00.02以上で利用可能です。 共有メモリからのデータの取得 (op=130) 共有メモリからデータを読み込みます。(SDメモリカード仕様で定められたコマンドCMD48: Read Extension Register Single Block Commandを実行します) リクエスト例: http://flashair/command.cgi?op=130&amp;ADDR=0&amp;LEN=8 パラメータ: ADDR アドレス。0-511 または0x0-0x1FF. LEN 長さ。0-512 または0x0-0x200. レスポンス例: 0123ABCD 成功しなかった場合は、400 Bad Request を返します。 この機能は、ファームウェアバージョン2.00.00以上で利用可能です。 共有メモリへのデータの書き込み (op=131) 共有メモリにデータを書き込みます。(SDメモリカード仕様で定められたコマンドCMD49: Write Extension Register Single Block Commandを実行します) リクエスト例: http://flashair/command.cgi?op=131&amp;ADDR=0&amp;LEN=8&amp;DATA=0123ABCD パラメータ: ADDR アドレス。0-511 または0x0-0x1FF. LEN 長さ。0-512 または0x0-0x200. DATA 書きこむデータ。データの長さははLENと同じでなければなりません。 レスポンス: 成功した場合は、SUCCESS を返します。成功しなかった場合は、400 Bad Request を返します。 この機能は、ファームウェアバージョン2.00.00以上で利用可能です。 空セクター数の取得 (op=140) FlashAirカードの空き容量を、空セクタ数/全セクタ数,セクタサイズ(バイト)の形式で返します。 リクエスト例: http://flashair/command.cgi?op=140 レスポンス例: 13952920/15228928,512 この例では、セクタあたり512バイトで、カード全体では15228928個のセクタがあり、 13952920個のセクタが未使用であることを示しています。 つまり、総容量7.26GB(8GBカード)のうち、約6.7GB残っているということがわかります。 この機能は、ファームウェアバージョン1.00.03以上で利用可能です。 SDインターフェース端子のI/O利用 (op=190) SDインターフェイス端子を、汎用のI/O信号端子として利用し、 信号の読み書きを行うことができます。 この機能を利用するためには以下の条件を満たしている必要があります。 CONFIGファイルにIFMODE=1と記載されている。 SDメモリカードスロットに挿入されていない（SDメモリカードホスト機器からのSD初期化が無い）。IFMODEについては、CONFIGのIFMODEに関する記述を参照してください。 リクエスト例: http://flashair/command.cgi?op=190&amp;CTRL=0x1f&amp;DATA=0x1f パラメータ: CTRL 読み込みか書き込みかを指定します。 読み込みたい端子に対応するビットに0を、 書き込みたい端子に対応するビットに1を指定します。 DATA 出力値の設定です。 書き込みたい端子に対応する各ビットに、0を設定するとLow、1を設定するとHighを出力します。 ビット割当 CMD : 0x01 D0 : 0x02 D1 : 0x04 D2 : 0x08 D3 : 0x10 レスポンス例: 現在の、読み書き設定および信号の値を取得できます。 {&quot;STATUS&quot;:&quot;OK&quot;,&quot;CTRL&quot;:&quot;0x00&quot;, &quot;DATA&quot;:&quot;0x00&quot;} この機能は、ファームウェアバージョン2.00.03以上で利用可能です。 フォトシェアモードの有効化 (op=200) フォトシェアモードを有効化します。フォトシェアモードは、指定されたディレクトリと日付のみにアクセスできるようにするために使われます。 フォトシェアモードを有効にすると、 それ以降のHTTP GET要求およびcommand.cgiに対するディレクトリ指定は無視され、フォトシェアモードで指定したディレクトリと日付のデータが常に返されるようになります。 リクエスト例: http://flashair/command.cgi?op=200&amp;DIR=/DCIM/100__TSB&amp;DATE=17153 パラメータの詳細は、ファイルリストの取得を参照してください。 レスポンス: 成功した場合は、OK を返します。 成功しなかった場合は、400 Bad Request を返します。 この機能は、ファームウェアバージョン2.00.00以上で利用可能です。 注意: op=200を使用してフォトシェアモードを有効にした場合、SSIDとネットワークセキュリティキーは、既に設定してある内容から変更されません。 ネットワークセキュリティキーを変更する場合には、config.cgiのネットワークセキュリティキーの設定を使用して、ネットワークセキュリティキーを変更してください。 また、SSIDを変更する場合は、config.cgiのSSIDの設定を使用して、SSIDを変更してください。 フォトシェアモードの解除 (op=201) フォトシェアモードを解除します。フォトシェアモードは、指定されたディレクトリと日付のみにアクセスできるようにするために使われます。 リクエスト例: http://flashair/command.cgi?op=201 レスポンス: 成功した場合は、OK を返します。成功しなかった場合は、400 Bad Request を返します。 この機能は、ファームウェアバージョン2.00.00以上で利用可能です。 フォトシェアモードの状態の取得 (op=202) フォトシェアモードが有効か無効かを返します。 リクエスト例: http://flashair/command.cgi?op=202 レスポンス例: SHAREMODE フォトシェアモードが有効な場合はSHAREMODE を返します。フォトシェアモードが無効の場合は、NORMALMODE を返します。 この機能は、ファームウェアバージョン2.00.00以上で利用可能です。 フォトシェアモードのSSIDの取得 (op=203) フォトシェアモードに使用する特別なSSIDを返します。 リクエスト例: http://flashair/command.cgi?op=203 レスポンス例: photoshare_e8e0b756a7fb この機能は、ファームウェアバージョン2.00.00以上で利用可能です。 FlashAirドライブ(WebDAV)情報の取得 (op=220) FlashAirドライブが有効か無効かを返します。 0 FlashAirドライブ機能無効 1 FlashAirドライブ機能有効（リードオンリーモード） 2 FlashAirドライブ機能有効。書き込みを有効にするには、CONFIGファイルにUPLOAD=1を設定する必要があります。 リクエスト例: http://flashair/command.cgi?op=220 レスポンス例: 1 この機能は、ファームウェアバージョン3.00.00以上で利用可能です。 タイムゾーンの取得 (op=221) FlashAirドライブ(WebDAV)動作時に、FATファイル時間からUTC時間へ変換するためのタイムゾーンの値を、15分を1とした単位で-48から+54の範囲で返します。 日本は、UTC標準時を0とし、9時間進めたUTC+9であるため、36(9(h)×4(15m)=36)を設定します。 リクエスト例: http://flashair/command.cgi?op=221 レスポンス例: 36 この機能は、ファームウェアバージョン3.00.00以上で利用可能です。",
    "url": "http://localhost:4000/docs/api/command.cgi.html",
    "relUrl": "/docs/api/command.cgi.html"
  },
  "67": {
    "id": "67",
    "title": "共通コマンド",
    "content": "共通コマンド コマンドID コマンド名 機能 0011h SetCurrentTime(currentDate, currentTime) 現在時刻の設定 0012h Abort(sequenceID) 特定のiSDIOコマンドの実行を停止 0013h ReadResponse(sequenceID) レスポンスデータの読み取り 0014h SetPowerSaveMode(powerMode) パワーセーブモードの設定（オン/オフ） 0015h SetChannel(channelNum) APモードで使用する無線チャネルの設定 SetCurrentTime(currentDate, currentTime) FlashAirに現在時刻を設定するためのホストリクエストです。FlashAirの内部の時計の数字からカウントが始まります。時刻を設定、修正、アクセスしたときに、ファイルやディレクトリにタイムスタンプが設定されます。 コマンドID 0011h 引数 Name Type Size Description 現在時刻 integer (little endian) 2バイト currentDateはFlashAirに設定する時刻です。フォーマットは以下のとおりです。 Bits 0 to 4: 日の設定、有効な数値は1～31 Bits 5 to 8: 月の設定、有効な数値は1～12 Bits 9 to 15: 年の設定、有効な数値は0～127（1980～2107） 現在時刻 integer (little endian) 2バイト currentDateはFlashAirに設定する時刻です。フォーマットは以下のとおりです。 Bits 0 to 4: 秒の設定（2秒？）、有効な数値は0～29(0～58秒) 2-second count Bits 5 to 10: 分の設定、有効な数値は0～59 Bits 11 to 15: 時の設定、有効な数値は0～23、設定可能な時刻は深夜00:00:00～23:59:58 レスポンス 無し Abort(sequenceID) 特定のiSDIOコマンドの実行を停止するためのホストリクエストです。FlashAirがこのコマンドを受信すると、現在プロセス中のコマンドは発行されていないものとみなして動作します。しかし、NANDメモリーモジュールの中にファイルを作るコマンド（”SendHTTPMessageByFile”、”SendHTTPFileByFile”、”SendHTTPSSLMessageByFile”、”SendHTTPSSLFileByFile”、”DLNA_AcceptUpload”、”GetFile” and “PTP_ReceiveFile”など）があっても、FlashAirはプロセスが完全に終わっていなくてもファイルを除く必要はありません。これは、FlashAirがすべてのデータを保存しているとは限らないということです。そのためプロセス中断後、ホストは完了していないファイルを適切に処理します。さらに、FlashAirはファイルアロケーションテーブル、ディレクトリーエントリーなどのファイルシステムのメタデータを継続的に維持します。このコマンドは、受信された場合、現在のプロセス中のコマンドより先に実行されます。このコマンドのためのCommand Response Status はCommand Response Status Queue に登録されません。しかし、中断したコマンドのCommand Response Statusは”04h: Process Terminated”に変換されます。つまり、このコマンドが発行されていても、いずれのコマンドのステータスはキューにから除かれないということです。例えば、複数のコマンドがプロセス中で、そのうちの一つが中断されたとき、他のコマンドは影響を受けずプロセスを継続します。 コマンドが発行されたタイミングによって、このコマンドは無視され、中断されたターゲットコマンドはプロセスを完了します。ターゲットコマンドのコマンドレスポンスステータスは”03h: Process Succeeded”または “80h to FFh: Process Failed”になります。この場合も “Abort”コマンドのプロセス時間は変わりません。 無線LAN接続の終了またはPeer-to-Peer File Transferアプリケーションの終了には、”Disconnect”コマンドを使用することが推奨されています。 コマンドID 0012h 引数 Name Type Size 説明 sequenceID integer 4-byte sequenceIDは、コマンド発行時ホストによって特定された、コマンドのiSDIOコマンドシークエンスIDを意味します。値は “00 00 00 00h”から”FF FFFF FFh”となります。 レスポンス 無し ReadResponse(sequenceID) 指定のiSDIOコマンドシークエンスIDによって発行されたコマンドに対応して、レスポンスデータを読み取るためのホストリクエストです。レスポンスデータは、バッファオーバーフローでない限り、Response Data Register Portから取得可能です。このコマンドは特定のコマンドが完了しCommand Response Status Queueにあるときにのみ有効です。さらに、このコマンドのプロセスは、現在プロセス中のコマンドより優先され、このコマンドのコマンドレスポンスステータスはCommand Response Status Queueに登録されません。つまり、このコマンドが発行されても、いずれのコマンドステータスもキューから除かれることはありません。 コマンドID 0013h 引数 Name Type Size 説明 sequenceID integer 4-byte sequenceIDは、コマンド発行時ホストによって特定された、コマンドのiSDIOコマンドシークエンスIDを意味します。値は “00 00 00 00h”から”FF FFFF FFh”となります。 レスポンス レスポンスデータは特定のiSDIOコマンドによります。(2.2.2.3 iSDIO Command Response Data in [iSDIO]を参照してください)。 Command Response Status Queueにある最初のコマンドにおいて、コマンドレスポンスステータス#1のレスポンスデータはResponse Data Register Portにデフォルトでマップされます。また#2～8のコマンドレスポンスステータスについては、このコマンドは特定のレスポンスデータがResponse Register Portにマップされるよう発行されます。（もしホストがCommand Write DataにあるひとつのiSDIOコマンドを、キューのプロセス無しで発行した場合、ホストはこのコマンドを使う必要がなくなります。）このコマンドはResponse DataをCommand Response Status #1にマップするために発行されることが可能です。 さらに、現在のレスポンスデータの読み込みが完了する前に、このコマンドが発行された場合でも、新しいレスポンスデータはデータの最初から読み取りが可能です。つまり、同じコマンドのうち、一つがこのコマンドによって特定され、現在のレスポンスデータの読み込みが完了する前でも、レスポンスデータは最初から読み取りが可能です。 SetPowerSaveMode(powerMode) FlashAirのパワーセーブモードを変更するためのホストリクエストです。モードがオンのとき、FlashAirはパワーセーブモードで機能します。（パワーセービングの認識はFlashAir実行によります。データ移行など他の動作が行われていた場合はFlashAirによってはこのモードが低くなります。） コマンドID 0014h 引数 Name Type Size 説明 パワーモード integer 1-byte powerModeはパワーセーブモードを意味します。 00h パワーセーブモード Off 01h パワーセーブモード On &lt;section&gt; ### レスポンス 無し &lt;/section&gt; &lt;/section&gt; ## SetChannel(channelNum) FlashAirのAPにチャンネルを設定するためのホストリクエストです。FlashAirが一部のチャンネルをサポートしていない場合、このコマンドは拒否されます。ホストはCapability Registerの&quot;Channel Support&quot;を確認する必要があります。iSDIO Capability Register for Wireless LANを参照してください。 ### コマンドID 0015h ### 引数 Name | Type | Size | 説明 | | -- | -- チャンネル番号 | integer | 1-byte | `channelNum`はチャンネルの番号を意味します。 00h チャンネル番号は自動的に設定されます。 01h チャンネル 1 …​ 0Eh チャンネル 14 24h チャンネル 36 …​ A1h チャンネル 161 ### レスポンス 無し",
    "url": "http://localhost:4000/docs/api/reference/common.html",
    "relUrl": "/docs/api/reference/common.html"
  },
  "68": {
    "id": "68",
    "title": "config.cgi",
    "content": "config.cgi config.cgiは、FlashAirの設定を変更するために使います。変更にはMASTERCODEが必要です。複数の項目を同時に変更できます。 パラメータ名 説明 パラメータ例 ファームウェアバージョン APPAUTOTIME 接続タイムアウト時間の設定 APPAUTOTIME=3000000 2.00.00+ APPINFO アプリケーション独自情報の設定 APPINFO=0123ABCD4567EFGH 1.00.00+ APPMODE 無線LANモードの設定 APPMODE=4 1.00.00+ APPNETWORKKEY ネットワークセキュリティキーの設定 APPNETWORKKEY=12345678 1.00.00+ APPSSID SSIDの設定 APPSSID=flashair 1.00.00+ BRGNETWORKKEY インターネット同時接続用ネットワークセキュリティキーの設定 BRGNETWORKKEY=12345678 2.00.02+ BRGSSID インターネット同時接続用ネットワークSSIDの設定 BRGSSID=myhomelan 2.00.02+ CIPATH WiFi起動画面パスの設定 CIPATH=/DCIM/100__TSB/FA000001.jpg 1.00.00+ CLEARCODE マスターコードの削除 CLEARCODE=1 3.00.00+ MASTERCODE マスターコードの設定 MASTERCODE=0123456789AB 1.00.00+ TIMEZONE タイムゾーンの設定 TIMEZONE=36 3.00.00+ WEBDAV FlashAirドライブ(WebDAV)の設定 WEBDAV=1 3.00.00+ 接続タイムアウト時間の設定 APPAUTOTIME 無線LAN機能の自動タイムアウト時間を設定します。単位はミリ秒です。 設定可能な値は、60000から4294967294で、デフォルト値は300000です。 0を指定すると自動停止しない設定になります。ただし、SDメモリカードホスト機器のスリープでカードへの電源供給が遮断された場合などに、停止することがあります。 設定された値はCONFIGファイルのAPPAUTOTIME パラメータに保存されます。 設定に成功するとSUCCESS 、失敗するとERROR が返ります。 リクエスト例: http://flashair/config.cgi?MASTERCODE=0123456789AB&amp;APPAUTOTIME=3000000&amp;APPMODE=4 アプリケーション独自情報の設定 APPINFO アプリケーションが独自で使用する情報を、16ケタの英数字で保存することができます。 一番新しく設定された値がCONFIGファイルのAPPINFOパラメータに保存されます。 設定に成功するとSUCCESS 、失敗するとERROR が返ります。 リクエスト例: http://flashair/config.cgi?MASTERCODE=0123456789AB&amp;APPINFO=0123ABCD4567EFGH 無線LANモードの設定 APPMODE 無線LANの動作モードを設定します。以下のモードがあります。 0 「無線起動画面」のライトプロテクト解除操作で無線LAN機能を起動します。無線LANモードはAPモードです。 2 「無線起動画面」のライトプロテクト解除操作で無線LAN機能を起動します。無線LANモードはSTAモードです。 3 「無線起動画面」のライトプロテクト解除操作で無線LAN機能を起動します。無線LANモードはインターネット同時接続モードです。 (ファームウェア 2.00.02以上) 4 カード電源投入時に無線LAN機能を起動します。無線LANモードはAPモードです。 5 カード電源投入時に無線LAN機能を起動します。無線LANモードはSTAモードです。 6 カード電源投入時に無線LAN機能を起動します。無線LANモードはインターネット同時接続モードです。 (ファームウェア 2.00.02以上) その他 未定義です。指定しないでください。 APモード、STAモード、インターネット同時接続モードについては、CONFIGファイルの説明をご覧ください。 一番新しく設定された値がCONFIGファイルのAPPMODEパラメータに保存されます。 設定に成功するとSUCCESS 、失敗するとERROR が返ります。 リクエスト例: http://flashair/config.cgi?MASTERCODE=0123456789AB&amp;APPMODE=4 ネットワークセキュリティキーの設定 APPNETWORKKEY 0-63文字の英数字でのネットワークセキュリティキーを設定します。 無線LANのセキュリティ機能を有効にするためには最低8文字が必要です。 一番新しく設定された値がCONFIGファイルのAPPNETWORKKEYパラメータに保存されます。 設定に成功するとSUCCESS 、失敗するとERROR が返ります。 リクエスト例: http://flashair/config.cgi?MASTERCODE=0123456789AB&amp;APPNETWORKKEY=12345678 SSIDの設定 APPSSID 無線LAN識別子(SSID)を、1-32文字の英数字で設定します。 一番新しく設定された値がCONFIGファイルのAPPSSIDパラメータに保存されます。 設定に成功するとSUCCESS 、失敗するとERROR が返ります。 リクエスト例: http://flashair/config.cgi?MASTERCODE=0123456789AB&amp;APPSSID=flashair インターネット同時接続モード用ネットワークセキュリティキーの設定 BRGNETWORKKEY インターネット同時接続モードで使用するインターネット側ネットワークの セキュリティキーを0-63文字の英数字で設定します。 一番新しく設定された値がCONFIGファイルのBRGNETWORKKEYパラメータに保存されます。 設定に成功するとSUCCESS 、失敗するとERROR が返ります。 リクエスト例: http://flashair/config.cgi?MASTERCODE=0123456789AB&amp;BRGNETWORKKEY=12345678 インターネット同時接続モード用ネットワークSSIDの設定 BRGSSID インターネット同時接続モードで使用するインターネット側ネットワークの 無線LAN識別子(SSID)を、1-32文字の英数字で設定します。 一番新しく設定された値がCONFIGファイルのBRGSSIDパラメータに保存されます。 設定に成功するとSUCCESS 、失敗するとERROR が返ります。 リクエスト例: http://flashair/config.cgi?MASTERCODE=0123456789AB&amp;BRGSSID=myhomelan 無線起動画面のパス設定 CIPATH 無線起動画面として使う画像ファイルのフルパスを設定します。 無線起動画面とは、無線LANモード(APPMODE)が0,2,3のいずれかである場合に、無線LAN機能のON/OFFを制御するための画像ファイルです。 一番新しく設定された値がCONFIGファイルのCIPATHパラメータに保存されます。 設定に成功するとSUCCESS 、失敗するとERROR が返ります。 リクエスト例: http://flashair/config.cgi?MASTERCODE=0123456789AB&amp;CIPATH=/DCIM/100__TSB/FA000001.jpg マスターコードの削除 CLEARCODE マスターコードをリセットします。CONFIGファイルのMASTERCODEが削除され、同時にLOCK=1も削除されます。 設定に成功するとSUCCESS 、失敗するとERROR が返ります。 リクエスト例: http://flashair/config.cgi?MASTERCODE=0123456789AB&amp;CLEARCODE=1 マスターコードの設定 MASTERCODE マスターコードは、SSID(APPSSID)やネットワークキー(APPNETWORKKEY)の設定の際のパスワードとして使われる12ケタの16進数の数字です。値が設定済みのマスターコードと一致した場合は、同時に指定されたその他の設定をCONFIGファイルの対応するパラメータに保存します。マスターコードが設定されていない場合は、設定された値がCONFIGファイルのMASTERCODEパラメータに保存され、同時にLOCK=1も設定されます。 設定に成功するとSUCCESS 、失敗するとERROR が返ります。 リクエスト例: http://flashair/config.cgi?MASTERCODE=0123456789AB タイムゾーンの設定 TIMEZONE FlashAirドライブ(WebDAV)動作時に、FATファイル時間からUTC時間へ変換するためのタイムゾーンを設定します。 15分単位を1として-48から54の数字で設定します。 日本は、UTC標準時を0とし、9時間進めたUTC+9であるため、36(9(h)×4(15m)=36)を設定します。 一番新しく設定された値がCONFIGファイルのTIMEZONEパラメータに保存されます。 設定に成功するとSUCCESS 、失敗するとERROR が返ります。 リクエスト例: http://flashair/config.cgi?MASTERCODE=0123456789AB&amp;TIMEZONE=36 FlashAirドライブ(WebDAV)の設定 WEBDAV FlashAirドライブ機能を有効にするかどうかを指定します。次の値のいずれかを指定します。 0 FlashAirドライブ機能無効 1 FlashAirドライブ機能有効（リードオンリーモード） 2 FlashAirドライブ機能有効。書き込みを有効にするには、CONFIGファイルにUPLOAD=1を設定する必要があります。 一番新しく設定された値がCONFIGファイルのWEBDAVパラメータに保存されます。 設定に成功するとSUCCESS 、失敗するとERROR が返ります。 リクエスト例: http://flashair/config.cgi?MASTERCODE=0123456789AB&amp;WEBDAV=1",
    "url": "http://localhost:4000/docs/api/config.cgi.html",
    "relUrl": "/docs/api/config.cgi.html"
  },
  "69": {
    "id": "69",
    "title": "CONFIG",
    "content": "CONFIG /SD_WLAN/CONFIGを変更することで、FlashAirの動作を制御することができます。変更した設定を反映するには、FlashAirを一旦取り外して再挿入するなどして再起動する必要があります。このフォルダは隠しフォルダとなっていますので、隠しフォルダを扱う事が出来るツールを使いましょう。なお、config.cgiによる設定変更を行った場合は、本ファイルにすぐに反映されないことがあります。FlashAirを再起動してから、本ファイルを変更してください。CONFIGの記載方法については CONFIG記載例 を参照してください。 なお、”;” 以降はコメントアウトの扱いになります。 WLANSD Vendor WLANSD 本セクションの設定により、iSDIO機器共通のWireless LANに関する動作を制御することができます。iSDIOの仕様については SD Associationを参照してください。 パラメータ名 説明 例 ファームウェアバージョン ID ID ID=SMITH’S_CARD 1.00.00+ DHCP_Enabled DHCPクライアントの有効化 DHCP_Enabled=YES 1.00.00+ IP_Address IPアドレス IP_Address=192.168.0.10 1.00.00+ Subnet_Mask サブネットマスク Subnet_Mask=255.255.255.0 1.00.00+ Default_Gateway デフォルトゲートウェイ Default_Gateway=192.168.0.1 1.00.00+ Preferred_DNS_Server 優先DNSサーバ Preferred_DNS_Server=192.168.0.1 1.00.00+ Alternate_DNS_Server 代替DNSサーバ Alternate_DNS_Server=192.168.0.1 1.00.00+ Proxy_Server_Enabled プロキシサーバの有効化 Proxy_Server_Enabled=YES 1.00.00+ Proxy_Server_Name プロキシサーバ Proxy_Server_Name=yourproxy.comProxy_Server_Name=123.123.0.1 1.00.00+ Port_Number プロキシサーバのポート番号 Port_Number=8080 1.00.00+ Vendor 本セクションの設定により、FlashAir固有の動作を制御することができます。 パラメータ名 説明 例 ファームウェアバージョン APPAUTOTIME 接続タイムアウト時間 APPAUTOTIME=3000000 1.00.00+ APPCH APモードで使用する無線チャネルの設定 APPCH=1 4.00.04+ APPINFO アプリケーション独自情報 APPINFO=0123ABCD4567EFGH 1.00.00+ APPMODE 無線LANモード APPMODE=4 1.00.00+ APPNAME NETBIOS, Bonjour名称 APPNAME=myflashair 1.00.00+ APPNETWORKKEY ネットワークセキュリティーキー APPNETWORKKEY=12345678 1.00.00+ APPSSID SSID APPSSID=flashair 1.00.00+ BRGNETWORKKEY インターネット同時接続用ネットワークセキュリティキー BRGNETWORKKEY=12345678 2.00.02+ BRGSSID インターネット同時接続用ネットワークSSID BRGSSID=myhomelan 2.00.02+ CID カードID CID=02544d53573038470750002a0200c201 1.00.00+ CIPATH 無線起動画面のパス CIPATH=/DCIM/100__TSB/FA000001.jpg 1.00.00+ COMMANDCGI command.cgiの有効opcodeを指定 COMMANDCGI=100-103 3.00.00+ DELCGI CGI の無効化 DELCGI=/,/thumbnail.cgi 2.00.02+ DHCPC_RETRANS_MAX DHCPクライアントの再送回数 DHCPC_RETRANS_MAX=5 4.00.03+ DNSMODE DNS動作モード DNSMODE=1 2.00.02+ EAPCERT TLS証明書のファイルパス EAPCERT=/cert.pfx 4.00.03+ EAPPASSWORD PEAPパスワードまたはTLS秘密キーパスワード EAPPASSWORD=12345678 4.00.03+ EAPTYPE 暗号化の規格 EAPTYPE=TLS 4.00.03+ EAPUSER EAPTYPEが指定された場合に利用するユーザーID EAPUSER=SMITH 4.00.03+ HTTPDBUFF メモリサイズ HTTPDBUFF=2920 2.00.03+ HTTPDMODE 認証方法 HTTPDMODE=1 1.00.04+ HTTPDPASS Basic認証のパスワード、Digest認証のハッシュ値 HTTPDPASS=12345678 1.00.04+ HTTPDUSER Basic認証のユーザ名 HTTPDUSER=flashair 1.00.04+ IFMODE SDインターフェース端子のI/O利用機能の有効化 IFMODE=1 2.00.03+ LOCK 初期設定済みフラグ LOCK=1 1.00.00+ LUA_RUN_SCRIPT 起動時に実行するLuaスクリプトのパス LUA_RUN_SCRIPT=/bootscript.lua 3.00.00+ LUA_SD_EVENT ファイル書き込み時に実行するLuaスクリプトのパス LUA_SD_EVENT=/writescript.lua 3.00.00+ MASTERCODE マスターコード MASTERCODE=0123456789AB 1.00.00+ NOISE_CANCEL ノイズキャンセル NOISE_CANCEL=2 2.00.03+ PRODUCT 製品コード PRODUCT=FlashAir 1.00.00+ REDIRECT HTTPリダイレクトモード REDIRECT=1 2.00.03+ STAMAC STAモードでのアドレスフィルタリング機能 STAMAC=40b395A0851a 2.00.02+ STANUM STAモードでの接続台数制限機能 STANUM=2 2.00.02+ STA_RETRY_CT STAモードでの接続リトライ回数 STA_RETRY_CT=0 3.00.00+ TIMEZONE タイムゾーン TIMEZONE=36 3.00.00+ UPDIR アップロード先ディレクトリの指定 UPDIR=/DCIM 2.00.03+ UPLOAD アップロード機能の有効化 UPLOAD=1 1.00.00+ VENDOR ベンダーコード VENDOR=TOSHIBA 1.00.00+ VERSION ファームウェアバージョン VERSION=F24A6W3AW1.00.03 1.00.00+ WEBDAV FlashAirドライブ(WebDAV)機能の有効化 WEBDAV=0 3.00.00+ WLANAPMODE 無線LAN規格 WLANAPMODE=0x03 3.00.00+ CONFIG記載例 [WLANSD] ID=SMITH’S_CARD DHCP_Enabled=YES IP_Address= Subnet_Mask= Default_Gateway= Preferred_DNS_Server= Alternate_DNS_Server= Proxy_Server_Enabled=YES Proxy_Server_Name=yourproxy.com Port_Number=8080 [Vendor] CIPATH=/DCIM/100__TSB/FA000001.JPG APPMODE=4 APPNETWORKKEY=******** VERSION=FA9CAW3AW3.00.00 CID=XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX PRODUCT=FlashAir VENDOR=TOSHIBA ID IDを指定します。ASCII文字で16文字まで指定できます。デフォルトは空です。 例: ID=SMITH’S_CARD DHCPクライアントの有効化 (DHCP_Enabled) DHCPクライアントを有効にするかどうかを指定します。次の値のいずれかを指定します。 YES(デフォルト) DHCPクライアント有効 NO DHCPクライアント無効 例: DHCP_Enabled=YES IPアドレス (IP_Address) DHCPクライアントが無効になっている場合、IPアドレスを指定します。デフォルト値は”0.0.0.0”です。”DHCP_Enabled=YES”の場合、指定した値は無視されます。 例: IP_Address=192.168.0.10 サブネットマスク (Subnet_Mask) DHCPクライアントが無効になっている場合、サブネットマスクを指定します。デフォルト値は”0.0.0.0”です。”DHCP_Enabled=YES”の場合、指定した値は無視されます。 例: Subnet_Mask=255.255.255.0 デフォルトゲートウェイ (Default_Gateway) DHCPクライアントが無効になっている場合、デフォルトゲートウェイを指定します。デフォルト値は”0.0.0.0”です。”DHCP_Enabled=YES”の場合、指定した値は無視されます。 例: Default_Gateway=192.168.0.1 優先DNSサーバ (Preferred_DNS_Server) DHCPクライアントが無効になっている場合、優先DNSサーバを指定します。デフォルト値は”0.0.0.0”です。”DHCP_Enabled=YES”の場合、指定した値は無視されます。 例: Preferred_DNS_Server=192.168.0.1 代替DNSサーバ (Alternate_DNS_Server) DHCPクライアントが無効になっている場合、代替DNSサーバを指定します。デフォルト値は”0.0.0.0”です。”DHCP_Enabled=YES”の場合、指定した値は無視されます。 例: Alternate_DNS_Server=192.168.0.1 プロキシサーバの有効化 (Proxy_Server_Enabled) プロキシサーバを有効にするかどうかを指定します。次の値のいずれかを指定します。 YES プロキシサーバ有効 NO(デフォルト) プロキシサーバ無効 例: Proxy_Server_Enabled=YES プロキシサーバ (Proxy_Server_Name) プロキシサーバのドメイン名、又はIPアドレスを指定します。デフォルト値は空です。”Proxy_Server_Enabled=NO”の場合、指定した値は無視されます。 例: Proxy_Server_Name=yourproxy.com Proxy_Server_Name=123.123.0.1 プロキシサーバのポート番号 (Port_Number) プロキシサーバのポート番号を指定します。デフォルト値は”8080”です。”Proxy_Server_Enabled=NO”の場合、指定した値は無視されます。 例: Port_Number=8080 接続タイムアウト時間 (APPAUTOTIME) 無線LAN機能の自動タイムアウト時間を設定します。無線LANの動作モードが4の場合に、他の端末から本パラメータで指定された時間接続がなければ無線LAN機能を停止します。設定可能な値は、60000から4294967294で、デフォルト値は300000です。単位はミリ秒です。 0を指定すると自動停止しない設定になります。ただし、SDメモリカードホスト機器のスリープでカードへの電源供給が遮断された場合などに、停止することがあります。 APPAUTOTIMEが有効となるのは、APPMODEがAPの場合のみとなります。STA、BRG時にAPPAUTOTIMEで設定した時間でタイムアウトになることはありません。 例: APPAUTOTIME=3000000 APモードで使用する無線チャネルの設定 (APPCH) FlashAirが無線LAN親機となるモードの際に使用する無線チャネルを設定します。 設定可能な値は、0 から 11 です。 1～11を指定した場合は、指定した値に無線チャネルが固定されます。0を指定した場合は、無線チャネルは固定されず、FlashAirが自動で決定します。デフォルト値は0となります。 ※インターネット同時接続モードにおけるAPモードで使用する無線チャネルには反映されません。 例: APPCH=1 アプリケーション独自情報 (APPINFO) アプリケーションが独自で使用する情報を、1-16ケタの英数字で保存することができます。 例: APPINFO=0123ABCD4567EFGH 無線LANモード (APPMODE) 無線LANの動作モードを設定します。以下のモードがあります。 0 手動起動モードで無線LAN機能を起動します。無線LANモードはAPモードです。 2 手動起動モードで無線LAN機能を起動します。無線LANモードはSTAモードです。 3 手動起動モードで無線LAN機能を起動します。無線LANモードはインターネット同時接続モードです。 (ファームウェア 2.00.02以上) 4 自動起動モードで無線LAN機能を起動します。無線LANモードはAPモードです。 5 自動起動モードで無線LAN機能を起動します。無線LANモードはSTAモードです。 6 自動起動モードで無線LAN機能を起動します。無線LANモードはインターネット同時接続モードです。 (ファームウェア 2.00.02以上) その他 未定義です。指定しないでください。 手動起動モード 無線LAN機能のON/OFFを手動で切り替えるモードです。 出荷時にFlashAirにあらかじめ保存されている無線LAN起動画像（/DCIM/100__TSB/FA000001.JPG）のプロテクト（削除できないようにする）をOFFにすると無線LAN機能を起動し、ONにすると無線LAN機能を停止することができます。 プロテクトのON/OFFは主にデジカメ側で行います。 自動起動モード カードを挿入した機器の電源を入れると、自動的に無線LAN機能が起動するモードです。 AP モード APモード（アクセスポイントモード）とは、FlashAirが無線LAN親機となるモードです。 APPSSID、APPNETWORKKEYにセットされているパラメータを、FlashAirを親機とするLANのSSID、ネットワークセキュリティキーとして使用します。セキュリティモードはWPA2-AESです。 STA モード STAモード（ステーションモード）とは、FlashAirが無線LAN子機となるモードです。 他の無線LAN親機が存在しなければなりません。 APPSSID、APPNETWORKKEYにセットされているパラメータを、親機のSSID、ネットワークセキュリティキーとして使用します。 利用方法は上級者向けチュートリアル - ステーションモードの利用を参照してください。 インターネット同時接続モード APモードとSTAモードを同時に有効にするモードです。 STAモード機能で接続する他の無線LAN親機が存在しない場合は、APモード機能のみが有効になります。 APPSSID、APPNETWORKKEYにセットされているパラメータを、FlashAirを親機とするLANのSSID、ネットワークセキュリティキーとして使用します。セキュリティモードはWPA2-AESです。BRGSSID、BRGNETWORKKEYにセットされているパラメータを、親機のSSID、ネットワークセキュリティキーとして使用します。 利用方法は上級者向けチュートリアル - インターネット同時接続モードの利用を参照してください。 なお、バージョン2.00.03以降のファームウェアにおいてこのモードを利用する場合、11nではなく11b/gによる動作となります。 例: APPMODE=4 NETBIOS, Bonjour名称 (APPNAME) NETBIOS, Bonjourで返される名前を、15文字以内の英数字小文字で設定します。 CONFIGファイルに設定がない場合、あるいはCONFIGファイルが存在しない場合は、flashairが使われます。 例: APPNAME=myflashair ネットワークセキュリティキー (APPNETWORKKEY) 0-63文字の英数字でのネットワークセキュリティキーを設定します。 無線LANのセキュリティ機能を有効にするためには最低8文字が必要です。 例: APPNETWORKKEY=12345678 SSID (APPSSID) 無線LAN識別子(SSID)を、1-32文字の英数字で設定します。 CONFIGファイルに設定がない場合、あるいはCONFIGファイルが存在しない場合は、flashair_&lt;MACADDRESS&gt;が使われます。 例: APPSSID=flashair インターネット同時接続モード用ネットワークセキュリティキー (BRGNETWORKKEY) インターネット同時接続モードで使用するインターネット側ネットワークの ネットワークセキュリティキーを0-63文字の英数字で設定します。 例: BRGNETWORKKEY=12345678 インターネット同時接続モード用ネットワークSSID (BRGSSID) インターネット同時接続モードで使用するインターネット側ネットワークの無線LAN識別子(SSID)を、 1-32文字の英数字で設定します。 例: BRGSSID=myhomelan カードID (CID) SD規格で定められているCard Identifier (CID)です。 32ケタの16進数です。 例: CID=02544d53573038470750002a0200c201 無線起動画面のパス設定 (CIPATH) 無線起動画面として使う画像ファイルのフルパスを設定します。 無線起動画面とは、無線LANモード(APPMODE)が0,2,3のいずれかである場合に、無線LAN機能のON/OFFを制御するための画像ファイルです。 例: CIPATH=/DCIM/100__TSB/FA000001.jpg command.cgiの有効opcodeを指定 (COMMANDCGI) command.cgiの有効opcodeを指定します。 例: COMMANDCGI=100-103 CGI の無効化 (DELCGI) 指定した CGI を 無効化します。 パラメータ: 下記のパラメータをカンマ区切りで指定します。 / ファイルダウンロード機能を無効化します。 /command.cgi command.cgiを無効化します。 /config.cgi config.cgiを無効化します。 /thumbnail.cgi thumbnail.cgiを無効化します。 /upload.cgi upload.cgiを無効化します。 例: DELCGI=/,/thumbnail.cgi DHCPクライアントの再送回数 (DHCPC_RETRANS_MAX) DHCPクライアントの再送回数を指定します。0を指定した場合には、無限に再送します。設定値は、0～255となります。 例: DHCPC_RETRANS_MAX=5 DNS動作モードの設定 (DNSMODE) FlashAirのDNS解決方法を変更します。以下のモードがあります。 0 APPNAME、あるいは既定値のflashairでの問い合わせのみ、IPアドレスを返します。 1 (デフォルト) 任意のDNSの問い合わせ全てに対して、自IPアドレスを返信します。 例えば、APPNAME=myflashair と設定されている場合、”http://flashair” でアクセスしてもカードのIPアドレスを返します。 例: DNSMODE=1 TLS証明書のファイルパス (EAPCERT) TLS証明書のファイルパスを指定します。指定可能な証明書は.pfxまたは.p12形式となります。 例: EAPCERT=/cert.pfx PEAPパスワードまたはTLS秘密キーパスワード (EAPPASSWORD) PEAPパスワードまたはTLS秘密キーパスワードを設定します。 例: EAPPASSWORD=12345678 暗号化の規格 (EAPTYPE) STAモード設定時にEAPTYPEが設定されている場合、8021Xモード(WPA2 Enterprise)で動作します。設定値はPEAP 、TLS となります。PEAP を設定した場合においては、EAPUSERとEAPPASSWORDのパラメータを用いて、接続を試みます。TLS を指定した場合はクライアント証明書を用いた接続を行います。この時、接続するアクセスポイントのSSIDは、APPSSIDにて指定します。 例: EAPTYPE=TLS 設定例: 無線セキュリティーの設定 認証方式：WPA-EAP WPAタイプ：WPA2-EAP 暗号化方式：AES ※IEEE802.1X/EAPでの接続は不可 EAP-PEAPのCOFIG設定 EAPTYPE=PEAP EAPUSER=flashair EAPPASSWORD=******** # ユーザ管理で設定したパスワード EAP-TLSのCOFIG設定 EAPTYPE=TLS EAPCERT=/radius2.p12 # RADIUSサーバに設定した証明書と同じでも可 EAPPASSWORD=******** # 証明書作成時に設定したパスワード EAPUSER=flashair EAPTYPEが指定された場合に利用するユーザーID (EAPUSER) EAPTYPEが指定された場合に利用するユーザーIDを指定します。 例: EAPUSER=SMITH メモリサイズ (HTTPDBUFF) HTTPサーバで使用するメモリ量を削減することで、Luaスクリプトが使用可能なメモリ量を増加することができます。 なおHTTPサーバのメモリを削減した場合には、ダウンロードのスループットが低下します。 設定可能範囲は2920から23360です。デフォルト値は23360です。 例: HTTPDBUFF=2920 認証方法 (HTTPDMODE) HTTPサーバが使用する認証方法を設定します。以下のモードがあります。 0 (デフォルト) 認証なし 1 Basic認証 2 Digest認証 例: HTTPDMODE=1 Basic認証のパスワード、Digest認証のハッシュ値 (HTTPDPASS) Basic認証で使われるパスワード、またはDigest認証で使われるハッシュ値を設定します。Digest認証のRealmは”Secret Zone”となります。Digest認証の場合、下記の値を32ケタの16進数で記載してください。MD5(ユーザー名 “:” “Secret Zone” “:” パスワード) ・例（Basic認証）: HTTPDPASS=12345678 ・例（Digest認証）: ユーザー名：username パスワード：password&lt;br の場合、MD5(“username:Secret Zone:password”)を計算する。 HTTPDPASS=66643ffbf66badfe10b904134e6bd1dc Basic認証のユーザ名 (HTTPDUSER) Basic認証で使われるユーザ名を設定します。Digest認証時では使用されません。 例: HTTPDUSER=flashair SDインターフェース端子のI/O利用機能の有効化 (IFMODE) SDインターフェイス端子を、汎用のI/O信号端子として利用し、 信号の読み書きを行う機能を有効にします。 利用方法はcommand.cgi: SDインターフェース端子のI/O利用を参照してください。 1 SDインターフェース端子のI/O利用機能有効 それ以外 (デフォルト) SDインターフェース端子のI/O利用機能無効 例: IFMODE=1 初期設定済みフラグ (LOCK) 初期設定が完了しているかを示すフラグです。初期設定が完了している場合は1が設定されます。 本パラメータがない場合は、ブラウザから接続すると初期設定としてSSIDとネットワークセキュリティキーの設定画面が表示されます。1以外の値は設定しないでください。 例: LOCK=1 起動時に実行するLuaスクリプトのパス (LUA_RUN_SCRIPT) FlashAir起動時に実行するLuaスクリプトのファイルパスを絶対パスで指定します。起動５秒後に指定ファイルが実行されます。 例: LUA_RUN_SCRIPT=/bootscript.lua ファイル書き込み時に実行するLuaスクリプトのパス (LUA_SD_EVENT) FlashAirへのファイル書き込み時に実行するLuaスクリプトのファイルパスを絶対パスで指定します。SDメモリカードの書き込みが発生した場合に指定ファイルが実行されます。最後のデータの書き込みから0.5秒後に実行されます。 例: LUA_SD_EVENT=/writescript.lua マスターコード (MASTERCODE) マスターコードは、SSID(APPSSID)やネットワークキー(APPNETWORKKEY)の設定の際のパスワードとして使われる12ケタの16進数の数字です。 未設定の場合は、config.cgiで各種設定を変更する前に必ず、マスターコードを設定する必要があります。 MASTERCODEを削除することで、マスタコードを初期状態に戻すことができます。 例: MASTERCODE=0123456789AB ノイズキャンセル (NOISE_CANCEL) 電波環境が良好とは言えない環境においてこの設定を利用することにより、距離特性と引き換えにノイズ耐性を多少向上させることが出来ます。 2 ノイズキャンセルを有効にする それ以外 (デフォルト) ノイズキャンセルを無効にする 例: NOISE_CANCEL=2 製品コード (PRODUCT) FlashAirの製品名称です。FlashAirとなります。 例: PRODUCT=FlashAir HTTPリダイレクトモード (REDIRECT) HTTPリダイレクトモードを変更します。次の値のいずれかを指定します。 1 (デフォルト) リダイレクト機能有効 0 リダイレクト機能無効 例: REDIRECT=1 STAモードでのアドレスフィルタリング機能 (STAMAC) STAモードでのアドレスフィルタリング機能を指定します。複数台登録する場合は、７台まで登録可能。その場合は、STAMACを複数行記載する必要があります。 例: STAMAC=40b395A0851a STAモードでの接続台数制限 (STANUM) STAモードでの接続台数制限を指定します。記載しない場合は7台まで接続可能です。 例: STANUM=2 STAモードでの接続リトライ回数 (STA_RETRY_CT) STAモードでの無線LAN親機への接続リトライ回数を指定します。0は無限にリトライします。 例: STA_RETRY_CT=3 タイムゾーン (TIMEZONE) FlashAirドライブ(WebDAV)動作時に、FATファイル時間からUTC時間へ変換するためのタイムゾーンを設定します。 15分単位を1として-48から54の数字で設定します。日本は、UTC標準時を0とし、9時間進めたUTC+9であるため、36(9(h)×4(15m)=36)を設定します。 例: TIMEZONE=36 アップロード先ディレクトリの指定 (UPDIR) アップロード先ディレクトリを指定します。 例: UPDIR=/DCIM アップロード機能の有効化 (UPLOAD) アップロード機能を有効にするかどうかを指定します。次の値のいずれかを指定します。 1 アップロード機能有効 それ以外 (デフォルト) アップロード機能無効 例: UPLOAD=1 ベンダーコード (VENDOR) FlashAirベンダーの名前です。TOSHIBAとなります。 例: VENDOR=TOSHIBA ファームウェアバージョン (VERSION) ファームウェアのバージョンです。 例: VERSION=F24A6W3AW1.00.03 FlashAirドライブ(WebDAV) (WEBDAV) FlashAirドライブ機能を有効にするかどうかを指定します。次の値のいずれかを指定します。 0 FlashAirドライブ機能無効 1 FlashAirドライブ機能有効（リードオンリーモード） 2 FlashAirドライブ機能有効（リードライトモード） 例: WEBDAV=0 無線LAN規格 (WLANAPMODE) 無線LAN規格を指定します。次の値のいずれかを指定します。 0x01 802.11b 0x02 802.11g 0x03 (デフォルト) 802.11bg 0x82 802.11ng 例: WLANAPMODE=0x03",
    "url": "http://localhost:4000/docs/api/config.html",
    "relUrl": "/docs/api/config.html"
  },
  "70": {
    "id": "70",
    "title": "Cordova向けチュートリアル",
    "content": "Cordova向けチュートリアル Cordova向けのチュートリアルを紹介しています。",
    "url": "http://localhost:4000/docs/tutorials/cordova.html",
    "relUrl": "/docs/tutorials/cordova.html"
  },
  "71": {
    "id": "71",
    "title": "組み込み機器開発の概要",
    "content": "組み込み機器開発の概要 量販店等で購入されたFlashAirに本サイトの記載内容を適用してソフトウェアの書き込みや設定変更を行った場合は、保証規定に基づく無償交換の対象外になります。ご了承の上、お客様の責任において開発を行ってください。 FlashAir組み込み機器の開発 FlashAir はiSDIO 規格（SD Specifications Part E7）および無線LAN 追加仕様（同Wireless LAN Addendum）に準拠しています。 カメラやPCなど、SDメモリカードスロットを持つ機器（SDメモリカードホスト機器）は、FlashAirをSDHC/SDXCメモリカードとして認識し、データの読み書きを行うことができます。また、iSDIOコマンドをサポートしているSDメモリカードホスト機器ならば、無線LAN機能のコントロールを行うこともできます。 さらに、Luaスクリプト実行機能により、外部サーバへのファイルアップロード、データのダウンロード、HTMLの動的生成など高度な機能が実現できます。 iSDIOによる制御 iSDIOによる制御では、以下のことができます。 無線 APモードで起動、STAモードで起動、AP+STA同時起動、無線切断、SSIDのスキャンといった無線LANの制御ができます。 HTTP 無線LAN上で、HTTP通信ができます。 GPIO SD端子のGPIO制御ができます。 SD 内蔵フラッシュメモリのファイル読み書きができます。 その他 SRAMの読み書きができます。 詳しくは、 iSDIO APIガイドをご覧ください。 Luaスクリプトによる制御 Luaスクリプトによる制御では、以下のことができます。 無線 APモードで起動、STAモードで起動、AP+STA同時起動、無線切断、SSIDのスキャンといった無線LANの制御ができます。 HTTP 無線LAN上で、HTTP通信ができます。 スクリプト Luaスクリプトの実行ができます。 GPIO SD端子のGPIO制御ができます。 SD 内蔵フラッシュメモリのファイル読み書きができます。 詳しくは、 Lua機能をご覧ください。",
    "url": "http://localhost:4000/docs/discover/device.html",
    "relUrl": "/docs/discover/device.html"
  },
  "72": {
    "id": "72",
    "title": "FlashAir DIP IOボード",
    "content": "FlashAir DIP IOボード FlashAir DIP IOは、FlashAirにGPIO と I2C インターフェースを拡張することができるボードです。 概要 FlashAir に GPIO と I2C インターフェースを拡張することができます。 ブレッドボードで使用する際、穴を無駄にしない形状です。 レギュレータを実装してあるので外付けする必要がありません。（電源電圧範囲外の場合を除きます。） リセットスイッチ（SW1）を押すことで FlashAir と SC18IS600IBS をリセットすることができます。 裏面に I2C のプルアップ設定用ジャンパーがあります 開発は Lua スクリプトで行います。FlashAir に Lua スクリプト（*.lua）を書き込むだけなのでノートPCのSDメモリカードスロット等、書き込む事の出来る環境があれば簡単に開発することができます。専用のライターなどは必要ありません。 FlashAir は別売です。別途ご用意ください。W-03（第三世代）が使用できます。 特徴 GPIO+I2C インターフェースブリッジに SC18IS600IBS を使用 GPIO4 チャネル+I2C インタフェースの変換 3.3V 出力 LDO レギュレータを内蔵 仕様 電源電圧 2.8V～6V（GPIO 出力電流 10mA 以下の条件で 9V まで入力可） 消費電流 140mA～260mA GPIO 出力電流 4 チャネル合計 120mA サンプル回路例 購入 FlashAir DIP IOボードは、以下よりご購入いただけます。 秋月電子通商 http://akizukidenshi.com/catalog/g/gK-10007/ 同店にて、FlashAir DIP IOボードと組み合わせ可能なFlashAirも販売しています。 W-03 8GB: 取り扱いありません（動作確認済み） W-03 16GB: M-09651 W-03 32GB: M-09865 部品表 部品番号 値 型式 C1～C5 0.1uF GRM155F11E104Z R1～R5 10kΩ RK73B1ETTP103J Q1   IRLML6402 Q2   2SC4081 U1   NJM2845DL1-33 U2   SN74LVC1G17DRLR U3   SC18IS600IBS CN1   1010070864 ダウンロード サンプルスクリプト（GPIO） ブリッジICを使いGPIOを動作させます。下記の部品表を参考に部品を接続して下さい。接続はサンプル回路例を参考にしてください。FlashAirの/SD_WLAN/CONFIG にIFMODE=1 を追記してください。 サンプルスクリプトをダウンロード (0.4KB) 部品表 名称 型番 個数 参考URL 電源 単三アルカリ乾電池 4 http://akizukidenshi.com/catalog/g/gB-03256/ LED OSDR5113A 4 http://akizukidenshi.com/catalog/g/gI-00624/ 抵抗 約1kΩ 4 http://akizukidenshi.com/catalog/g/gR-16102/",
    "url": "http://localhost:4000/docs/resources/dipio.html",
    "relUrl": "/docs/resources/dipio.html"
  },
  "73": {
    "id": "73",
    "title": "開発を始めよう",
    "content": "開発を始めよう",
    "url": "http://localhost:4000/docs/discover",
    "relUrl": "/docs/discover"
  },
  "74": {
    "id": "74",
    "title": "FAQ",
    "content": "FAQ FlashAirアプリ開発に関してよくある質問と答えを公開しています。 一般的な使い方 FlashAir って？ FlashAirが応答しなくなることがあります。 FlashAirに無線LANで接続できません。 FlashAirをカメラで使っていますが、スマートフォンに写真をダウンロードできません。 無線LAN経由でFlashAir内のファイルを確認できますか？ FlashAirの電波の届く距離を延ばすにはどうすればよいですか？ 使用しているカメラがFlashAirに対応しているか教えてください。 設定 SSIDは文字数の制限がありますか？ 初期ネットワークキー（パスワード）がわかりません。 ネットワークキー（パスワード）は文字数の制限がありますか？ FlashAirのネットワークキー（パスワード）を忘れてしまいました。 SSID、パスワードを設定者以外知りえない状態にできますか？ マスターコードとは何ですか？ マスターコードの調べ方を教えてください。 FlashAirをステーションモードに設定しましたが、同じ無線LAN内の端末のブラウザからアクセスできません。 FlashAirへデータをアップロードできますか？ FlashAirのIPアドレスは指定できますか？ FlashAirはEAP-TLS（PEAP-TLS）の認証方式で接続できますか？ CGI、CONFIG command.cgi?op=100&amp;DIR=/DCIM/ を要求しても値が返ってきません。 command.cgi?op=100 と command.cgi?op=101 で返される数に違いがあります。 command.cgi?op=105 を要求しても値が返ってきません。 command.cgi?op=111 を要求しても値が返ってきません。 config.cgiで変更したSSIDやパスワードはCONFIGファイルに保存されますか？ upload.cgi?DEL= でファイル（フォルダ）の削除を要求してもFileNotFoundExceptionのエラーが出ます。 upload.cgi?DEL= を要求してSUCCESSの応答があってもファイル（フォルダ）の削除が反映されず、SDメモリカードホスト機器からFlashAirを外して再挿入すると反映されるのは何故ですか？ CGIをHTTP GETリクエストで繰り返し発行する際に、ブラウザのキャッシュ機能を回避する方法はありますか？ CONFIGファイルの確認、編集方法を教えてください。 upload.cgiで追加（または削除）したはずのファイルがPC上で確認できません。 Lua アクセスポイントモードに設定しているFlashAirを、Luaスクリプトでインターネット同時接続モードへ切り替えることはできますか？ アクセスポイントモードで接続中に、LuaスクリプトでScanの操作を行うことができますか？ LuaスクリプトのScan使用時のSSID検索について、ワイルドカードでの指定検索は可能ですか？ FlashAirがGPIOを使用できないデバイスに接続されているか判断する方法を教えてください。 ホスト側の処理とLuaスクリプトの処理が同時に行われた場合、どちらが優先されますか？ ハードウェア FlashAirの消費電力はどのくらいですか FlashAirの消費電力を少なくすることはできますか？ FlashAirを初期化した際の構造を教えてください。 FlashAirのWebサーバはどのような仕組みで動作するのですか？ Linuxのファイルシステム（ext3など）でフォーマットしてもよいでしょうか？ FlashAirがサポートしている文字エンコーディングを教えてください。 FlashAir SD-WD/WC（W-02）をW-03のファームウェアにアップデートできますか？ その他 アクセス制限不備の脆弱性について教えてください。 FlashAirのファイルを自動的にFTPサーバやクラウドサービスへアップロードする方法はありますか？ Arduino Due用iSDIOに関するライブラリやチュートリアルはありませんか？ FlashAirをPCに接続している場合、FlashAirを介してPC側のデータにアクセスできますか？ Eyefi Connectedについて教えてください。 「Keenai™」アプリケーションでのFlashAirの使用方法を教えてください。 FlashAirを物理的に抜き差しせずに内容を更新（再認識）する方法はありますか？ 一般的な使い方 FlashAir って？ FlashAirは、無線LAN機能を搭載したSDHC/SDXCメモリカードです。無線LANを搭載しているパソコン、スマートフォンなどであれば、別の機器に挿入されているFlashAirのデータにアクセスすることができます。 詳細はこちらをご確認ください。https://jp.toshiba-memory.com/product/flashair/sduwa/index_j.htm FlashAirが応答しなくなることがあります。 FlashAirは接続機器により、応答しにくくなる場合があります。メーカーの動作確認済み機器リストをご参考ください。 また、同時に複数の要求を受けた場合にも、応答しにくくなる場合があります。 一度に投げるリクエストは、1つ（多くとも2つ）にすることをお勧めします。 FlashAirに無線LANで接続できません。 FlashAirの一般的な使い方に関するご質問（例：対応機器、アプリの使い方、接続方法）や、FlashAirの故障、接続トラブルについては、下記のサポートセンターへ直接お問い合わせください。https://jp.toshiba-memory.com/contact/index_j.htm FlashAirをカメラで使っていますが、スマートフォンに写真をダウンロードできません。 FlashAirの一般的な使い方に関するご質問（例：対応機器、アプリの使い方、接続方法）や、FlashAirの故障、接続トラブルについては、下記のサポートセンターへ直接お問い合わせください。https://jp.toshiba-memory.com/contact/index_j.htm 無線LAN経由でFlashAir内のファイルを確認できますか？ FlashAirに無線LAN接続したPC上のウェブブラウザから、ファイル一覧やファイルのダウンロードができます。また、APIを使って行うこともできます。詳細については、FlashAirアプリ開発の概要 の「FlashAirとのHTTP通信の種類」をご覧ください。 FlashAirの電波の届く距離を延ばすにはどうすればよいですか？ FlashAir自体の電波の届く距離を延ばす方法はありませんが、中継機となる無線LANアクセスポイント（ルータなど）があれば、FlashAirをステーションモードに設定して無線LANを中継することで、遠くのFlashAirに接続するという方法があります。ステーションモードの設定方法については、上級者向けチュートリアル - ステーションモードの利用 をご覧ください。 使用しているカメラがFlashAirに対応しているか教えてください。 FlashAirの動作確認機器についてはメーカーの動作確認済み機器リストをご確認ください。 設定 SSIDは文字数の制限がありますか？ SSIDは、1～32文字の間で設定してください。スペースを含めることはできませんのでご注意ください。 初期ネットワークキー（パスワード）がわかりません。 FlashAirの出荷時のパスワードは、「12345678」です。 ネットワークキー（パスワード）は文字数の制限がありますか？ ネットワークキー（パスワード）は、8～64文字で設定してください。また、0文字（未設定）とすることも可能です。スペースを含めることはできませんのでご注意ください。 FlashAirのネットワークキー（パスワード）を忘れてしまいました。 FlashAirの一般的な使い方に関するご質問（例：対応機器、アプリの使い方、接続方法）や、FlashAirの故障、接続トラブルについては、下記のサポートセンターへ直接お問い合わせください。https://jp.toshiba-memory.com/contact/index_j.htm SSID、パスワードを設定者以外知りえない状態にできますか？ SSIDはCONFIGファイルにてどなたでも確認できます。パスワードはFlashAirの再起動でパスワードに設定した文字が「*」に置き換えられますので、設定者以外知りえない状態とすることは可能です。 マスターコードとは何ですか？ マスターコードは、SSIDやネットワークキー（パスワード）を設定する際のパスワードとして使われる12ケタの16進数の数字です。未設定の場合は、config.cgi で各種設定を変更する前に必ず、マスターコードを設定する必要があります。 マスターコードの調べ方を教えてください。 マスターコードはFlashAirに格納されているCONFIGファイルに記されています。CONFIGファイルはFlashAirの “/SD_WLAN/” に配置されており、テキストエディタなどで開くことができます。“/SD_WLAN/”は隠しフォルダとなっておりますので、隠しフォルダ表示の設定を有効にしてご確認ください。 FlashAirをステーションモードに設定しましたが、同じ無線LAN内の端末のブラウザからアクセスできません。 ブラウザを使用している端末及び無線LAN親機がFlashAir対応プロトコル（NetBIOS over TCP/IP または Bonjour）に対応しているかご確認ください。詳細については、上級者向けチュートリアル - ステーションモードの利用の「対応プロトコルによる問題」をご覧ください。 FlashAirへデータをアップロードできますか？ 標準ではFlashAirへデータをアップロードする機能は無効化されています。アップロード機能の有効化やアップロードする方法については以下のページをご参考ください。 APIガイド - upload.cgi 上級者向けチュートリアル - FlashAirへのアップロード FlashAirのIPアドレスは指定できますか？ はい、できます。FlashAirのIPアドレスを指定する方法はCONFIGファイルを編集する方法とLuaスクリプトを実行する方法の２つがあります。 方法1: CONFIGファイルを編集して指定する方法 CONFIGファイルに以下を追加編集します。上から順に、DHCPの無効化、FlashAirに指定したいIPアドレス、無線LANのサブネットマスク、無線LANのデフォルトゲートウェイの設定になります。（※設定値は接続先の無線LANの環境に合わせて変更してください） DHCP_Enabled=NO IP_Address=192.168.43.10 Subnet_Mask=255.255.255.0 Default_Gateway=192.168.43.1 方法2: Luaスクリプトを実行して指定する方法 以下のLua関数を実行するスクリプトに組み込みます。左から順に、FlashAirに指定したいIPアドレス、無線LANのサブネットマスク、無線LANのデフォルトゲートウェイの設定になります。（※設定値は接続先の無線LANの環境に合わせて変更してください） fa.ip(&quot;192.168.11.2&quot;, &quot;255.255.255.0&quot;, &quot;192.168.11.1&quot;) それぞれの詳細については、APIガイド - CONFIG 及びLua関数リファレンス - ip をご覧ください。 FlashAirはEAP-TLS（PEAP-TLS）の認証方式で接続できますか？ FW4.00.03以上で接続可能です。詳細はAPIガイド - CONFIG　EAPTYPEをご覧ください。 CGI、CONFIG command.cgi?op=100&amp;DIR=/DCIM/ を要求しても値が返ってきません。 フォルダ名の最後に付けている “/” スラッシュは不要です。削除してください。 command.cgi?op=100 と command.cgi?op=101 で返される数に違いがあります。 command.cgi?op=101は隠しファイル（フォルダ）を除いたコンテンツ数を返します。対して、command.cgi?op=100は、全てのファイル（フォルダ）を返すため、数に違いがでます。 command.cgi?op=105 を要求しても値が返ってきません。 command.cgi?op=105は、FlashAirがアクセスポイントモードに設定されている場合にのみ使用することができます。アクセスポイントモードについての説明は、無線LANモードの設定 をご覧ください。 command.cgi?op=111 を要求しても値が返ってきません。 command.cgi?op=111は、FlashAirがカード電源投入時に無線LAN機能を起動するモード（APPMODE=4）に設定されている場合にのみ使用することができます。APPMODEについての説明は、無線LANモードの設定 をご覧ください。 config.cgiで変更したSSIDやパスワードはCONFIGファイルに保存されますか？ はい、保存されます。 upload.cgi?DEL= でファイル（フォルダ）の削除を要求してもFileNotFoundExceptionのエラーが出ます。 CONFIGファイルに「UPLOAD=1」が書き込まれているかご確認ください。こちらの設定がない場合、upload.cgiは使用できません。詳細についてはupload.cgi をご覧ください。 upload.cgi?DEL= を要求してSUCCESSの応答があってもファイル（フォルダ）の削除が反映されず、SDメモリカードホスト機器からFlashAirを外して再挿入すると反映されるのは何故ですか？ upload.cgiで行った変更をSDメモリカードホスト機器が認識する方法が無い為、実際にはFlashAirからファイルが削除されているにも関わらず、SDメモリカードホスト機器のOSなどのファイル一覧が更新されていない可能性がございます。詳細については、upload.cgi の「ご注意」をご覧ください。 CGIをHTTP GETリクエストで繰り返し発行する際に、ブラウザのキャッシュ機能を回避する方法はありますか？ 以下のようにCGIを繰り返し発行する度に異なるURLとなるよう追加パラメータを設定することで回避できます。 http://flashair/command.cgi?op=...**&amp;TIME=100** // 一回目のGETリクエスト http://flashair/command.cgi?op=...**&amp;TIME=101** // 二回目のGETリクエスト http://flashair/command.cgi?op=...**&amp;TIME=102** // 三回目のGETリクエスト // 以下繰り返し CONFIGファイルの確認、編集方法を教えてください。 CONFIGファイルについての説明は、APIガイド - CONFIG をご覧ください。 upload.cgiで追加（または削除）したはずのファイルがPC上で確認できません。 SDメモリカードホスト側でOSが持つディスクキャッシュをクリアする処理を実行するか、ホスト機器を再起動してください。FlashAirを刺したまま、再マウントし、OSに再読み込みさせるチュートリアルも参考にしてください。 Lua アクセスポイントモードに設定しているFlashAirを、Luaスクリプトでインターネット同時接続モードへ切り替えることはできますか？ 無線LAN起動中の場合、Bridge では操作できません。また、Luaでインターネット同時接続モードへ切り替えたい場合は、CONFIGファイルに「APPMODE=0」と設定し、起動時に無線LANを起動しない状態で操作することを推奨します。 アクセスポイントモードで接続中に、LuaスクリプトでScanの操作を行うことができますか？ いいえ、できません。無線LAN起動の場合は一旦Disconnect で切断することで、Scan による操作が可能になります。 LuaスクリプトのScan使用時のSSID検索について、ワイルドカードでの指定検索は可能ですか？ いいえ、Scan 使用時にSSIDの指定はできません。 FlashAirがGPIOを使用できないデバイスに接続されているか判断する方法を教えてください。 SDインターフェース端子のI/O利用で確認可能です。Luaスクリプトで確認する場合は以下のようにしてください。 local response = fa.request(&quot;http://flashair/command.cgi?op=190&amp;CTRL=0x00&amp;DATA=0x00&quot;) locl gpio = cjson.decode(response) locl status = gpio[&quot;STATUS&quot;] if tatus == &quot;OK&quot; then - GPIO機能が有効 elsif status == &quot;SDERR&quot; then - GPIO機能が無効 end 上記のコードの1行目で実行したCGIのレスポンスは、例えば {&quot;STATUS&quot;:“OK&quot;, &quot;CTRL&quot;:&quot;0x00&quot;, &quot;DATA&quot;:&quot;0x00&quot;} となり、STATUSの値により、GPIO機能の状態が判断できます。 GPIO機能が有効な場合: “OK” GPIO機能が無効な場合: “SDERR” ホスト側の処理とLuaスクリプトの処理が同時に行われた場合、どちらが優先されますか？ 基本的にホスト側の処理が優先されます。 また、ホスト側でファイル書き込み中にLuaスクリプトで同一ファイルを読み書きすると、Luaスクリプトの処理が不安定になる場合があります。 ハードウェア FlashAirの消費電力はどのくらいですか FlashAirの消費電流は、SDHCの規格範囲内（最大0.72W@3.6V）です。 ただし、起動時や通信中の電流変動は、一般のSDHC/SDXCメモリカードとは異なる場合があります。 FlashAirの消費電力を少なくすることはできますか？ 申し訳ありませんが、電力パラメータを変更する方法はございません。ご了承下さい。 FlashAirを初期化した際の構造を教えてください。 非公開となっております。 FlashAirのWebサーバはどのような仕組みで動作するのですか？ Webサーバは、FlashAirのフラッシュメモリ（SDメモリカードとしてアクセスできる部分）のルートディレクトリをドキュメントルートとして動作します。FlashAirに電源が入っていれば常に起動しております。 Linuxのファイルシステム（ext3など）でフォーマットしてもよいでしょうか？ SDメモリカードとしてはご利用できますが、Webサーバは正常に動作しません。FlashAirのWebサーバが正常動作するためにはファイルシステムがFATである必要があります。 FlashAirがサポートしている文字エンコーディングを教えてください。 第1世代はShift-JISです。第2世代（W-02）以降はUTF-8ですが、ASCII、日本語、中国語の範囲のみの対応となります。 FlashAir SD-WD/WC（W-02）をW-03のファームウェアにアップデートできますか？ W-02シリーズのFlashAirをW-03のファームウェアにアップデートすることはできません。 その他 アクセス制限不備の脆弱性について教えてください。 インターネット同時接続機能に関して、下記の脆弱性が存在します。 インターネット接続側ネットワークにあるデバイス（PC等）から認証なしで接続できてしまう FlashAirに記録されているファイルやデータの改ざんや、任意のLuaスクリプトの実行ができてしまう 1.の脆弱性は、下記の条件をすべて満たした場合に発生いたします。 FlashAirのインターネット同時接続機能が有効である（参照：APPMODE） FlashAirとインターネット接続側ネットワークにあるデバイスが、同一アクセスポイントに接続されている FlashAirのIPアドレスがわかっている 2.の脆弱性は、上記３つに加えて、下記の条件が満たされた場合に発生いたします。 無線LAN経由での書き込み機能を有効にしている（参照：UPLOAD 本脆弱性は、HTTPサーバの認証を設定することで回避できます。 HTTPDMODE — 認証方法 HTTPDUSER — Basic認証のユーザ名 HTTPDPASS — Basic認証のパスワード、Digest認証のハッシュ値 なお、標準では、インターネット同時接続機能および無線LAN経由での書き込み機能はいずれも無効になっており、本脆弱性の影響はありません。ご利用者がCONFIGファイルの直接変更またはアプリを利用して明示的に変更しない限り、これらの機能が有効になることはありません。 これらの機能に関する詳しい設定方法は、上級者向けチュートリアル - インターネット同時接続モード および上級者向けチュートリアル - FlashAirへのアップロード をご覧ください。 FlashAirのファイルを自動的にFTPサーバやクラウドサービスへアップロードする方法はありますか？ ご自身でアップロード環境を構築する場合は、以下のチュートリアルページがご参考になります。 Lua機能 - FTPサーバを使ったファイルのアップロード Lua機能 - Facebookへのアップロード Lua機能 - OAUTH2を使ったDropboxへのアップロード Arduino Due用iSDIOに関するライブラリやチュートリアルはありませんか？ 現時点ではArduino Dueに関するライブラリやチュートリアルはございません。 Arduino Unoで動作確認済みのチュートリアルがありますので、そちらをご参考ください。チュートリアル - Arduino FlashAirをPCに接続している場合、FlashAirを介してPC側のデータにアクセスできますか？ いいえ、アクセスすることはできません。 Eyefi Connectedについて教えてください。 Eyefi Connectedは、カメラからSDメモリカードを制御することができるカメラ連携機能です。電源コントロールに対応したEyefi連動機能搭載カメラで使用すると、データ転送中のカメラの電源停止を防ぐことができます。 詳細は下記のページをご確認ください。https://business.toshiba-memory.com/ja-jp/company/news/news-topics/2017/02/memory-20170223-1.html 「Keenai™」アプリケーションでのFlashAirの使用方法を教えてください。 「Keenai™」アプリケーションでの使用方法については下記のページをご確認ください。https://help.keenai.com/hc/ja/sections/206542628 FlashAirを物理的に抜き差しせずに内容を更新（再認識）する方法はありますか？ SDメモリカードホスト側でOSが持つディスクキャッシュをクリアする処理を実行するか、ホスト機器を再起動してください。 FlashAirを刺したまま、再マウントし、OSに再読み込みさせるチュートリアルも参考にしてください。",
    "url": "http://localhost:4000/docs/support/faq.html",
    "relUrl": "/docs/support/faq.html"
  },
  "75": {
    "id": "75",
    "title": "FTP/FTPS（FlashAir独自拡張）",
    "content": "FTP/FTPS（FlashAir独自拡張） FTP コマンドID コマンド名 機能 0E001h get(hostname, port, user, pass, serverFile, localFile) FTPサーバーからファイルを取得 0E002h put(hostName, port, user, pass, serverFile, localFile) FTPサーバーへファイルを送信 0E003h rename(hostName, port, user, pass, sourceFile, distinationFile) FTPサーバー上のファイル名を変更 0E004h delete(hostName, port, user, pass, serverFile) FTPサーバーのファイルを削除 0E005h getList(hostName, port, user, pass, directoryName) FTPサーバーのディレクトリ情報を取得 FTPS コマンドID コマンド名 機能 0E011h get(hostname, port, mode, user, pass, serverFile, localFile) FTPSサーバーからファイルを取得 0E012h put(hostName, port, mode, user, pass, serverFile, localFile) FTPSサーバーへファイルを送信 0E013h rename(hostName, port, mode, user, pass, sourceFile, distinationFile) FTPSサーバー上のファイル名を変更 0E014h delete(hostName, port, mode, user, pass, serverFile) FTPSサーバーのファイルを削除 0E015h getList(hostName, port, mode, user, pass, directoryName) FTPSサーバーのディレクトリ情報を取得 get(hostname, port, user, pass, serverFile, localFile) FTPサーバーからのファイルを取得します。取得したファイルは指定されたlocalFileのファイルパス名により保存されます。 コマンドID 0E001h 引数 Name Type Size 説明 hostname Value 可変長 ホスト名。最大128文字指定できます。 port integer 2バイト ポート番号。 user Value 可変長 FTPサーバーのユーザー名。最大64文字指定できます。 pass Value 可変長 FTPサーバーのパスワード。最大64文字指定できます。 serverFile Value 可変長 FTPサーバー上のファイル名。最大128文字指定できます。 localFile Value 可変長 取得したファイルに付ける名称。最大128文字指定できます。 レスポンス なし put(hostName, port, user, pass, serverFile, localFile) FTPサーバーへファイルを送信します。 コマンドID 0E002h 引数 Name Type Size 説明 hostname Value 可変長 ホスト名。最大128文字指定できます。 port integer 2バイト ポート番号。 user Value 可変長 FTPサーバーのユーザー名。最大64文字指定できます。 pass Value 可変長 FTPサーバーのパスワード。最大64文字指定できます。 serverFile Value 可変長 FTPサーバー上のファイル名。最大128文字指定できます。 localFile Value 可変長 送信するファイル名。最大128文字指定できます。 レスポンス なし rename(hostName, port, user, pass, sourceFile, distinationFile) FTPサーバー上のファイル名を変更します。 コマンドID 0E003h 引数 Name Type Size 説明 hostname Value 可変長 ホスト名。最大128文字指定できます。 port integer 2バイト ポート番号。 user Value 可変長 FTPサーバーのユーザー名。最大64文字指定できます。 pass Value 可変長 FTPサーバーのパスワード。最大64文字指定できます。 serverFile Value 可変長 FTPサーバー上のファイル名。最大128文字指定できます。 distinationFile Value 可変長 変更後のファイル名。最大128文字指定できます。 レスポンス なし delete(hostName, port, user, pass, serverFile) FTPサーバーのファイルを削除します。 コマンドID 0E004h 引数 Name Type Size 説明 hostname Value 可変長 ホスト名。最大128文字指定できます。 port integer 2バイト ポート番号。 user Value 可変長 FTPサーバーのユーザー名。最大64文字指定できます。 pass Value 可変長 FTPサーバーのパスワード。最大64文字指定できます。 serverFile Value 可変長 FTPサーバー上の削除するファイル名。最大128文字指定できます。 レスポンス なし getList(hostName, port, user, pass, directoryName) FTPサーバーのディレクトリ情報を取得します。取得するデータは、FTPサーバーにより作成された文字列となります。 コマンドID 0E005h 引数 Name Type Size 説明 hostname Value 可変長 ホスト名。最大128文字指定できます。 port integer 2バイト ポート番号。 user Value 可変長 FTPサーバーのユーザー名。最大64文字指定できます。 pass Value 可変長 FTPサーバーのパスワード。最大64文字指定できます。 directoryName Value 可変長 FTPサーバー上の情報を取得するディレクトリ名。最大128文字指定できます。 レスポンス directoryNameで指定したディレクトリ配下のリストを取得することが出来ます。 get(hostname, port, mode, user, pass, serverFile, localFile) FTPSサーバーからのファイルを取得します。取得したファイルは指定されたlocalFileのファイルパス名により保存されます。 コマンドID 0E011h 引数 Name Type Size 説明 hostname Value 可変長 ホスト名。最大128文字指定できます。 port integer 2バイト ポート番号。 mode integer 1バイト モード設定。 user Value 可変長 FTPSサーバーのユーザー名。最大64文字指定できます。 pass Value 可変長 FTPSサーバーのパスワード。最大64文字指定できます。 serverFile Value 可変長 FTPSサーバー上のファイル名。最大128文字指定できます。 localFile Value 可変長 取得したファイルに付ける名称。最大128文字指定できます。 レスポンス なし put(hostName, port, mode, user, pass, serverFile, localFile) FTPSサーバーへファイルを送信します。 コマンドID 0E012h 引数 Name Type Size 説明 hostname Value 可変長 ホスト名。最大128文字指定できます。 port integer 2バイト ポート番号。 mode integer 1バイト モード設定。 user Value 可変長 FTPSサーバーのユーザー名。最大64文字指定できます。 pass Value 可変長 FTPSサーバーのパスワード。最大64文字指定できます。 serverFile Value 可変長 FTPSサーバー上のファイル名。最大128文字指定できます。 localFile Value 可変長 送信するファイル名。最大128文字指定できます。 レスポンス なし rename(hostName, port, mode, user, pass, sourceFile, distinationFile) FTPSサーバー上のファイル名を変更します。 コマンドID 0E013h 引数 Name Type Size 説明 hostname Value 可変長 ホスト名。最大128文字指定できます。 port integer 2バイト ポート番号。 mode integer 1バイト モード設定。 user Value 可変長 FTPサーバーのユーザー名。最大64文字指定できます。 pass Value 可変長 FTPSサーバーのパスワード。最大64文字指定できます。 serverFile Value 可変長 FTPSサーバー上のファイル名。最大128文字指定できます。 distinationFile Value 可変長 変更後のファイル名。最大128文字指定できます。 レスポンス なし delete(hostName, port, mode, user, pass, serverFile) FTPSサーバーのファイルを削除します。 コマンドID 0E014h 引数 Name Type Size 説明 hostname Value 可変長 ホスト名。最大128文字指定できます。 port integer 2バイト ポート番号。 mode integer 1バイト モード設定。 user Value 可変長 FTPSサーバーのユーザー名。最大64文字指定できます。 pass Value 可変長 FTPSサーバーのパスワード。最大64文字指定できます。 serverFile Value 可変長 FTPSサーバー上の削除するファイル名。最大128文字指定できます。 レスポンス なし getList(hostName, port, mode, user, pass, directoryName) FTPSサーバーのディレクトリ情報を取得します。取得するデータは、FTPSサーバーにより作成された文字列となります。 コマンドID 0E015h 引数 Name Type Size 説明 hostname Value 可変長 ホスト名。最大128文字指定できます。 port integer 2バイト ポート番号。 mode integer 1バイト モード設定。 user Value 可変長 FTPSサーバーのユーザー名。最大64文字指定できます。 pass Value 可変長 FTPSサーバーのパスワード。最大64文字指定できます。 directoryName Value 可変長 FTPSサーバー上の情報を取得するディレクトリ名。最大128文字指定できます。 レスポンス directoryNameで指定したディレクトリ配下のリストを取得することが出来ます。",
    "url": "http://localhost:4000/docs/api/reference/ftp.html",
    "relUrl": "/docs/api/reference/ftp.html"
  },
  "76": {
    "id": "76",
    "title": "はじめに",
    "content": "はじめに 開発を始める前にぜひ一度お読みください FlashAirデベロッパーズへようこそ FlashAirは、無線LAN機能を搭載したSDHC/SDXCメモリカードです。PCやスマートフォンといったWi-Fiを搭載した外部機器は、FlashAir APIを介して、FlashAirに保存されたデータにアクセスできるようになります。このFlashAir APIを使うことで、アプリ開発者は、FlashAir対応のアプリを開発したり、既存アプリの機能を拡張したりすることができます。 FlashAirデベロッパーズでは、FlashAir APIを使ったアプリ開発や、ブラウザユーティリティをカスタマイズして自分だけのオリジナルFlashAirを作る方法を紹介しています。 このドキュメントの想定読者 本サイトの内容は、無線LAN、SDメモリカード、およびコンピュータ関連の基礎知識があり、AndroidやiOSなどの開発を自分で学習しながら進められる方を対象としています。また、一部の内容はWeb関連技術に関して知識があることを想定しています。必要な基礎知識に関しては、 初心者向け技術ガイドをご覧ください。 FlashAir APIとは FlashAirは、外部デバイスから利用するための基本的なAPIを提供しています。 詳しくは、 APIガイドをご覧ください。 また、FlashAir APIを使った開発をサンプルコード付で詳しく解説したチュートリアルをご紹介しています。 詳しくは、 チュートリアルをご覧ください。 APIポリシー FlashAir APIは、非商用、商用を問わず、アプリ開発などでご自由にお使いいただけます。 サポート StackOverflow 開発に関する技術的な質問は、Stack Overflowをお薦めします。質問する場合は、flashairタグをご利用ください。",
    "url": "http://localhost:4000/docs/discover/gettingstarted.html",
    "relUrl": "/docs/discover/gettingstarted.html"
  },
  "77": {
    "id": "77",
    "title": "FlashAir Developers",
    "content": "あらゆる機器をIoTデバイスに 通常のSDカードの代わりに無線LAN機能を搭載したFlashAirを組み込むことで、あらゆる機器がIoTデバイスになります。 FlashAirでできること FlashAirを学ぶ FlashAirとは FlashAirでできること アプリを作る FlashAirアプリ開発概要 iOS向けチュートリアル Android向けチュートリアル 電子工作する 組み込み機器開発の概要 Lua",
    "url": "http://localhost:4000/",
    "relUrl": "/"
  },
  "78": {
    "id": "78",
    "title": "iOS向けチュートリアル",
    "content": "iOS向けチュートリアル iOSアプリ開発向けのチュートリアルを紹介しています。",
    "url": "http://localhost:4000/docs/tutorials/ios.html",
    "relUrl": "/docs/tutorials/ios.html"
  },
  "79": {
    "id": "79",
    "title": "iSDIO",
    "content": "iSDIO iSDIO (Intelligent SDIO) をつかえば、マイコンボードなどのSDメモリカードホスト機器から、FlashAirの無線LAN機能の高度で精密な制御が行えます。 FlashAirがHTTP通信コプロセッサになってしまうのです。 iSDIOは，ファームウェアバージョン 1.00.00 以上で利用できます。 ファームウェアバージョン 4.00.00では、SDモードのみの対応となります。 ファームウェアバージョン 4.00.01+においては、CMD17/24を利用することでSPIモードでのiSDIOコマンドの発行を行うことができます。使用方法に関してはこちらをご覧ください。 SPIモードでのご利用方法については、後日公開予定です。 iSDIOとは iSDIOコマンド発行の方法 コマンドリファレンス レジスタマップ Arduinoチュートリアル (iSDIOを利用しています) iSDIOとは iSDIO (Intelligent SDIO) とは、SD メモリカードの規格団体である SD アソシエーションによって定められた、 FlashAir のような拡張機能付き SDメモリカードをコントロールするための新しい規格です。 通常、Arduino のようなマイコン機器に無線 LAN 機能を付ける場合、無線 LAN アダプタ部品とドライバソフトウェアが必要になります。 しかし、iSDIO をつかえば、マイコン機器に代わってFlashAirに無線 LAN 通信を代行させることができます。 FlashAir が無線 LAN アダプタとドライバソフトウェアが一体化した部品になると考えてもよいかもしれません。 SD 規格は、会員企業以外にも簡易版仕様書 (Simplifed Specifications - SD Association) が公開されており、 iSDIO の仕様はこのなかの Part E7 Intelligent SDIO Simplified Specification に定義されています。 実際には、iSDIO 仕様とはコマンドやりとりの手順 ( プロトコル ) のみを定めた枠組みのようなものであり、 利用できる機能や引数などの詳細は拡張機能の種類（アプリケーション）ごとにAddendum（補遺）で定められます。FlashAir は無線 LAN 内蔵カード向けの「Wireless LAN Addendum」に準拠しています。 iSDIOコマンド発行の方法 コマンドの発行と結果の取得には、 SD規格のFunction Extension Commands (class 11)に規定されている、 拡張レジスタの読み書きを行うコマンド CMD49(WRITE_EXTR_SINGLE)およびCMD48(READ_EXTR_SINGLE)を利用します。 CMD48/49は、次のような３種類のモードがあります。 レジスタ アドレスと長さで指定したメモリ領域に対する読み書き。ステータスなど小さなデータに利用。 データポート 512バイト固定のメモリブロックに対する読み書き。データなど大きなデータに利用。 マスク書き込み (CMD49のみ) あるアドレスの1バイトの一部のビットの変更。ステータスリセットなどに利用。 どのモードを使えばよいかは、iSDIO Wireless LAN Simplified Addendumによって、 あるアドレス領域はレジスタモード、あるアドレス領域はデータポートモード、などと定められており、それに従う必要があります。 iSDIOコマンドの発行 iSDIOコマンドを発行するには、 コマンドデータをCMD49を使ってCommand Write Register Portに書き込みます。 一般的な手順は次のとおりです。 コマンドデータを作る。ホストシステムのメモリ上で行います。 データの内容はコマンドの種類によって異なります。コマンドリファレンスを参照してください。 コマンドデータをCMD49を使ってCommand Write Register Portに書き込む。 システムで提供されているSD読み書きAPIを利用するとよいでしょう。Arduinoチュートリアルも参照ください。 ファームウェアバージョン 4.00.01+でのSPIモードでのiSDIOは、CMD48, CMD49ではなく、CMD17, CMD24をお使いください。 iSDIOコマンドの結果を読み取る すべてのiSDIOコマンドは非同期的に実行されます。 そのため、コマンドのステータスを監視し、 終了したら結果を読み取るという手順が必要になります。 発行されたコマンドのステータス監視には、Response Status Registerを読み取ります。 コマンドが完了したら、Response Data Register Portを読み取ることで、結果を取得できます。 コマンドリファレンス iSDIO Wireless LAN Addendumのコマンドです。 FlashAirで利用できないものは省略しています。 WLAN 共通 サーバーアップロード FTP/FTPS（FlashAir独自拡張） レジスタマップ FlashAirのiSDIOのメモリマップはレジスタマップを参照してください。 00000h～00200h Command Write Register 00200h～00400h Response Data Register Port 00400h～00600h Status Register",
    "url": "http://localhost:4000/docs/api/isdio.html",
    "relUrl": "/docs/api/isdio.html"
  },
  "80": {
    "id": "80",
    "title": "iSDIO向けチュートリアル",
    "content": "iSDIO向けチュートリアル iSDIO向けのチュートリアルを紹介しています。 Arduino向けチュートリアル ArduinoでFlashAir制御の概要 iSDIO拡張コマンドの作成 カードステータスの読み取り APモードでの起動 STAモードでの起動 Webページの取得 Raspberry Pi向けチュートリアル インターネット同時接続モードの設定 APIリファレンス Mbed™向けチュートリアル MbedでAPモード起動 APIリファレンス",
    "url": "http://localhost:4000/docs/tutorials/isdio.html",
    "relUrl": "/docs/tutorials/isdio.html"
  },
  "81": {
    "id": "81",
    "title": "二条項BSDライセンス",
    "content": "二条項BSDライセンス このサイトのサンプルコードは二条項BSDライセンスで提供されています。 Copyright (c) 2013, Toshiba Memory Corporation. All rights reserved. Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.",
    "url": "http://localhost:4000/docs/license.html",
    "relUrl": "/docs/license.html"
  },
  "82": {
    "id": "82",
    "title": "Lua機能",
    "content": "Lua機能 量販店等で購入されたFlashAirに本サイトの記載内容を適用してソフトウェアの書き込みや設定変更を行った場合は、保証規定に基づく無償交換の対象外になります。ご了承の上、お客様の責任において開発を行ってください。 Lua言語で書かれたスクリプトファイルをFlashAirに保存することで、 下記のような簡易なバッチ処理が行えます。 FlashAirに保存されたファイルを、任意のサーバー等にアップロード。（ダイレクトアップロード） FlashAirにファイルを生成する。 動的にHTMLファイルを生成する。 本機能は、FlashAir W-03以上で利用できます。 Lua言語について 利用できる機能 制約事項 Lua関数リファレンス Lua言語について Luaは、パワフルで、高速で、軽量で、埋め込み可能な、スクリプト言語です。 Luaは、シンプルな手続き型構文をと強力なデータ記述構造を、連想配列と拡張可能なセマンティクスを用いて組み合わせています。 Luaは動的型付けであり、レジスタベースの仮想マシン向けのバイトコードを解釈することによって実行されます。 また、インクリメンタルガベッジコレクションによる自動メモリ管理を備えており、 設定、スクリプティング、ラピッドプロトタイピングに最適です。 原文: Lua: about - http://www.lua.org/ Lua言語の詳細は、関連情報をご覧ください。 Wikipedia Programming in Lua プログラミング言語Lua公式解説書(Amazon.co.jp) 利用できる機能 FlashAirのLua機能では、下記のライブラリ関数が利用できます。 Lua基本ライブラリ Version: 5.2.1（http://www.lua.org/） LuaFileSystem Version: 1.61（http://keplerproject.github.io/luafilesystem/） CJSON Version: 1.0.3（http://www.kyne.com.au/~mark/software/lua-cjson.php） FlashAir独自機能 Lua関数リファレンス パーティション操作 制約事項 メモリ制約のため、標準ライブラリの以下の機能は使用できません。 数学関数は、FlashAir W-04から使用可能になりました。 コルーチン操作 OS機能 デバッグライブラリ Lua関数リファレンス 内容は予告なく変更される可能性があります。 関数名 機能 ファームウェアバージョン Bridge インターネット同時接続モードで無線LANの有効化 3.00.00+ Connect STAモードで無線LANの有効化 3.00.00+ ConnectedSTA AP接続時の接続ステーション数 4.00.00+ control(“fioget”) 無線LAN On/Off状態の取得 4.00.00+ control(“fioset”) 無線LAN On/Off 4.00.00+ control(“hid_change_pass”) 秘匿領域に設定したパスワードの変更 4.00.04+ control(“hid_clear”) パスワード、APIで保存したスクリプトファイルを全て削除 4.00.04+ control(“hid_get”) 秘匿領域に保存したスクリプトを取得 4.00.04+ control(“hid_hash”) 設定したパスワードと指定する文字列からハッシュ文字列を作成 4.00.04+ control(“hid_set_pass”) 秘匿領域への保存のためのパスワードを設定 4.00.04+ control(“hid_store”) スクリプトを秘匿領域へ保存 4.00.04+ control(“time”) 日時メモ保存 4.00.00+ Disconnect 無線LANの停止 3.00.00+ Establish APモードで無線LANの有効化 3.00.00+ ftp FTPを使用したファイルのアップロード、ダウンロード 3.00.00+ GetScanInfo SSIDスキャン結果の取得 3.00.00+ hash ハッシュの計算 3.00.00+ HTTPGetFile HTTPを使用したファイルのダウンロード 3.00.00+ i2c I2C操作 4.00.00+ ip IPアドレスを取得または設定 3.00.00+ MailSend メールの送信 3.00.01+ deletedmd5 MD5ハッシュの計算 3.00.00 ping 指定IPへPINGを発行 3.00.00+ pio SDインターフェースのGPIO制御 3.00.00+ pwm(“duty”) pwm操作時の周波数とデューティ比を設定 4.00.03+ pwm(“init”) pwmの有効化、チャンネル数の設定 4.00.03+ pwm(“start”) pwm操作時の指定チャンネルを動作 4.00.03+ pwm(“stop”) pwm操作時の指定チャンネルを停止 4.00.03+ ReadStatusReg FlashAir自身のステータスレジスタを取得 3.00.00+ remove ファイルの削除 3.00.00+ rename ファイル名の変更 3.00.00+ request HTTPリクエストの発行 3.00.00+ Scan SSIDスキャンの実行 3.00.00+ search ファイルサーチ機能 4.00.00+ serial(“init”) シリアルの有効化、ボーレートの設定 4.00.03+ serial(“read”) シリアル操作時のデータの受信 4.00.03+ serial(“write”) シリアル操作時のデータの送信 4.00.03+ SetCert ルート証明登録 3.00.00+ SetChannel 無線チャネルを設定する 3.00.01+ sharedmemory 共有メモリのデータを読み込み或いは書き込み 3.00.00+ sleep 指定時間だけスクリプトの実行を停止 3.00.00+ spi SPI操作を行う 3.00.01+ spi(“bit”) 転送ビット数の指定 4.00.03+ spi(“cs”) チップセレクト信号の制御 4.00.03+ spi(“init”) インターフェースを初期化し、クロック周期の変更を行う 4.00.03+ spi(“mode”) SPIモードの指定 4.00.03+ spi(“read”) ライトおよびリード 4.00.03+ spi(“write”) ライトおよびリード 4.00.03+ strconvert 文字列変換 3.00.00+ udp UDP送信 4.00.04+ udp {mode=”recv”} UDP受信 4.00.04+ udp {mode=”send”} UDP送信 4.00.04+ udp {mode=”send_interval”} UDP指定間隔送信 4.00.04+ udp {mode=”stop”} UDP送受信停止 4.00.04+ udp(“state”) UDP送受信状態取得 4.00.04+ watchdog(“event”) WatchDogのタイマーリセット 4.00.03+ watchdog(“start”) WatchDogのタイマースタート 4.00.03+ watchdog(“status”) WatchDogの状態取得 4.00.03+ watchdog(“stop”) WatchDogのタイマー停止 4.00.03+ websocket WebSocket機能 4.00.00+ WlanLink 接続確認 3.00.00+ Bridge インターネット同時接続モードで無線LANを有効化します。 書式 fa.Bridge(ssid, networkkey, encmode, brgssid, brgnetworkkey) 引数 ssid string。 FlashAirのSSID。 networkkey string。 FlashAirのセキュリティキー。 encmode string。 FlashAirのセキュリティモード。 指定可能な値についてはEstablishを参照して下さい。 brgssid string。 接続先無線LAN APのSSID。 brgnetworkkey string。 接続先無線LAN APのセキュリティキー。 戻り値 なし Connect STAモードで無線LANを有効化します。 書式 fa.Connect(ssid, networkkey) 引数 ssid string。 接続先無線LAN APのSSID名。 networkkey string。 接続先無線LAN APのセキュリティキー。 戻り値 なし ConnectedSTA AP接続時の接続されているステーション数、ip、macを返します。 書式 cnt,tbl = fa.ConnectedSTA() 戻り値 cnt 接続しているステーションの個数を返却する。 Tbl 取得したクライアントのテーブルを返却する。cntが0に場合nilを返却する。 例 AP起動時に何台接続しているか確認する。 local cnt, tbl = fa.ConnectedSTA() print(cnt,tbl) for i,t in ipairs(tbl) do for k,v in pairs(t) do print(k,v) end end 結果 1 table: 856B1C mac 40:48:0f:7b:37:92 ip 192.168.0.11 control(“fioget”) 無線LANのOn/Off状態を取得します。 書式 result = fa.control(&quot;fioget&quot;) 引数 第1引数は”fioget”固定。 戻り値 result number。現在の無線LANの状態。 1：無線LANはOn。 0：無線LANはOff。 control(“fioset”) 無線LANのOn/Offを行います。 書式 result = fa.control(&quot;fioset&quot;, enable) 引数 第1引数は”fioset”固定。&lt;/dd&gt; enable number。1 または 0を指定。 1：無線LANをOnにする。モードやSSIDなどの設定はCONFIGファイルの内容が適用される。 0：無線LANをOffにする。 戻り値 result number。現在の無線LANの状態。 1：無線LANはOn。 0：無線LANはOff。 control(“hid_change_pass”) 秘匿領域に設定したパスワードを変更します。 書式 ret = fa.control(&quot;hid_change_pass&quot;, old_password, new_password) 引数 第1引数は”hid_change_pass”固定。 old_password string。設定済みパスワード。 new_password string。新規パスワード。 戻り値 ret number。 0 成功。 1 設定エラー。 -1 パスワード長エラー。 control(“hid_clear”) パスワード、APIで保存したスクリプトファイルを全て削除します。 書式 fa.control(&quot;hid_clear&quot;) 引数 第1引数は”hid_clear”固定。 戻り値 なし control(“hid_get”) 秘匿領域に保存したスクリプトを取得します。 書式 fa.control(&quot;hid_get&quot;, filename , dstfilename, password) 引数 第1引数は”hid_get”固定。 filename string。保存しているスクリプト。 dstfilename string。コピー先ファイル名。 password string。パスワード。 戻り値 なし 例 fa.control(&quot;hid_get&quot;, &quot;h:sys.lua&quot;, &quot;tmp/option.lua&quot;, &quot;mysecret&quot;) 注意事項 ホストからアクセス可能な領域で実行されたLuaスクリプトから、秘匿領域へ保存されたファイルへアクセスは出来ません。 control(“hid_hash”) 秘匿領域に設定したパスワードと指定する文字列からハッシュ文字列を作成します。 書式 ret = fa.control(&quot;hid_hash&quot;, string) 引数 第1引数は”hid_change_pass”固定。 string string。設定文字列。 戻り値 ret string。ハッシュ値。 control(“hid_set_pass”) 秘匿領域への保存のためのパスワードを設定します。 書式 fa.control(&quot;hid_set_pass&quot;, password) 引数 第1引数は”hid_set_pass”固定。 password string。パスワード。 戻り値 なし control(“hid_store”) スクリプトを秘匿領域へ保存します。 書式 a.control(&quot;hid_store&quot;,　filename,　password) 引数 第1引数は”hid_store”固定。 filename string。保存するスクリプト。 password string。パスワード。 戻り値 なし 例 fa.control(&quot;hid_store&quot;, &quot;test.lua&quot;, &quot;12345678&quot;) 保存したファイルをCONFIGで指定する LUA_RUN_SCRIPT=H:filename LUA_SD_EVNET=H:filename control(“time”) 日時メモの保存または取得を行います。 書式 result = fa.control(&quot;time&quot;[, savetime]) 引数 第1引数は”time”固定。 savetime number。保存する日時。FAT形式で指定する。 savetime引数ありの場合、指定された日時を保存する。 savetime引数なしの場合、保存された日時を取得する。 FAT形式の日時について 32ビットの整数値で、上位16ビットが日付、下位16ビットが時刻。 日付と時刻は、command.cgiのop=100を実行した際に取得できる値と同じフォーマット。 戻り値 result number。取得した日時。 savetime引数ありの場合、指定された日時そのものを返す。 savetime引数なしの場合、保存された日時を返す。 日時が保存されていない場合は、-1を返す。 エラーの場合は nil を返す。 例 “2017/06/01 12:34:56” を保存する。 result = fa.control(&quot;time&quot;, 0x4ac1645c) 保存された日時を取得する。 result = fa.control(&quot;time&quot;) if result ~= nil then print(string.format(&quot;time: 0x%08x&quot;, result)) end Disconnect 無線LANを停止します。 書式 fa.Disconnect() 引数 なし 戻り値 なし Establish APモードで無線LANを有効化します。 書式 fa.Establish(ssid, networkkey, encmode) 引数 ssid string。 FlashAirのSSID。 networkkey string。 FlashAirのセキュリティキー。 encmode number。 FlashAirのセキュリティモード。 戻り値 なし 備考 FlashAirセキュリティモードには、下記のうち一つを指定します。 値 意味 0 オープンシステム、暗号化なし 1 オープンシステム、WEP 3 WPA-PSK、TKIP 4 WPA-PSK、AES 5 WPA2-PSK、TKIP 6 WPA2-PSK、AES ftp FTP (File Transfer Protocol) によるファイルのダウンロードまたはアップロードを実行します。 書式 result = fa.ftp(cmd, uri, filename) 引数 cmd string。 FTPコマンド。 &quot;get&quot; ファイルのダウンロード。 &quot;put&quot; ファイルのアップロード。 url string。 FTPサーバーのURI。 filename string。 FlashAirカード内のファイルパス。 戻り値 result number。 1 正常動作。 nil エラー。 備考 FlashAirの対応しているデータ転送モードはパッシブ（PASV）モードのみとなります。 FTPS接続を使用する場合はURLをftps://とすると実行可能です。implicit, explicitモード両方とも利用可能です。 ポート指定はホスト名の後ろにポート番号を付けてください。 動作例 result = fa.ftp(&quot;get&quot;, &quot;ftp://user:pass@ftp.test.com:21/test.txt&quot;, &quot;test.txt&quot;); result = fa.ftp(&quot;put&quot;, &quot;ftps://user:pass@ftp.test.com:990/test.txt;implicit&quot;, &quot;test.txt&quot;); result = fa.ftp(&quot;put&quot;, &quot;ftps://user:pass@ftp.test.com:990/test.txt;explicit&quot;, &quot;test.txt&quot;); GetScanInfo Scan関数で得られた情報を取得します。 書式 ssid, other = fa.GetScanInfo(num) 引数 num number。 Scanリストの番号を指定。 戻り値 ssid string。 SSID。 other table。 Scan結果情報。 備考 Connect, Establish, または Bridge コマンドにより無線LANが有効になっていると利用できません。 例 count = fa.Scan() for i=0,count-1 do ssid,other = fa.GetScanInfo(i) for key, val in pairs(other) do print(key, val) end end hash ハッシュ値を計算します。 書式 hash = fa.hash(name, data, key) 引数 name string。 hashの種類選択(md5,sha1,sha256,hmac-sha256)。 data string。 データ。 key string。 秘密鍵（nameがhmac-sha256時利用）。 戻り値 hash string。 16進数で表したハッシュ値。 HTTPGetFile HTTPを使用してファイルをダウンロードします。 書式 result = fa.HTTPGetFile(uri, filepath [, user, pass]) 引数 uri string。 取得元のURI。 filepath string。 保存先ファイル名。 user string。 Basic認証におけるUser文字列。 pass string。 Basic認証におけるPass文字列。 戻り値 result number。 1 正常動作。 nil エラー。 注意事項 この関数でHTTPS通信を実行する場合、実行前にfa.SetCert関数でルート証明書を設定することが推奨されています。ルート証明書を設定せずにHTTPS通信を実行した場合、ルート証明書を用いたサーバ証明書の検証が行われないまま、通信が行われます。 ルート証明書を用いてサーバ証明書を検証した結果、検証が失敗した場合、この関数の実行は失敗となります。 i2c FlashAirよりI2C操作を行います。i2cはMasterとして動作します。 書式 res, data1, data2, data3, ... = fa.i2c(table) res, string = fa.i2c(table) res, data, ctrl = fa.i2c{mode = &quot;getpio&quot;} 引数 table 以下のフィールドがあります。 mode _string_。I2C操作の属性。 freq _number_。I2Cクロック周波数（単位：kHz）。設定可能な値は、`45`、`100`、`189`、`400`の4つ。省略時は`100`が設定されます。 timeout _number_。スレーブ応答のタイムアウト時間（単位：msec）。省略時は`10`が設定されます。 address _number_。接続デバイスのスレーブアドレスを指定します。 direction _string_。データの方向を指定します。設定可能な値は`&quot;read&quot;`と`&quot;write&quot;`です。`&quot;read&quot;`を指定した場合、接続デバイスからデータを読み出します。`&quot;write&quot;`を指定した場合、接続デバイスへデータを送ります。 data _string_ or _number_。送信データを設定します。string形式で指定した場合は、設定したデータを全て送ります。number形式で指定した場合は`0`～`255`までの値を設定できます。`&quot;setpio&quot;` の場合、0または1でPIOの出力を指定します。 4.00.03 Null文字のサポートしました。 bytes _number_。受信データサイズを指定します。typeが`&quot;binary&quot;`のとき、`1`～`16`までの値を指定できます。typeが`&quot;string&quot;`のとき、最小値は`1`、最大値はメモリ依存となります。省時には`1`が設定されます。 type _string_。受信データ形式を指定します。設定可能な値は`&quot;binary&quot;`、`&quot;string&quot;`です。省略時には、`&quot;binary&quot;`が設定されます。 ctrl4.00.03 _number_。PIOの方向を指定します。0のとき入力、1のとき出力となります。   デバイス初期化 スタートコンディションの送信 リスタートコンディションの送信 接続デバイスからデータ読み出し 接続デバイスへデータ書き込み ストップコンディションを送信し、コネクションを閉じる 4.00.03PIO設定 4.00.03PIO取得 mode &quot;init&quot; &quot;start&quot; &quot;restart&quot; &quot;read&quot; &quot;write&quot; &quot;stop&quot; &quot;setpio&quot; &quot;getpio&quot; freq 省略可 不要 不要 不要 不要 不要 不要 不要 timeout 省略可 不要 不要 不要 不要 不要 不要 不要 address 不要 必須 必須 不要 不要 不要 不要 不要 direction 不要 必須 必須 不要 不要 不要 不要 不要 data 不要 不要 不要 不要 必須 不要 必須 不要 bytes 不要 不要 不要 省略可 省略可 不要 不要 不要 type 不要 不要 不要 省略可 不要 不要 不要 不要 ctrl 不要 不要 不要 不要 不要 不要 必須 不要 備考 ビット割当 CMD: SCL D0: SDA SCL/SDAはプルアップしてください。 CLKはプルダウンしてください。 4.00.03&quot;setpio&quot; /&quot;getpio&quot; ではD1が使用できます。 複数バイト送信 バイナリデータを複数バイト送信したい場合は、データ書き込みを続けて実行することで、複数バイト送信することができます。 戻り値 res string。成功時は&quot;OK&quot;を返します。失敗時はそれ以外の文字列を返します。 data1, data2, data3, … number。0～255までの値が格納されます。接続デバイスからデータ読み出し、type = &quot;binary&quot;指定時のみ使用します。 string string。受信データが格納されます。接続デバイスからデータ読み出し、type = &quot;string&quot;指定時のみ使用します。 data 4.00.03 number。PIOの取得値が格納されます。type = &quot;getpio&quot;指定時のみ使用します。 control 4.00.03 number。PIOの方向設定値が格納されます。0 のとき入力、1 のとき出力となります。type = &quot;getpio&quot;指定時のみ使用します。 例 res = fa.i2c{mode = &quot;init&quot;, freq = 100} res = fa.i2c{mode = &quot;start&quot;, address = 50, direction = &quot;write&quot;} res = fa.i2c{mode = &quot;restart&quot;, address = 50, direction = &quot;read&quot;} res, data1, data2, data3, ... = fa.i2c{mode = &quot;read&quot;, type = &quot;binary&quot;} res, string = fa.i2c{mode = &quot;read&quot;, type = &quot;string&quot;} res = fa.i2c{mode = &quot;write&quot;, data = 0} res = fa.i2c{mode = &quot;stop&quot;} アドレス50のスレーブから5バイト読み出す res = fa.i2c{mode = &quot;init&quot;, freq = 100} res = fa.i2c{mode = &quot;start&quot;, address = 50, direction = &quot;read&quot;} res, r1, r2, r3, r4, r5 = fa.i2c{mode = &quot;read&quot;, bytes = 5, type = &quot;binary&quot;} res = fa.i2c{mode = &quot;stop&quot;} アドレス50のスレーブに0を書き込んでから1バイト読み出す res = fa.i2c{mode = &quot;init&quot;, freq = 100} res = fa.i2c{mode = &quot;start&quot;, address = 50, direction = &quot;write&quot;} res = fa.i2c{mode = &quot;write&quot;, data = 0} res = fa.i2c{mode = &quot;restart&quot;, address = 50, direction = &quot;read&quot;} res, data = fa.i2c{mode = &quot;read&quot;, bytes = 1, type = &quot;binary&quot;} fa.i2c{mode = &quot;stop&quot;} PIOの操作 4.00.03 res = fa.i2c {mode =&quot;init&quot;, freq=100} res = fa.i2c {mode =&quot;setpio&quot;, data=1, ctrl=1} -- 出力High res = fa.i2c {mode =&quot;setpio&quot;, data=0, ctrl=1} -- 出力Low res = fa.i2c {mode =&quot;setpio&quot;, data=0, ctrl=0} -- 入力 res, data, ctrl = fa.i2c {mode=&quot;getpio&quot;} ip FlashAir自身のIPアドレスを取得または設定します。 書式 ip, mask, gw = fa.ip(ipaddress, subnetmask, gateway) 引数 ipaddress string。 FlashAirに設定するIPアドレス。 subnetmask string。 サブネットマスク値。 gateway string。 ゲートウェイのIPアドレス。 戻り値 ip string。 IPアドレス。 mask string。 サブネットマスク。 gw string。 ゲートウェイ。 例 -- 値取得時 ip, mask, gw = fa.ip() -- 値設定時 fa.ip(&quot;192.168.11.2&quot;, &quot;255.255.255.0&quot;, &quot;192.168.11.1&quot;) MailSend FlashAirよりメール送信を行う（ファイルの添付も可能）。 書式 fa.MailSend(table) 引数 table 以下のフィールドがあります。 from _string_。 送信元メールアドレス。 headers _string_。 メールヘッダ。 body _string_。 メール本文。 server _string_。 メールサーバ(smtp)。 user _string_。 ユーザーID。 password _string_。 パスワード。 attachment _string_。 添付ファイル指定（任意）。 ContentType _string_。 コンテンツタイプ指定（attachment指定時に有効で必須）。 port 4.00.03 _number_。ポート番号を指定します。デフォルトは465。 レスポンス 成功： MailSend is success. 失敗： Error: It failed to send. 動作例 from = &quot;fromaddr@yahoo.co.jp&quot; rcpt = &quot;toaddr@gmail.com&quot; a = fa.MailSend { from = from, headers = &quot;To: &quot;..rcpt..&quot; r nFrom: &quot;..from..&quot; r nSubject: test&quot;, body = &quot;HELLO HELLO&quot;, server = &quot;smtp.mail.yahoo.co.jp&quot;, user = &quot;flashair&quot;, password =&quot;1234567890&quot;, attachment = &quot;FBYF.jpg&quot;, ContentType = &quot;image/jpg&quot; } md5 hash（ハッシュの計算）へ統合されました。 ping 指定IPへPINGを発行します。 書式 result = fa.ping(ip) 引数 ip string。 ipアドレス。 戻り値 result number。 1 正常動作。 nil エラー。 動作例 result = fa.ping(&quot;192.168.130.1&quot;) pio SDインターフェースのPIO (Programmed Input/Output) 制御を行います。 書式 s, indata = fa.pio(ctrl, data) 引数 ctrl number。 ピンの入出力指定。 読み込みたい端子に対応するビットに0 を、 書き込みたい端子に対応するビットに1 を指定します。 data number。 出力ピン状態の指定。 書き込みたい端子に対応する各ビットに、0 を設定するとLow、1 を設定するとHighを出力します。 戻り値 s number。 インターフェース制御の状態。 1 成功。 0 失敗。 indata number。 入力ピン情報。 備考 ビット割当 CMD : 0x01 D0 : 0x02 D1 : 0x04 D2 : 0x08 D3 : 0x10 pwm(“duty”) FlashAirでpwm操作を行う際、周波数とデューティ比を設定します。 書式 res = fa.pwm(&quot;duty&quot;, ch, freq, duty) 引数 ch number。動作指定するPin情報です。0～4のチャンネルを指定できます。 freq number。周波数(Hz単位)。浮動小数点で指定可能。 duty number。デューティ比(0～100%)。浮動小数点で指定可能。 戻り値 res number。 1 成功。 nil 失敗。 pwm(“init”) FlashAirでpwm操作を行う際、pwmの有効化、チャンネル数の設定を行います。 書式 ret = fa.pwm(&quot;init&quot;, ch, enable) 引数 ch number。pwmモードを設定するチャンネルを1つ指定します。0～4のチャンネルを指定できます。 enable number。1 または 0を指定。 1 pwmモードを有効にする。 0 pwmモードを無効にする。 戻り値 res number。 1 成功。 nil 失敗。 注意事項 CONFIGにIFMODE=1を設定する必要があります。 ビット割当 CMD: 0ch D0: 1ch D1: 2ch D2: 3ch D3: 4ch pwm(“start”) FlashAirでpwm操作を行う際、指定したチャンネルを動作させます。0～4のチャンネルを指定できます。 書式 res = fa.pwm(&quot;start&quot;, ch) 引数 ch number。動作指定するPin情報です。0～4のチャンネルを指定できます。 戻り値 res number。 1 成功。 nil 失敗。 pwm(“stop”) FlashAirでpwm操作を行う際、指定したチャンネルを停止させます。0～4のチャンネルを指定できます。 書式 res = fa.pwm(&quot;stop&quot;, ch) 引数 ch number。停止指定するPin情報です。0～4のチャンネルを指定できます。 戻り値 res number。 1 成功。 nil 失敗。 ReadStatusReg FlashAir自身のステータスレジスタを取得する。 書式 reg = fa.ReadStatusReg() 引数 なし 戻り値 無線LAN機能ステータスレジスタの内容を、文字列として返します。内容は無線LAN機能ステータスレジスタ（ApplicationStatus for Wireless LAN）を参照してください。 動作例 IPアドレスを取得する場合 local ipaddress = string.sub(fa.ReadStatusReg(),160,168) remove 指定されたファイルを削除します。 書式 fa.remove(filepath) 引数 filepath string。 削除対象のファイル名。 戻り値 なし 動作例 fa.remove(&quot;/DCIM/100__TSB/DSC_100.JPG&quot;)&gt; rename 指定されたファイルのパスを変更します。 書式 fa.rename(oldfile, newfile) 引数 oldfile string。 元ファイル名。 newfile string。 新ファイル名。 戻り値 なし 動作例 fa.rename(&quot;/DCIM/100__TSB/DSC_100.JPG&quot;,&quot;/DCIM/100__TSB/DSC_101.JPG&quot;) request HTTP (Hyper Text Transfer Protocol) リクエストを発行します。 書式 b, c, h = fa.request(url [, method [, headers [, file [, body [, bufsize [, redirect [, rcvbuff [, rcvfile]]]]]]]]) 引数 url string。 URLの文字列。（ポート指定可能:8080） method string。 HTTPリクエストメソッド。省略すると&quot;GET&quot; とみなします。 headers table。 HTTPリクエストのヘッダーフィールド情報を追加できます。 file string。 HTTPリクエストのボディに指定されたファイルを追加して送信します。 body string。 HTTPリクエストのボディに指定された文字列を追加して送信します。 fileオプションと併用するとbody内部の文字列&lt;!--WLANSDFILE--&gt; をファイルに置換して送信します。bodyが指定されていない場合は、単にfileが送信されます。 bufsize number。 HTTPリクエストの送信バッファ・サイズ。flickrサーバーへ送信する場合はこの値を1460*10とします。 redirect boolean。 HTTPのリダイレクト動作の有効無効を制御する。省略するとtrue を指定したものとみなします。 rcvbuff 4.00.03 string。Luaのスタック上にメモリを確保し、受信データを確保したメモリに保存します。 rcvfile 4.00.03 string。受信したHTTPレスポンスのデータを指定したファイルへの保存を行います。 戻り値 b string。 HTTP response bodyの文字列。 c number。 HTTPステータスコード。 h string。 HTTP response headerの文字列。 例 boundary = &quot;--61141483716826&quot; contenttype = &quot;multipart/form-data; boundary=&quot; .. boundary filepath = &quot;sample.txt&quot; mes = &quot;--&quot;.. boundary .. &quot;¥r¥n&quot; ..&quot;Content-Disposition: form-data; name=¥&quot;file¥&quot;; filename=¥&quot;&quot;..file ..&quot;¥&quot;¥r¥n&quot; ..&quot;Content-Type: text/plain¥r¥n&quot; ..&quot;¥r¥n&quot; ..&quot;&lt;!--WLANSDFILE--&gt;¥r¥n&quot; ..&quot;--&quot; .. boundary .. &quot;--¥r¥n&quot; blen = lfs.attributes(file,&quot;size&quot;) + string.len(mes) - 17 b,c,h = fa.request{url = &quot;http://192.168.0.1/upload.cgi:8080&quot;, method = &quot;POST&quot;, headers = {[&quot;Content-Length&quot;] = tostring(blen), [&quot;Content-Type&quot;] = contenttype}, file = filepath, body = mes } 備考 HTTP Responseの転送サイズは、3KBまで対応。 Flickrへの送信においてTCPリセットが行われることがあります。bufsizeオプションで送信バッファサイズを1460*10程度に小さくすると回避できる場合があります。 注意事項 この関数でHTTPS通信を実行する場合、実行前にfa.SetCert関数でルート証明書を設定することが推奨されています。ルート証明書を設定せずにHTTPS通信を実行した場合、ルート証明書を用いたサーバ証明書の検証が行われないまま、通信が行われます。 ルート証明書を用いてサーバ証明書を検証した結果、検証が失敗した場合、この関数の実行は失敗となります。 Scan Scan開始コマンド。結果はGetScanInfo()で取得します。 書式 count = fa.Scan([ssid]) 引数 ssid string。 指定したSSIDについてスキャンを行います。 省略した場合は近傍のSSIDをスキャンします。 戻り値 count number。 スキャンで見つかったAP数。 備考 Connect, Establish, または Bridge コマンドにより無線LANが有効になっていると利用できません。 search 指定したディレクトリ内で、更新日時によるファイル検索を行います。更新日時が最新であるファイルの検索、または引数で指定した更新日時によるファイルの検索が可能です。 書式 result, filelist, time = fa.search(type, path, searchtime) 引数 type string。検索タイプ。file固定。 file：ファイルの検索 path string。検索対象のディレクトリ。 searchtime number。検索対象更新日時。-1またはFAT形式の日時を指定する。 -1を指定した場合、更新日時が最新のファイルを検索する。 -1以外を指定した場合、以下の両方を検索する。 指定された更新日時と一致するファイル 指定された更新日時より新しいファイルのうち最も古いファイル（指定された日時の次に新しいファイル） FAT形式の日時について 32ビットの整数値で、上位16ビットが日付、下位16ビットが時刻。 日付と時刻は、command.cgiのop=100を実行した際に取得できる値と同じフォーマット。 戻り値 result number。ステータス。 1 正常終了 -1 ファイルリストの作成時にオーバーフロー searchtimeに-1を指定した場合、「更新日時が最新のファイル」のリスト作成で文字列バッファのオーバーフロー searchtimeに-1以外を指定した場合、「指定された更新日時より新しいファイルのうち最も古いファイル」のリスト作成で文字列バッファのオーバーフロー -2 ファイルリストの作成時にオーバーフロー(searchtimeに-1以外を指定した場合のみ返す可能性がある) 「指定された更新日時と一致するファイル」のリスト作成で文字列バッファのオーバーフロー -3 ディレクトリオープンエラー -4 ディレクトリリードエラー filelist string。カンマ区切りのファイルリスト。 条件に一致するファイルのリストをカンマ区切りの文字列で返す。 searchtimeに-1以外を指定した場合、「指定された更新日時と一致するファイル」のリストと「指定された更新日時より新しいファイルのうち最も古いファイル」のリストを連結した文字列を返す。 該当ファイルがない場合は、”“(空文字列)を返す。 オーバーフロー以外のエラーの場合はnilを返す。 time number。検索結果日時。 searchtimeに-1を指定した場合、「更新日時が最新のファイル」の更新日時を返す。 searchtimeに-1以外を指定した場合、 「指定された更新日時より新しいファイルのうち最も古いファイル」の更新日時を返す。 条件に一致するファイルがない場合は0を返す。 オーバーフロー以外のエラーの場合はnilを返す。 備考 ファイルリストの作成時に512文字を超えた場合はバッファオーバーフローとなり、リストは途中で打ち切られる。 検索するディレクトリの深さは3階層まで。 例 “/DCIM” から最新のファイルを検索する。 local result, filelist, time = fa.search(&quot;file&quot;, &quot;/DCIM&quot;, -1) if result ~= 1 then print(&quot;error: &quot;, result) end if filelist ~= nil then for f in string.gmatch(filelist, &#39;(.-),&#39;) do print(f) end end if time ~= nil then print(string.format(&quot;time: 0x%08x&quot;, time)) end “DCIM”から更新日時が 2017/06/01 12:34:56 であるファイルと、その日時より新しいファイルのうち最も古いファイルを検索する。 local result, filelist, time = fa.search(&quot;file&quot;, &quot;/DCIM&quot;, 0x4ac1645c) if result ~= 1 then print(&quot;error: &quot;, result) end if filelist ~= nil then for f in string.gmatch(filelist, &#39;(.-),&#39;) do print(f) end end if time ~= nil then print(string.format(&quot;time: 0x%08x&quot;, time)) end 参考 FAT形式の日時変換例 文字列の日時をFAT形式に変換する local function StringToFatDateTime(datetime_str) local pattern = &#39;(%d+)/(%d+)/(%d+)%s+(%d+):(%d+):(%d+)&#39; local year,month,day,hour,min,sec = string.match(datetime_str, pattern) year = year - 1980 sec = bit32.rshift(sec, 1) local date_fat = bit32.bor(bit32.lshift(year, 9), bit32.lshift(month, 5), day) local time_fat = bit32.bor(bit32.lshift(hour, 11), bit32.lshift(min, 5), sec) local datetime_fat = bit32.bor(bit32.lshift(date_fat, 16), time_fat) return datetime_fat end FAT形式の日時を文字列に変換する local function FatDateTimeToString(datetime_fat) local function getbits(x, from, to) local mask = bit32.lshift(1, to - from + 1) - 1 local shifted = bit32.rshift(x, from) return bit32.band(shifted, mask) end local fatdate = bit32.rshift(datetime_fat, 16) local day = getbits(fatdate, 0, 4) local month = getbits(fatdate, 5, 8) local year = getbits(fatdate, 9, 15) + 1980 local fattime = getbits(datetime_fat, 0, 15) local sec = getbits(fattime, 0, 4) * 2 local min = getbits(fattime, 5, 10) local hour = getbits(fattime, 11, 15) return string.format(&#39;%02d/%02d/%02d %02d:%02d:%02d&#39;, year, month, day, hour, min, sec) end serial(“init”) FlashAirでシリアル操作を行う際、シリアルの有効化、ボーレートの設定を行います。 書式 fa.serial(&quot;init&quot;, [boudrate]) 引数 boudrate number。ボーレート（未設定時は115200ボー）。 戻り値 なし 注意事項 CONFIGにIFMODE=1を設定する必要があります。 ビット割当 CMD: RX D0: TX GND: GND フロー制御機能はありません。 serial(“read”) FlashAirでシリアル操作を行う際、データの受信を行います。 書式 data = fa.serial(&quot;read&quot;) 引数 なし 戻り値 data number。取得したデータ。データは1byte, number形式で取得します。受信バッファが空のときは、nilが返ります。 serial(“write”) FlashAirでシリアル操作を行う際、データの送信を行います。 書式 fa.serial(&quot;write&quot;, data) 引数 data string or number(0～255) or table。送信するデータ。 戻り値 なし SetCert 証明書のクリアor登録（X.509 binary encode with DER)を行います。 書式 fa.SetCert(filename) 引数 filename string。 DERファイルのパス、ファイル名を指定する。空文字列指定時は証明書をクリアする。 戻り値 result number。 1 正常動作。 nil 失敗。 動作例 -- 証明書の登録 res = fa.SetCert(&quot;DerSha256.cer&quot;) if res == nil then print(&quot;certificate registration error&quot;) end -- 証明書のクリア res = fa.SetCert(&quot;&quot;) if res == nil then print(&quot;certificate clear error&quot;) end SetChannel 無線チャネルを設定する。 書式 fa.SetChannel(channelNo) 引数 channelNo number。 チャネル（0～11 or 0x0～0xb　0指定はAUTO）。 戻り値 なし 動作例 fa.Disconnect() fa.SetChannel(&quot;0xB&quot;) fa.Establish(&quot;flashair3&quot;, &quot;12345678&quot;, &quot;6&quot;) sharedmemory 共有メモリからデータを読み込み或いは書き込みを行います。 4.00.03Null文字のwrite, readをサポートしました。 書式 fa.sharedmemory(command, addr, len, wdata) 引数 command string。 動作コマンド(write, read)。 addr number。 アドレス（0～511）（0～2047）。 len number。 データ長（0～512）（1～2048）。 wdata string。 書込み文字列（コマンドでwrite指定時有効）。 レスポンス write時 成功：1失敗：nil read時 成功：読み出し文字列失敗：nil 動作例 res1 = fa.sharedmemory(&quot;write&quot;, 0, 8, &quot;12345678&quot;) res2 = fa.sharedmemory(&quot;read&quot;, 1, 4, 0) print(&quot;res=&quot;,res2) 　　 　結果：res=2345 sleep 指定時間だけスクリプトの実行を停止します。 書式 sleep(msec) 引数 msec number。 停止時間を0～(232 - 1)の範囲のミリ秒単位で指定します。 戻り値 なし spi FlashAirよりSPI操作を行う。 書式 result = fa.spi(command, data) 引数 command init クロック周期の変更を行う（デフォルト値：1000）。 ビット割当 * D0 : CLK * D1 : CS * D2 : MISO * CMD : MOSI {: .ml-4 } mode SPIモードの指定（引数：０～３。デフォルト値：３）。 bit 転送ビット数（デフォルト値：８）。 write ライト。 read リード。 cs チップセレクト信号の制御（引数１でCS＝ON、０でCS=OFF）。 data string。 データ。 レスポンス write ライトコマンド発行時の受信データ。 read リードコマンド発行時の受信データ。 otherwise ステータス 動作例 fa.spi(&quot;init&quot;, 1001) spi(“bit”) 転送ビット数を指定します。（デフォルト値：8） 書式 res = fa.spi(&quot;bit&quot;, bit) 引数 bit number。範囲1 ～32 。転送ビット数。 戻り値 res number。 1 成功。 0 失敗。 注意事項 spi(“write”) で文字列を指定する場合、bit指定との併用は不可となります。 spi(“cs”) チップセレクト信号を制御します。 書式 fa.spi(&quot;cs&quot;, cs_level) 引数 cs_level number。 1 High 0 Low 例 local CS_ASSERT=0 local CS_NEGATE=1 fa.spi(&quot;mode&quot;, 2) fa.spi(&quot;init&quot;, 1000) fa.spi(&quot;cs&quot;, CS_ASSERT) fa.spi(&quot;write&quot;, &quot;hello&quot;, 5) fa.spi(&quot;cs&quot;, CS_NEGATE) spi(“init”) インターフェースを初期化し、クロック周期の変更を行う（デフォルト値：1000）。CSはHighとなる。 書式 res = fa.spi(&quot;init&quot;[, period]) 引数 period number。 省略可。クロック周期。 戻り値 res number。 1 成功。 0 失敗。 spi(“mode”) SPIモードを指定します。（デフォルト値：3） 書式 res = fa.spi(&quot;mode&quot;, mode) 引数 mode number。範囲0 ～3 。SPIモード。 戻り値 res number。 1 成功。 0 失敗。 注意事項 spi(“init”) の実行前にspi(“mode”)を実行してください。 spi(“read”) ライトおよびリード。複数回転送でき、全てのリード結果を取得できます。送信データは固定値を繰り返し送信します。 書式 res_num = fa.spi(&quot;read&quot;) res_tbl = fa.spi(&quot;read&quot;, xfer_num, data_num) 引数 xfer_num number。転送回数。 data_num number。送信データ。 戻り値 res_num number。リードした値。 res_tbl table。リードした値の配列。 送信データについて fa.spi(“read”) の書式では、全ビット0が送信されます。 fa.spi(“read”, xfer_num, data_num) の書式では、data_numが繰り返し送信されます。 例 res_num = fa.spi(&quot;read&quot;) print(res_num) res_tbl = fa.spi(&quot;read&quot;, 10, 0xff) for i, v in ipairs(res_tbl) do print(i, v) end spi(“write”) ライトおよびリード。複数回転送できますが、リード結果は最後の1回のみ取得できます。 書式 res = fa.spi(&quot;write&quot;, data_num) res = fa.spi(&quot;write&quot;, data_str, xfer_num) 引数 data_num number。送信データ。 data_str string。送信データを文字列で指定。1バイトずつ複数回に分けて転送される。 xfer_num number。送信バイト数。data_strの文字列長を超えた場合には送信データは0x00となる。 戻り値 res number。リードした値。（1度の関数呼び出しで複数回転送した場合は、最後にリードした値） 例 res = fa.spi(&quot;write&quot;, 0x12) result = fa.spi(&quot;write&quot;, &quot;hello&quot;, 8) 注意事項 data_strを使用する場合、bit指定との併用は不可となります。 strconvert SJIS文字をUTF-8文字へ変換とutf8文字をSJIS文字へ変換する。 書式 fa.strconvert(format, orgstr) 引数 format string。 「sjis2utf8」を指定するとsjis文字をutf8文字へ変換する、「utf82sjis」を指定するとutf8文字をsjis文字へ変換する。 orgstr string。 変換元文字列。 レスポンス 成功：変換文字列 失敗：nil 動作例 str = &quot;あかさたなはまやらわ&quot; print(&quot;testStr=&quot;, str) a = fa.strconvert(&quot;sjis2utf8&quot;, str ) print(&quot;toUTF8=&quot;, a) b = fa.strconvert(&quot;utf82sjis&quot;, a) print(&quot;toSJIS=&quot;, b) udp UDPの送信を行います。 書式 res = fa.udp(address, port, type, data) 引数 address string。 送信先アドレス。 port number。 送信先ポート。 type string。データタイプ。 “message”：文字列を送信する。 “file”: ファイルを送信する。 data string。 type=”message”のときは送信データ、type=”file”のときは送信するファイル名。 戻り値 res number_または_nil。 1 成功。 nil 失敗。 例 文字列を送信 res = fa.udp(&quot;192.168.0.11&quot;, 50000, &quot;message&quot;, &quot;hello&quot;) ファイルを送信 res = fa.udp(&quot;192.168.0.11&quot;, 50000, &quot;file&quot;, &quot;hello.txt&quot;) 注意事項 非同期の関数呼び出しとなります。 既にUDP送受信が動作中の場合は実行が失敗します。 udp UDPの送信を行います。 書式 res = fa.udp(address, port, type, data) 引数 address string。 送信先アドレス。 port number。 送信先ポート。 type string。データタイプ。 “message”：文字列を送信する。 “file”: ファイルを送信する。 data string。 type=”message”のときは送信データ、type=”file”のときは送信するファイル名。 戻り値 res number_または_nil。 1 成功。 nil 失敗。 例 文字列を送信 res = fa.udp(&quot;192.168.0.11&quot;, 50000, &quot;message&quot;, &quot;hello&quot;) ファイルを送信 res = fa.udp(&quot;192.168.0.11&quot;, 50000, &quot;file&quot;, &quot;hello.txt&quot;) 注意事項 非同期の関数呼び出しとなります。 既にUDP送受信が動作中の場合は実行が失敗します。 udp {mode=&quot;recv&quot;} UDPの受信を行います。 書式 res = fa.udp(table) 引数 table 以下のフィールドがあります。 mode string。UDP操作の属性。&quot;recv&quot;を指定する。 address string。指定したアドレスからのみ受信する。省略可。省略した場合は全てのアドレスから受信する。 port number。受信待ちポート。 file string。受信したデータを保存するファイル名。&quot;sharedmemory&quot;を指定すると共有メモリに保存する。 offset number。sharedmemory内オフセット。fileに&quot;sharedmemory&quot;を指定した場合のみ指定可。省略可。省略時の値は0。 size number。受信サイズ。指定サイズ受信後に受信動作が停止する。省略可。ファイルに受信する場合でsize省略時は受信するサイズが無制限となる。共有メモリに受信する場合でsize省略時は、2048 - offsetがsize値となる。 timeout number。タイムアウト時間(秒)。指定時間後に受信動作が停止する。省略時はタイムアウト無しとなる。 各フィールドの必須/省略一覧   受信 mode recv address 省略可 port 必須 file 必須 offset fileに”sharedmemory”を指定時のみ指定可（省略可） size 省略可 timeout 省略可 戻り値 res number_または_nil。 1 成功。 nil 失敗。 例 共有メモリに受信（アドレス100から10バイト） res = fa.udp {mode = &quot;recv&quot;, port = 50000, file = &quot;sharedmemory&quot;, offset = 100, size = 10 } ファイルに受信(100バイト受信で終了、タイムアウト30秒) res = fa.udp {mode = &quot;recv&quot;, port = 50000, file = &quot;recv.txt&quot;, size = 100, timeout = 30 } 注意事項 非同期の関数呼び出しとなります。 既にUDP送受信が動作中の場合は実行が失敗します。 fileにファイル名を指定した場合は、受信したデータはファイルに追記されます。 fileにファイル名を指定した場合は、受信が終了するまでファイルに反映されません。 fileにファイル名を指定した場合は、1パケットで受信できるサイズの最大値は1460バイトとなります。 受信動作は、以下の条件により停止します。 受信バイト数がsizeで指定したサイズに達する(sizeを指定した場合) timeoutで指定した時間が経過する(timeoutを指定した場合) fa.udp {mode=”stop”}を実行する udp {mode=&quot;send&quot;} UDPの送信を行います。 書式 res = fa.udp(table) 引数 table 以下のフィールドがあります。 mode string。UDP操作の属性。&quot;send&quot;を指定する。 address string。送信先アドレス。 port number。送信先ポート。 file string。送信データが格納されたファイル名。&quot;sharedmemory&quot;を指定すると共有メモリから送信する。message指定時は指定不可。 message string。送信する文字列。file指定時は指定不可。 offset number。sharedmemory内オフセット。fileに&quot;sharedmemory&quot;を指定した場合のみ指定可。省略可。省略時の値は0。 size number。送信サイズ。省略可。省略時は、fileまたはmessageで指定した内容全てを送信する。fileに&quot;sharedmemory&quot;を指定してsizeを省略した場合は、offsetの位置以降の内容を全て送信する。 各フィールドの必須/省略一覧   送信 mode send address 必須 port 必須 file fileとmessageのどちらか一方のみ指定 message fileとmessageのどちらか一方のみ指定 offset fileに”sharedmemory”を指定時のみ指定可（省略可） size 省略可 戻り値 res number_または_nil。 1 成功。 nil 失敗。 例 文字列を送信 res = fa.udp {mode = &quot;send&quot;, address = &quot;192.168.0.11&quot;, port = 50000, message = &quot;hello&quot; } ファイルの内容を送信 res = fa.udp {mode = &quot;send&quot;, address = &quot;192.168.0.11&quot;, port = 50000, file = &quot;hello.txt&quot; } 共有メモリの内容を送信 fa.sharedmemory(&quot;write&quot;, 2, 17, &quot;from sharedmemory&quot;) res = fa.udp {mode = &quot;send&quot;, address = &quot;192.168.0.11&quot;, port = 50000, file = &quot;sharedmemory&quot;, offset = 2, size = 17 } 注意事項 非同期の関数呼び出しとなります。 既にUDP送受信が動作中の場合は実行が失敗します。 fileとmessageはどちらか一方を指定してください。 udp {mode=&quot;send_interval&quot;} UDPの送信を指定間隔で行います。 書式 res = fa.udp(table) 引数 table 以下のフィールドがあります。 mode string。UDP操作の属性。&quot;send_interval&quot;を指定する。 address string。送信先アドレス。 port number。送信先ポート。 file string。送信データが格納されたファイル名。&quot;sharedmemory&quot;を指定すると共有メモリから送信する。message指定時は指定不可。 message string。送信する文字列。file指定時は指定不可。 offset number。sharedmemory内オフセット。fileに&quot;sharedmemory&quot;を指定した場合のみ指定可。省略可。省略時の値は0。 size number。送信サイズ。省略可。省略時は、fileまたはmessageで指定した内容全てを送信する。fileに&quot;sharedmemory&quot;を指定してsizeを省略した場合は、offsetの位置以降の内容を全て送信する。 interval number。送信間隔(秒)。省略可。省略時の値は5。 timeout number。タイムアウト時間(秒)。省略時はタイムアウト無しとなる。 各フィールドの必須/省略一覧   指定間隔送信 mode send_interval address 必須 port 必須 file fileとmessageのどちらか一方のみ指定 message fileとmessageのどちらか一方のみ指定 offset fileに”sharedmemory”を指定時のみ指定可（省略可） size 省略可 interval 省略可 timeout 省略可 戻り値 res number_または_nil。 1 成功。 nil 失敗。 例 1秒間隔で10秒間送信 res = fa.udp {mode = &quot;send_interval&quot;, address = &quot;192.168.0.11&quot;, port = 50000, file = &quot;hello.txt&quot;, interval = 1, timeout = 10 } 注意事項 非同期の関数呼び出しとなります。 既にUDP送受信が動作中の場合は実行が失敗します。 fileとmessageはどちらか一方を指定してください。 指定間隔送信動作は、以下の条件により停止します。 timeoutで指定した時間が経過する(timeoutを指定した場合) fa.udp {mode=”stop”}を実行する udp {mode=&quot;stop&quot;} UDPの受信動作または指定間隔送信動作を停止します。 書式 res = fa.udp(table) 引数 table 以下のフィールドがあります。 mode string。UDP操作の属性。&quot;stop&quot;を指定する。 戻り値 res number_または_nil。 1 成功。 nil 失敗。 udp(“state”) UDPの送受信状態を取得します。 書式 state, count = fa.udp(&quot;state&quot;) 引数 第1引数は”state”固定。 戻り値 state number。 1 UDP送受信が非同期で動作中。 nil UDP送受信は動作していない。 count number_または_string。 number 送受信開始時からの送受信バイト数。 string: &quot;destination unreachable n&quot; 送信サイズが0で接続機器が見つからない場合の戻り値。 例 UDPの送受信が終わるまで待機する for i=1, 1000 do local state, count = fa.udp(&quot;state&quot;) if state == 0 then break end sleep(20) end watchdog(“event”) WatchDogのタイマーをリセットします。 書式 result = fa.watchdog(&quot;event&quot;) 引数 第1引数は”event”固定。 戻り値 result number。 1 タイマー再始動。 0 watchdogをスタートしていない（タイマー待ち時間未設定）。 watchdog(“start”) WatchDogのタイマーをスタートさせます。タイムアウトするとFlashAirが再起動します。 書式 result = fa.watchdog(&quot;start&quot;, cycle) 引数 第1引数は”start”固定。 cycle number。 watchdogを発行を秒単位で指定します。 戻り値 result number。 1 タイマー開始。 0 タイマー待ち時間未設定。 備考 WatchDogとは、システムが機能し続けていることを確認するためのタイマーのことです。WatchDogのタイマーをスタートした後システムに異常事態が起こり、WatchDogのタイマーをリセットできなかった場合FlashAirを再起動させます。 使用例 CONFIGにLUA_RUN_SCRIPT=/HelloWorld.luaを追加します。こちらのチュートリアルで使用したHelloWorld.luaをFlashAirルート上に保存します。すでにHello.txtがルート上にある場合はリネームまたは削除してください。 FlashAirルート上に以下のコードを保存します。 /WatchDog.lua fa.watchdog(&quot;start&quot;, 10) print(&quot;watchdog start&quot;) for i = 1, 30 do result = fa.watchdog(&quot;status&quot;) print(&quot;watchdog status:&quot;..result) end result, filelist, time = fa.search(&quot;file&quot;, &quot;/DCIM&quot;, -1) if filelist ~= nill then result = fa.watchdog(&quot;event&quot;) print(&quot;watchdog restart&quot;) else fa.watchdog(&quot;stop&quot;) print(&quot;watchdog stop&quot;) end while 0 ~= fa.watchdog(&quot;status&quot;) do result = fa.watchdog(&quot;status&quot;) print(&quot;watchdog status:&quot;..result) end このスクリプトはWatchdogタイマーを10秒間隔でスタートさせ、Watchdogステータスを数回確認、/DCIM上にファイルが存在したらWatchdogタイマーを再起動させ、Watchdogステータスが0になるまでprintし続けます。 FlashAirを抜き差します。 HelloWorld.luaにより作成されたHello.txtを確認します。（Hello There!が1行表示されている状態です） ブラウザからWatchDog.luaを実行します。 ブラウザ上にprint文で出力した内容が表示されたら抜き差しせずにHello.txtを確認します。（Hello There!が2行表示されている状態です）FlashAirが再起動され、LUA_RUN_SCRIPTが実行されていることが確認できます。 watchdog(“status”) WatchDogの状態を取得します。 書式 result = fa.watchdog(&quot;status&quot;) 引数 第1引数は”status”固定。 戻り値 result number。 0以上 watchdogタイマー発動までの残り時間。 0 発動までの残り時間が１秒未満。 -1 watchdogタイマー待機中。 watchdog(“stop”) WatchDogのタイマーを停止します。 書式 result = fa.watchdog(&quot;stop&quot;) 引数 第1引数は”stop”固定。 戻り値 result number。 0 タイマー停止。 websocket WebSocket通信をします。 書式 res, type, payload = fa.websocket(table) 引数 table 以下のフィールドがあります。 mode string。WebSocket接続の属性。 address string。接続先のサーバアドレス。 payload string or table。メッセージ内容（文字列、配列）。 type number。メッセージタイプ（テキスト＝1、バイナリ＝2、PING＝9、 省略時＝自動判別）。 length number。メッセージの長さ（省略時＝payloadのオブジェクト長）。 tout number。タイムアウト時間（単位：msec）。   オープン メッセージ送信 メッセージ受信 クローズ mode &quot;open&quot; &quot;send&quot; &quot;recv&quot; &quot;close&quot; address 必須 不要 不要 不要 payload 不要 必須 不要 不要 type 不要 省略可 不要 不要 length 不要 省略可 不要 不要 tout 不要 不要 省略可 不要 戻り値 res number。受信成功時は0もしくは正数を返します。受信失敗時は負数を返します。 type number。メッセージタイプ（テキスト＝1、バイナリ＝2）。メッセージ受信のときのみ使用します。 payload string or table。受信メッセージ。受信失敗時はnilを返します。メッセージ受信のときのみ使用します。 例 res = fa.websocket{mode = &quot;open&quot;, address = &quot;ws://localhost/socket&quot;} res = fa.websocket{mode = &quot;send&quot;, payload = &quot;hello!&quot;, type = 1} res, type, payload = fa.websocket{mode = &quot;recv&quot;, tout = 5000} fa.websocket{mode = &quot;close&quot;} WlanLink ネットワークに無線接続されているかを確認します。 書式 result = fa.WlanLink() 引数 なし 戻り値 result number。 1 接続状態。 0 未接続。 パーティション操作 第２パーティションへアクセスを行うことが出来ます。第２パーティションはLuaの内部ログなどを保存し、ホスト機器からのファイルアクセスによる影響がない領域のことです。ドライブレターにより、パーティションを指定することが可能です。 書式 &quot;p&quot; --1stパーティション（省略化） &quot;s&quot; --2ndパーティション &quot;h&quot; --秘匿領域 その他 パーティションの作成は、Linux、Win10などのホスト機器を使用して分割することが可能です。 例 local file = io.open(&quot;s: flashair.log&quot;, &quot;a&quot;)",
    "url": "http://localhost:4000/docs/api/lua.html",
    "relUrl": "/docs/api/lua.html"
  },
  "83": {
    "id": "83",
    "title": "Lua機能チュートリアル",
    "content": "Lua機能チュートリアル Lua機能チュートリアルを紹介しています。",
    "url": "http://localhost:4000/docs/tutorials/lua.html",
    "relUrl": "/docs/tutorials/lua.html"
  },
  "84": {
    "id": "84",
    "title": "FlashAirとは",
    "content": "FlashAirとは FlashAirは、無線LAN機能を搭載したSDHC/SDXCメモリカードです。FlashAirは、カード単体で無線LANのアクセスポイントとして機能するため、FlashAir搭載機器同士でファイルの送受信を行ったり、PCやスマートフォンなど外部の無線LAN機器からFlashAir内のファイルにアクセスしたりすることが可能です。 FlashAirは、世界の主要な国で発売、利用されており、多数の機器で動作確認が行われています。 機能と特長 SDメモリカード規格準拠 SDメモリカードの規格に準拠したカードです。 「ワイヤレスデータ転送」機能 デジカメで撮った写真を、皆で共有して気にいった写真をスマートフォンに転送するなど、メモリカードに入っているデータをスマートフォンやPCにワイヤレスで転送できます。 専用のアプリを使用するか、スマートフォンやPCの汎用のブラウザでもファイルにアクセスできます。 画像ファイルだけでなく、様々な形式のファイルに対応しています。 カンタン無線設定 FlashAirとスマートフォンやPCを簡単に無線LAN接続できます。 *SSID、セキュリティキーを設定してセキュリティを保つことをお勧めします。 複数台で接続可能 デジカメ内のFlashAirに、複数のスマートフォンやPCから接続ができます。 省エネ 必要なときだけ通信することにより、機器のバッテリー消費を抑えることができます。 海外でもご使用できます 日本、米国、カナダ、EU（欧州連合）等の無線認証を取得しています。旅行先でもワイヤレスでデータ転送が可能です。 無線認証取得国以外でのご使用は、電波法違反となりますので、ご注意ください。 スペック FlashAir W-04 FlashAir W-03 * FlashAir W-02 * FlashAir * 型番 SD-UWA SD-WE SD-WD/WC SD-WB/WL 容量 16GB 32GB 64GB 8GB 16GB 32GB 8GB 16GB 32GB 8GB SDスピードクラス Class 10 Class 6 無線対応規格仕様 IEEE802.11b/g/n (2.4GHz SISO, HT20/HT40) IEEE802.11b/g/n (2.4GHz SISO, 20MHz) *生産終了 スペックの詳細は、メーカーサイトをご覧ください。 動作確認機器 FlashAirは、SDHC/SDXC対応のデジタルカメラで利用することができます。動作確認機器の一覧は、メーカーサイトでご確認ください。",
    "url": "http://localhost:4000/docs/discover/overview.html",
    "relUrl": "/docs/discover/overview.html"
  },
  "85": {
    "id": "85",
    "title": "コマンドリファレンス",
    "content": "",
    "url": "http://localhost:4000/docs/api/reference/reference.html",
    "relUrl": "/docs/api/reference/reference.html"
  },
  "86": {
    "id": "86",
    "title": "レジスタマップ",
    "content": "レジスタマップ FlashAirのiSDIOのメモリマップです。 アドレス サイズ タイプ 名称 読み／書き 00000h 00200h データポート Command Write Register 書き込み 00200h 00200h データポート Response Data Register Port 読み込み 00400h 00200h メモリ Status Register   00600h 00200h メモリ Capability Register 読み込み 00800h 00200h - Reserved   01000h 00200h メモリ Shared Memory (W-02, W-03, W-04)* 読み書き 01200h 00600h メモリ Shared Memory (W-04)* 読み書き 01800h 00800h - Reserved for Vendor   02000h 1E000h - Reserved   *Shared Memory は iSDIO のメモリアクセスコマンドのほか、下記のAPIで利用できます。 command.cgi 共有メモリからのデータの取得 (op=130) command.cgi 共有メモリへのデータの書き込み (op=131) lua機能 sharedmemory",
    "url": "http://localhost:4000/docs/api/register/register.html",
    "relUrl": "/docs/api/register/register.html"
  },
  "87": {
    "id": "87",
    "title": "Command Write Register",
    "content": "Command Write Register iSDIO Command Write Data iSDIO Command Write Dataは、1つまたは複数のコマンド情報を保持します。 FlashAirでは1度に1つのコマンドの発行のみをサポートしていることに注意してください。 つまり、 Number of iSDIO Commands は常に１となります。 サイズ[バイト] 名称 簡単な説明 読み込み／書き込み 1 iSDIO Command Write Identifier 01h 書き込み専用 1 Number of iSDIO Commands 登録されるiSDIOコマンドの数（1～8）。FlashAirでは常に1です。 書き込み専用 2 Reserved   書き込み専用 4 Size of iSDIO Command Write Data iSDIO Command Write Dataのサイズです。 書き込み専用 4 Reserved   書き込み専用 可変長 iSDIO Command Information   書き込み専用 （以降） Reserved   書き込み専用 iSDIO Command Information iSDIO Command Informationは単一コマンドのコマンドIDと引数の情報を保持します。 すべての引数は、Padding で4バイトに整列されます。 サイズ [バイト] 名称 簡単な説明 読み込み／ 書き込み 2 Reserved 書き込み専用 2 iSDIO command id コマンドID 書き込み専用 4 iSDIO command sequence id 他に発行されたコマンドと区別する為のシーケンスID 書き込み専用 2 Number of Arguments コマンドの引数の数 書き込み専用 2 Reserved 書き込み専用 4 Length of Argument（No.1） コマンドの引数（L1）の長さ 書き込み専用 L1 Argument（No.1） コマンドの引数（1番目） 書き込み専用 0, 1, 2 または 3 Padding（No.1） パディングのサイズはL1mod4の値が、0であれば0、1であれば3、2であれば2、3であれば1 書き込み専用 …​ 書き込み専用 4 Length of Argument（No.n） コマンドの引数（Ln）の長さ 書き込み専用 Ln Argument（No.n） コマンドの引数（n番目） 書き込み専用 0, 1, 2 または 3 Padding（No.n） パディングのサイズはLnmod4の値が、0であれば0、1であれば3、2であれば2、3であれば1 書き込み専用",
    "url": "http://localhost:4000/docs/api/register/request.html",
    "relUrl": "/docs/api/register/request.html"
  },
  "88": {
    "id": "88",
    "title": "関連商品・開発リソース",
    "content": "関連商品・開発リソース FlashAir開発を便利にする、関連商品やライブラリ、開発ツールをご紹介します。 関連商品 ライブラリ 開発ツール 関連商品 FlashAir W-04 SDHC/SDXCメモリカード 16GB TOSHIBA 無線LAN搭載 FlashAir SDHC/SDXCメモリカード 16GB SD-UWAシリーズ（W-04） ヨドバシ.comで購入 FlashAir W-03 SDHCメモリカード 16GB TOSHIBA 無線LAN搭載 FlashAir SDHC/SDXCメモリカード 16GB Class10 日本製 (国内正規品) SD-WE016G amazonで購入 かんたん！スマートフォン＋FlashAirで楽しむIoT電子工作 本書は、スマートフォンと無線通信（無線LAN搭載SDカード FlashAir（東芝）を使用）を活用した電子工作の入門書です。 amazonで購入 FlashBREAD ブレッドボード上で「FlashAir W-04」を使用するためのモジュールです。 詳細はこちら Seeeduino Storage for FlashAir Seeeduino Storage for FlashAirは、Arduio開発環境でFlashAirを使ったプロトタイピングを行うことができるボードです。 詳細はこちら 購入 Airio-Base（量産モデル） Arduino互換形状のNXP LPC11U35マイコンボードです。(Arduino互換機ではありません) マイコンとSPI接続されたSDメモリ用カードスロットは、FlashAirとの接続を容易にし、様々な開発を行うことができます。 詳細はこちら 購入 Airio Play（えありおぷれい） FlashAir のGPIO 機能を使うための基板です。JavaScript などを利用したHTML ゲームを動作させることが可能です。 詳細はこちら 購入 Airio RP（えありおあーるぴー） FlashAirを用いてプロトタイプ開発を行うためのボードです。DIP形状／SPI-I2Cブリッジ IC／リセットスイッチ・リセット端子／LEDピン 詳細はこちら 購入 Airio（えありお） FlashAir評価ボードです。FlashAirのGPIO機能を使用して、ブラウザからフルカラーLEDを駆動したり、スイッチの値を取得することなどが可能です。 詳細はこちら 購入 SDカード配線引出基板 AE-SD SDカードの配線をブレッドボードやユニバーサル基板等で使いやすいよう2.54mmピッチで引き出しました。FlashAirを使った電子工作にも便利です。 購入 FlashAir DIP IOボード FlashAirにGPIO と I2C インターフェースを拡張することができるボードです。 詳細はこちら 購入 Arduino 製品プロトタイピングなどの用途でとても人気のあるマイコンボードです。ユーザーがクローンを製造したり、改造して独自のArduino互換ボードを作ることが容易です。 詳細はこちら 購入 PM-232 ホスト側機器とプリンタを中継し、ホストからのデータをメモリカードに保存します。スマートフォンやタブレットからもアクセス可能です。 詳細はこちら GR-LYCHEE ARM Cortex-A RZ/A1LU搭載のリファレンスボードで、Mbed開発環境およびRenesasWebコンパイラ、IDE for GRでの開発が可能です。 詳細はこちら Arduinoをはじめよう 第3版 ”本書では、開発者自らが、Arduinoの哲学、ハードウェア、ソフトウェアの基礎を解説、誰にでもできる簡単なチュートリアルを行います。” amazonで購入 Arduinoではじめる電子工作 超入門 改訂第2版。”本書では、Arduinoの基本的な使い方や開発環境の準備方法から、Arduinoを利用した電子工作の活用方法を解説します。” amazonで購入 Programming in Lua プログラミング言語Lua公式解説書。”Luaの開発者イエルサリムスキー教授による公式解説書ついに登場！巻末にLua5.1リファレンスマニュアルも掲載、これ1冊でLuaのすべてが学べます。” amazonで購入 Lua 組み込みプログラミング Lua 5.2.3 対応版 Kindle版。”この本ではアプリケーションに Lua インタプリタを組み込み、C/C++ と Lua の間で相互に機能を呼び出す方法を解説します。” amazonで購入 Raspberry Pi 3 MODEL B シングルボードコンピュータ。Raspberry PiはSDメモリカードからのブートができます。 amazonで購入 Raspberry Piクックブック ”本書は、多くのユーザーの支持を集めている教育用低価格コンピュータ「Raspberry Pi」を使いこなすためのレシピ集です。” amazonで購入 ラズベリー・パイ 超入門 ”本書があれば、Linuxの初心者、電子工作の初心者、プログラミングの初心者すべての方に、安心してRaspberry Piを使いこなすことが可能です。” amazonで購入 ライブラリ Webアプリサンプル 開発: 東芝メモリ株式会社 FlashAirのAPIを操作するWebアプリのサンプルです。（このライブラリコードは二条項BSDライセンスで提供されています。） ダウンロード（48KB） FlashAir Library for iOS v1.0 開発: 東芝メモリ株式会社 FlashAirと通信する機能をまとめた、iOS向けアプリ用ライブラリです。（このライブラリコードは二条項BSDライセンスで提供されています。） ダウンロード（403KB） tfatool 開発: Tad Leonard コマンドラインからFlashAir APIを使うことが出来るPythonライブラリです。 リポジトリを見る 公式サイトを見る libAE_FAIO 開発: GPS_NMEA(@Seg_faul) FlashAir DIP IOボードのライブラリです。 リポジトリを見る FlashAirDev 開発: yanzm FlashAirと通信する機能をまとめた、Android向けアプリ用ライブラリです。 リポジトリを見る FlashAir client library for .NET Portable 開発: JakeJP FlashAirのAPIに接続するための.NET版クラスライブラリです。 リポジトリを見る FlashAir Javascript Client Library 開発: JakeJP FlashAirとの通信機能をまとめたJavascriptクラスライブラリです。 リポジトリを見る flashair-lua-dev 開発: xight FlashAir独自のLua関数を利用するためのライブラリです。FlashAir外でも開発が可能になります。 リポジトリを見る Fritzing 開発: 余熱 Fritzingで使用可能なFlashAirボードのライブラリです。 ダウンロード（55KB） 開発ツール FlashAirエミュレータ 開発: cho45 FlashAirのWebサーバーをエミュレートするPerlスクリプトです。無線LANの切り替えや通信状態の良しあしを無視できるので、開発時に利用すると便利です。 リポジトリを見る 公式サイトを見る",
    "url": "http://localhost:4000/docs/resources",
    "relUrl": "/docs/resources"
  },
  "89": {
    "id": "89",
    "title": "Response Data Register Port",
    "content": "Response Data Register Port iSDIO Command Response Dataは発行されたコマンドからのレスポンスが含まれています。 サイズ[バイト] 名称 簡単な説明 読み込み／書き込み 1 iSDIO Command Response Identifier 02h 読み込み専用 3 Reserved   読み込み専用 4 Size of iSDIO Command Response Data iSDIO Command Response Dataのサイズ 読み込み専用 6 Reserved   読み込み専用 2 iSDIO command id Command Write Registerに書かれているコマンドのコマンドID 読み込み専用 4 iSDIO command sequence id Command Write Registerに書かれているコマンドのコマンドシーケンスID 読み込み専用 4 Size of Response Data レスポンスデータ(L1)のサイズ 読み込み専用 L1 Response Data 発行されたコマンドに対するレスポンスデータ 読み込み専用 0, 1, 2 または 3 Padding パディングのサイズはL1mod4の値が、0であれば0、1であれば3、2であれば2、3であれば1 読み込み専用 （以降） Reserved   読み込み専用",
    "url": "http://localhost:4000/docs/api/register/response.html",
    "relUrl": "/docs/api/register/response.html"
  },
  "90": {
    "id": "90",
    "title": "Luaサンプルプログラム",
    "content": "Luaサンプルプログラム FlashAirの /DCIM 以下の最新フォルダーから、Facebookへアップロードするサンプルプログラムです。 リポジトリを見る（GitHub） このサイトのサンプルコードは 二条項BSDライセンスで提供されています。 開発者登録 アプリ登録 アクセストークンの取得 アップロードの準備 写真のアップロード サンプルプログラムをFlashAirの /lua フォルダに保存しておきましょう。 FlashAirのフォルダ・ファイル構成は次のようになります。 / +-- DCIM/ | +-- 100__TSB/ | +-- 101_FILE/ | +-- JPEGファイル +-- lua/ | +-- facebook.html | +-- facebook.cfg | +-- fb_auto_up.lua | +-- fb_get_token.lua | +-- fb_token_handler.lua | +-- lastupload.cfg +-- SD_WLAN/ +-- CONFIG DCIM/101_FILEフォルダーは例です。お使いのカメラによってフォルダー名は異なります。 Luaスクリプトは lua フォルダーに保存します。別のフォルダーに保存する場合は、fb_auto_up.lua, SD_WLAN/CONFIGの設定を実際の構成に合わせてください。 注意事項 本プログラムは、実用を想定したものではありません。 カメラに挿入したカードでの実行、カードのデータの削除、カードの空き容量不足、 などの場合に正しく動かない可能性があります。 Facebookの仕様変更があった場合、動作しない可能性があります。 1. 開発者登録 Facebookにアクセスするアプリを作成するには、開発者登録が必要です。 開発者登録済の場合は、次のステップに進んでください。 この作業は、インターネットに接続されたPC上で行います。 Facebook Developersを開きます。 画面右上の”ログイン”をクリックし、Facebookアカウントにログインします。 ログイン後、画面右上の”登録”をクリックし、開発者登録します。 アプリ開発 2. アプリの登録 Facebookにアクセスするアプリの登録とアプリ情報の取得を行います。 この作業は、インターネットに接続されたPC上で行います。 Facebook Developersのアプリ管理ページを開きます。 画面上の “新しいアプリを作成”をクリックします。 “表示名”を入力し、”アプリIDを作成してください”をクリックします。 例: “Lua Upload” 登録が完了すると、下記のような画面が表示されます。左ナビゲーションの”ダッシュボード”をクリックします。 左ナビゲーションの”設定”をクリックします。 “カテゴリ”を入力し、”＋プラットフォームを追加”をクリックします。 例: “写真” “ウェブサイト”をクリックします。 ウェブサイトに関する入力欄が追加されます。 サイトURLに http://flashair.local/lua/facebook.html と入力し、”変更を保存”をクリックします。 アプリの情報を控えます。これらの情報は取扱に注意し、他人と共有しないようにしてください。 アプリID app secret “表示”をクリックすると、アプリのシークレットキーが表示されます。 メニューの”ツール＆サポート”をクリックします。 ツールの”アクセストークンツール”をクリックします。 “App Token”を控えます。 3. アクセストークンの取得 FlashAirをカードリーダーに挿入します。 FlashAirのSD_WLANフォルダに保存されている、CONFIGファイルを編集します。 キー 値 意味 APPMODE 6 インターネット同時接続モードで起動 APPSSID 例) lua_test FlashAirのSSID APPNETWORKKEY 例) 12345678 FlashAirのパスワード BRGSSID 例) my_home_wlan 家庭の無線LAN APのSSID BRGNETWORKKEY 例) password12345678 家庭の無線LAN APのパスワード APPAUTOTIME 0 FlashAirの無線LAN機能自動停止無効 WEBDAV 2 WebDAV機能有効 facebook.htmlを編集し、変数 appID をApp IDの値にします。 var appId = &quot;1369419999999999&quot;; FlashAirをカードリーダーから一旦取り出し、再び挿入します。 PCの無線LANを、FlashAirに接続します。 SSIDとパスワードはCONFIGファイルに設定した値です。 ウェブブラウザから、http://flashair.local/lua/facebook.html にアクセスします。 OAuthの認証画面が出るので、”（名前）としてログイン”をクリックします。 “投稿をシェアしたい相手は？”の選択肢を”自分のみ”に変更し、”OK”をクリックします。 PUT Success: OK と表示されれば成功です。 FlashAirのluaフォルダに”fb_access_token”というファイルが作成されます。 このファイルは、FlashAirをカードリーダーから抜き差ししてから確認して下さい。 4. アップロードの準備 FlashAirをカードリーダーに挿入します。 facebook.cfg ファイルを編集し、控えた、App Token, App Secret, App IDを設定します。 app_access_token=1369419999999999|x2bu1ED9XxXxXxXxXxXxXxXxXxX app_secret=e820256be7XxXxXxXxXxXxXxXxXxXxXx app_id=1369419999999999 token_fullpath=/lua/fb_access_token アクセストークンを、約60日間有効なアクセストークンに更新します。 現在のトークンは約1時間で無効になります。http://flashair.local/lua/fb_get_token.luaにアクセスします。 user access token:に続けて以下の様な文字列が表示されれば成功です。 lastupload.cfg ファイルを編集し、下記のような内容に変更してください。無ければ新規に作成してください。 lastupload=1000001 100__TSBフォルダーのFA000001.JPGファイルはアップロード済みという意味になります。 FlashAirのSD_WLANフォルダに保存されている、CONFIGファイルを編集します。 キー 値 意味 APPMODE 5 ステーションモードで起動 APPSSID 例) my_home_wlan 家庭の無線LAN APのSSID APPNETWORKKEY 例) password12345678 家庭の無線LAN APのパスワード LUA_RUN_SCRIPT 例) /lua/fb_auto_up.lua 電源投入後に実行したいスクリプトのフルパス FlashAirをカードリーダーから抜きます。 5. 写真のアップロード FlashAirをカードリーダーに挿入します。 自動的に、アクセスポイントへの接続と、Facebookへのアップロードが開始されます。 画像ファイルの更新日を元にアルバムを作成してアップロードします。 アルバム名の書式は“YYYY-M-D”です。 DCIM以下の古いフォルダーから順にアップロードします。 フォルダーの削除並びに、名前の変更をした場合、正しく動作しません。 フォルダー内の古い画像ファイルから順にアップロードします。 サイズにもよりますが、１枚の写真のアップロードに数分かかることもあります。 Facebookのページにアクセスすると、写真がアップロードされていることが確認できます。",
    "url": "http://localhost:4000/docs/api/lua/sample.html",
    "relUrl": "/docs/api/lua/sample.html"
  },
  "91": {
    "id": "91",
    "title": "Seeeduino Storage for FlashAir",
    "content": "Seeeduino Storage for FlashAir Seeeduino Storage for FlashAirは、Arduio開発環境でFlashAirを使ったプロトタイピングを行うことができるボードです。 主な仕様 搭載マイコン： ATMEGA328 マイコン動作電圧： 5V/3.3V（スライドSWで切り替え） USB: microB USB/バッテリーコネクタ給電 Grove: x2(I2C, UART) SDカードスロット搭載 特徴 「Arduino」のフォームファクターを採用 Seeed社のスターターキット「Grove - Starter Kit for Arduino」が利用可能 バッテリーチャージャー搭載 購入 Seeeduino Storage for FlashAirは、以下よりご購入いただけます。 秋月電子通商 http://akizukidenshi.com/catalog/g/gM-13705/ 同店にて、FlashAir DIP IOボードと組み合わせ可能なFlashAirも販売しています。 W-03 16GB: M-09651 W-03 32GB: M-09865 参考ページ Arduino向けチュートリアル FlashAirの共有メモリにアクセスするライブラリ＆サンプル",
    "url": "http://localhost:4000/docs/resources/seeeduino-storage-for-flashair.html",
    "relUrl": "/docs/resources/seeeduino-storage-for-flashair.html"
  },
  "92": {
    "id": "92",
    "title": "スライド資料",
    "content": "スライド資料 過去のイベントでご紹介したプレゼンテーション資料一覧です。",
    "url": "http://localhost:4000/docs/slides.html",
    "relUrl": "/docs/slides.html"
  },
  "93": {
    "id": "93",
    "title": "Status Register",
    "content": "Status Register FlashAirのiSDIOステータスレジスタマップです。 iSDIOステータスレジスタ 無線LAN機能 ステータスレジスタ iSDIOステータスレジスタ iSDIO機器すべてで利用できるレジスタです。 引用元: Table 2-7 : iSDIO Status Register Map - iSDIO Simplified Specification Version 1.10 アドレス サイズ[バイト] 名称 Bit7 Bit6 Bit5 Bit4 Bit3 Bit2 Bit1 Bit 0 読み込み／書き込み 00400h 1 Command Write Status - - - - - - CWA CWU(opt) 読み込み／書き込み 00401h 15 Reserved                 読み込み専用 00420h 1 iSDIO Status - - - - ASU(Int) MCU(Int) ESU(Int) CRU(Int) 読み込み／書き込み 00421h 1 iSDIO Status (Reserved) - - - - - - - -   00422h 1 iSDIO Int Enable - - - - ASU_ENA MCU_ENA ESU_ENA CRU_ENA 読み込み／書き込み 00423h 1 iSDIO Int Enable (Reserved) - - - - - - - -   00424h 1 Error Status - - - - APE RPE CWE CRE 読み込み／書き込み 00425h 1 Error Status (Reserved) - - - - - - - -   00426h 1 Memory Status - - - - - - FAT MEX 読み込み専用 00427h 1 Memory Status (Reserved) - - - - - - - -   00428h 24 Reserved                   00440h 160 Command Response Status Queue                 読み込み専用 004E0h 32 Reserved                   00500h 256 Application Status                   （解説は順次公開予定） 無線LAN機能 ステータスレジスタ 無線LAN機能に対応したiSDIO機器で利用できるレジスタです。 FlashAirで利用できない部分は省略してあります。 引用元: Table 3-2 : Application Status for Wireless LAN - Wireless LAN Simplified Addendum Version 1.10 下記のFlashAir独自拡張があります。 BridgeモードにおけるWLANステータス値*1 アドレス：00507h、bit0 説明：Bridgeモード動作時に1bとなります。 EAPモードを含むEncryption Modeステータス値*2 アドレス：00528h、bit0～7 説明：EAPモード（WPA/WPA2 Enterprise）を示す次の値を追加しています。 07h: WPA-EAP認証、TKIP暗号化 08h: WPA-EAP認証、AES暗号化 09h: WPA2-EAP認証、TKIP暗号化 0Ah: WPA2-EAP認証、AES暗号化 アドレス サイズ[バイト] 名称 Bit7 Bit6 Bit5 Bit4 Bit3 Bit2 Bit1 Bit0 読み込み／書き込み 00500h 6 Reserved 00506h 1 WLAN Connected Infra-Direct AP-STA Group WPS Scan 読み込み専用 00507h 1 WLAN (Reserved) *1 読み込み専用 00508h 32 SSID 読み込み専用 00528h 1 Encryption Mode*2 読み込み専用 00529h 1 Signal Strength 読み込み専用 0052Ah 1 Channel 読み込み専用 0052Bh 5 Reserved 00530h 6 MAC Address 読み込み専用 00536h 10 Reserved 00540h 16 ID 読み込み専用 00550h 4 IP Address 読み込み専用 00554h 4 Subnet Mask 読み込み専用 00558h 4 Default Gateway 読み込み専用 0055Ch 4 Preferred DNS Server 読み込み専用 00560h 4 Alternate DNS Server 読み込み専用 00564h 1 Proxy Server PSE 読み込み専用 00565h 11 Proxy Server 00570h 2 Date 読み込み専用 00572h 2 Time 読み込み専用 00574h 1 HTTP Status HPC HTTP Progress 読み込み専用 00575h 1 Power Save Management - - - - - - - PSM 読み込み専用 00576h 1 File System Management - - - - - - - FIM 読み込み／書き込み 00577h 73 Reserved 005C0h 8 Reserved for Vendor 005C8h 4 HTTP転送ステータス・レジスタ 読み込み専用 005CCh 4 HTTP転送サイズ・レジスタ 読み込み専用 005D0h 6 Reserved for vendor 005D6h 1 ファイルダウンロードステータス・レジスタ 読み込み専用 005D7h 9 Reserved for vendor 005F0h 16 FWバージョンレジスタ 読み込み専用 HTTP転送ステータス・レジスタ HTTPClientの転送済みデータサイズを取得します。転送中のデータサイズが取得できるために、データ転送の経過状況を取得することが可能です。 HTTP転送サイズ・レジスタ HTTPレスポンスヘッダーのContent-lengthの値を取得します。Content-lengthがレスポンスに含まれていない場合には設定されません。 ファイルダウンロードステータス・レジスタ ファイルダウンロード中かどうかを判定します。 FWバージョンレジスタ FWバージョン情報を示すレジスタです。 （例：F24A6W3AW1.00.02）",
    "url": "http://localhost:4000/docs/api/register/status.html",
    "relUrl": "/docs/api/register/status.html"
  },
  "94": {
    "id": "94",
    "title": "サポート",
    "content": "サポート 重要なお知らせFlashAir™で使用しているWPA2(無線LANの暗号化方式)において、送受信されているデータを暗号化する際の鍵情報の生成・管理に関する脆弱性が発見されました。 詳しくはこちらの東芝メモリからのお知らせをご覧ください。 デベロッパー向けサポート FAQ FlashAirアプリ開発に関してよくある質問と答えを公開しています。 Stack Overflow アプリ開発や、プログラミングなど技術的な質問はスタックオーバーフローをおすすめします。 一般ユーザー向けサポート 一般的なご質問については、メーカーサイトのFAQをご覧ください。FAQにない質問に関しては、東芝メモリ株式会社 ブリッジメディア商品サポートセンターへ直接お問い合わせください。 FlashAir™設定ソフトウェア FlashAirをご使用のお客様が、ご使用のパソコンでFlashAirの設定を行う際に必要なソフトウェアです。最新情報についてはこちらにて随時更新いたしますので、ご確認ください。 FlashAir™ソフトウェア更新ツール FlashAirを快適にご使用いただくために本ツールによるソフトウェア更新をお勧めします。FlashAir W-04をご使用の方はこちらをご覧ください。",
    "url": "http://localhost:4000/docs/support",
    "relUrl": "/docs/support"
  },
  "95": {
    "id": "95",
    "title": "thumbnail.cgi",
    "content": "thumbnail.cgi thumbnail.cgiは画像のサムネイルを取得するために使用します。 機能 パラメータ例 ファームウェアバージョン サムネイルの取得 /DCIM/100__TSB/DSC_100.JPG 1.00.00+ サムネイルの取得 指定したファイルからEXIF規格で定められているサムネイル画像を取得して返します。JPEG(image/jpeg)形式です。 指定したファイルがJPEG形式でない場合、またはJPEG形式であってもEXIF規格で定められたサムネイル画像が格納されていない場合は、リクエストが404 Not Found となり失敗します。 リクエスト例: http://flashair/thumbnail.cgi?/DCIM/100__TSB/DSC_100.JPG レスポンスヘッダー: ファームウェアバージョン3.00.00以上の場合、HTTPレスポンスヘッダーに以下のフィールドが追加されます。 X-exif-WIDTH JPEGのEXIF情報よりWIDTHを取得し、ヘッダーへ追加します。 X-exif-HEIGHT JPEGのEXIF情報よりHEIGHTを取得し、ヘッダーへ追加します。 X-exif-ORIENTATION JPEGのEXIF情報よりORIENTATIONを取得し、ヘッダーへ追加します。",
    "url": "http://localhost:4000/docs/api/thumbnail.cgi.html",
    "relUrl": "/docs/api/thumbnail.cgi.html"
  },
  "96": {
    "id": "96",
    "title": "チュートリアル",
    "content": "チュートリアル",
    "url": "http://localhost:4000/docs/tutorials",
    "relUrl": "/docs/tutorials"
  },
  "97": {
    "id": "97",
    "title": "upload.cgi",
    "content": "upload.cgi upload.cgiは、ネットワーク越しにSDメモリカードの中身を変更するためのAPIです。 {% include warning.html title=”ご注意” content=”本機能を誤って使用すると、FlashAirのファイルシステムを破壊してデータを失う恐れがあります。 PCなどのSDメモリカードホスト機器はSDメモリカードの内容(FAT)をキャッシュしている場合がありますが、本CGIで行った変更をSDメモリカードホスト機器が認識する方法がありません。そのため、本CGIとSDメモリカードホスト機器から同時に変更を行うとFAT不整合が起こる可能性があります。書き込み後は必ずカードをいったん抜いて再挿入するなどしてSDメモリカードホスト機器に再認識させてください。” %} アップロード手順 #1 -Webブラウザから行う場合- CONFIG ファイルにUPLOAD=1 を書きこむ FlashAirを再起動する FlashAirに無線LANで接続する Webブラウザでhttp://flashair/upload.cgi を開く アップロードするファイルを選択し、Submitボタンを押す アップロード手順 #2 -CGIで行う場合- CONFIG ファイルにUPLOAD=1 を書きこむ FlashAirを再起動する FlashAirに無線LANで接続する WRITEPROTECT コマンドで、SDメモリカードホスト機器からの書き込みを禁止する UPDIR コマンドで、アップロード先ディレクトリを設定する FTIME コマンドで、ファイルの作成日時を設定する upload.cgiにファイルをPOSTし、ファイルをアップロードする 機能 パラメータ例 ファームウェアバージョン ファイルのアップロード http://flashair/upload.cgi 1.00.00+ ファイルの削除 http://flashair/upload.cgi?DEL=/DCIM/100__TSB/DSC_100.JPG 1.00.00+ アップロード先ディレクトリの設定 http://flashair/upload.cgi?UPDIR=/DCIM/101__TSB 1.00.00+ システム時間の設定 http://flashair/upload.cgi?FTIME=0x00210000 1.00.00+ SDメモリカードホスト機器からの書き込み禁止 http://flashair/upload.cgi?WRITEPROTECT=ON 1.00.00+ ファイルのアップロード multipart/form-data形式でデータをPOSTリクエストで送信すると、UPDIR で指定されたディレクトリにファイルをアップロードします。なお、本URLに対してWebブラウザからGETリクエストを使用すると、アップロードを行うための画面が表示されます。 設定に成功するとSUCCESS、失敗するとERROR を返します。 リクエスト例: http://flashair/upload.cgi ファイルの削除 指定したファイルをFlashAirから削除します。 重要  ディレクトリを指定した場合、ディレクトリ以下にファイルおよびディレクトリが存在してはいけません。存在している場合にディレクトリを削除すると、ディレクトリ以下のファイルおよびディレクトリはファイルシステムから認識できなくなることがあります。 設定に成功するとSUCCESS、失敗するとERROR を返します。 リクエスト例: http://flashair/upload.cgi?DEL=/DCIM/100__TSB/DSC_100.JPG アップロード先ディレクトリの設定 アップロードされたファイルを保存するディレクトリを指定します。 デフォルトではルートディレクトリ(/)に設定されています。 ディレクトリが存在しな場合は作成されますが、親ディレクトリが存在しない場合は作成されません。存在しないディレクトリを指定した場合は、その後のアップロード動作は失敗となります。 常にSUCCESS を返します。 アップロード操作が失敗してしまった場合でもSUCCESS が返されるため、このコマンドを使った後には、無事にファイルがアップロードされているかどうか確認することをお勧めします。 リクエスト例: http://flashair/upload.cgi?UPDIR=/DCIM/101__TSB システム時間の設定 アップロードされたファイルの作成時間を指定します。元のファイルのファイル時間情報は失われます。 パラメータは32ビットの16進数で、上位16ビットが日付、下位16ビットが時刻を表します。 情報の詳細はFAT32の規格を参照ください。 設定に成功するとSUCCESS、失敗するとERROR を返します。 リクエスト例: http://flashair/upload.cgi?FTIME=0x00210000 SDメモリカードホスト機器からの書き込み禁止 SDメモリカードホスト機器からの書き込みを禁止します。 書き込み禁止後は、SDメモリカードホスト機器からのライト動作にはエラーを返すため、SDメモリカードホスト機器はカードの異常として認識する場合があります。 書き込み禁止を解除するには、カードを再起動する必要があります。 設定に成功するとSUCCESS、失敗するとERROR を返します。 リクエスト例: http://flashair/upload.cgi?WRITEPROTECT=ON",
    "url": "http://localhost:4000/docs/api/upload.cgi.html",
    "relUrl": "/docs/api/upload.cgi.html"
  },
  "98": {
    "id": "98",
    "title": "サーバーアップロードコマンド",
    "content": "サーバーアップロードコマンド コマンドID コマンド名 機能 0021h SendHTTPMessageByRegister(hostName, message) 指定したサーバーにHTTPリクエストを送信 SendHTTPMessage～： 文字データのみのリクエストを発行 SendHTTPFile～： ファイルを添付してリクエストを発行 SendHTTPSSL～： SSLによる暗号化通信を使用 ～ByRegister: リクエストデータをメモリから読み込み ～ByFile: リクエストデータをファイルから読み込み 0022h SendHTTPFileByRegister(hostName, appendFileName, message) 0023h SendHTTPSSLMessageByRegister(hostName, message) 0024h SendHTTPSSLFileByRegister(hostName, appendFileName, message) 0025h SendHTTPMessageByFile(hostName, messageFileName, headerRemoval) 0026h SendHTTPFileByFile(hostName, messageFileName, appendFileName, headerRemoval) 0027h SendHTTPSSLMessageByFile(hostName, messageFileName, headerRemoval) 0028h SendHTTPSSLFileByFile(hostName, messageFileName, appendFileName, headerRemoval) 0029h SetCertificate(certificate) 002Ah SetCertificateByFile(certificateFileName) SendHTTPMessageByRegister(hostName, message) 特定のサーバにHTTPリクエストメッセージを送るためのホストリクエストです。 HTTPリクエストラインとHTTPメッセージヘッダー、HTTPメッセージボディで構成されるHTTPリクエストメッセージを、ホストは準備します。(optional in [HTTP]).（★1）　 すると、HTTPレスポンスラインとHTTPメッセージヘッダー、HTTPメッセージボディ(optional in [HTTP]) で構成されるHTTPレスポンスメッセージをFlashAirはサーバより受信します。2.3 Server Uploadを参照してください。（★2） コマンドID 0021h 引数 Name Type Size 説明 ホスト名 ASCII 変数 hostNameはHTTPリクエストメッセージが送信されHTTPレスポンスメッセージを受信するホスト名を意味します。プロキシサーバが使用される場合を除いて、ポート番号は”80”が使われます。値はNull値で終了しません。（★3） message Binary data Variable messageはHTTPリクエストラインとHTTPメッセージヘッダー、HTTPメッセージボディで構成されるHTTPリクエストメッセージを意味します。（★4） レスポンス 受信したHTTPレスポンスメッセージは、コマンドレスポンスデータのレスポンスデータから取得可能です。2.2.2.3 iSDIO Command Response Data in [iSDIO]を参照してください。（★5） SendHTTPFileByRegister(hostName, appendFileName, message) HTTPリクエストメッセージをファイルを添付して特定のサーバに送るためのホストリクエストです。 （★1と同じ） さらにサーバへメッセージが送信される際、FlashAirはメッセージ内の事前に定義された文字を特定のファイルに置き換えます。 （★2と同じ） コマンドID 0022h 引数 Name Type Size 説明 hostName ASCII character Variable （★3と同じ） appendFileName ASCII character Variable appendFileNameは、NANDメモリモジュール内のアペンドファイルのルートディレクトリからサーバに送信されるファイル名とファイルパッチを意味します。例”/DCIM/100XXXXX/YYYY1234.JPG”値はNull値で終了しません。（★8） message Binary data Variable （★4と同じ） レスポンス （★5と同じ） SendHTTPSSLMessageByRegister(hostName, message) このコマンドの定義は、 FlashAirにSSL経由でHTTPメッセージをリクエストする以外は、”SendHTTPMessageByRegister(hostName, message)”と同じです。プロキシサーバが使用される場合を除いて、ポート番号443が使われます。 このコマンドを実行する前に、”SetCertificate”または”SetCertificateByFile”コマンドでルート認証を設定することが推奨されています。ルート認証を設定せずにコマンドを実行した場合、ルート認証によるサーバ証明書を認証しないまま、FlashAirはこのコマンドを実行します。（★6） サーバ証明書がルート認証によって認証されない場合、レスポンスステータスが”85h: SSL certification error”となり、このコマンドの実行は失敗となります。（★7） コマンドID 0023h 引数 Name Type Size 説明 hostName ASCII character Variable （★3と同じ） message Binary data Variable （★4と同じ） レスポンス 無し SendHTTPSSLFileByRegister(hostName, appendFileName, message) このコマンドの定義は、 FlashAirにSSL経由でHTTPメッセージをリクエストする以外は、”SendHTTPMessageByRegister(hostName, message)”と同じです。プロキシサーバが使用される場合を除いて、ポート番号443が使われます。（★13） （★6と同じ） （★7と同じ） コマンドID 0024h 引数 Name Type Size 説明 hostName ASCII character Variable （★3と同じ） appendFileName ASCII character Variable （★8と同じ） message Binary data Variable （★4と同じ） レスポンス 無し SendHTTPMessageByFile(hostName, messageFileName, headerRemoval) 特定のサーバにHTTPリクエストメッセージを送るためのホストリクエストです。 コマンドが実行される前に、HTTPリクエストラインとHTTPメッセージヘッダー、HTTPメッセージボディで構成されるHTTPリクエストメッセージを、ホストはメッセージファイルとしてNANDメモリモジュールに保存します。（★9） すると、HTTPレスポンスラインとHTTPメッセージヘッダー、HTTPメッセージボディ(optional in [HTTP])から構成されるHTTPレスポンスメッセージをFlashAirがサーバから受信し、”RESPONSE” ディレクトリの下に”iSDIO command sequence id”のファイル名で保存します。もしこのファイルが存在した場合、上書きして保存されます。HTTPリクエストラインとHTTPメッセージヘッダーを除くよう、ホストがリクエストした場合、HTTPメッセージボディのみがレスポンスファイルとして保存されます。2.3 Server Uploadを参照してください。 Capability Register内の”Max Size of Command Response Data”による制限は、このコマンドによって作られるレスポンスファイルのサイズに適用されません。（★10） コマンドID 0025h 引数 Name Type Size 説明 hostName ASCII character Variable （★3と同じ） messageFileName ASCII character Variable messageFileNameは、NANDメモリモジュール内のメッセージファイルのルートディレクトリから送られ？、HTTPリクエストラインとHTTPメッセージヘッダー、HTTPメッセージボディで構成されるファイル名とファイルパッチを意味します。例 &quot;/REQUEST/MESSAGE1.TXT&quot;。 値はNull値で終了しません。（★11） headerRemoval integer 1-byte headerRemovalはHTTPヘッダーを除くことに関して意味します。 00h HTTPレスポンスメッセージはそのまま保存されます。 01h HTTPヘッダーを除くことにより、HTTPメッセージボディのみ保存されます。（★12） レスポンス 無し SendHTTPFileByFile(hostName, messageFileName, appendFileName, headerRemoval) ファイルを添付して、HTTPリクエストメッセージを特定のサーバに送るためのホストリクエストです。（★9と同じ） メッセージがサーバへ送信されると、FlashAirはメッセージ内の事前に定義した文字 (例: “” in [ISO 8859-1]) を特定のファイルに変換します。 （★10と同じ） コマンドID 0026h 引数 Name Type Size 説明 hostName ASCII character Variable （★3と同じ） messageFileName ASCII character Variable （★11と同じ） appendFileName ASCII character Variable （★8と同じ） headerRemoval integer 1-byte （★12と同じ） レスポンス 無し SendHTTPSSLMessageByFile(hostName, messageFileName, headerRemoval) （★13とほぼ同じ　”SendHTTPMessageByFile (hostName, messageFileName, headerRemoval)） （★6と同じ）（★7と同じ） (i.e. Response Status becomes “85h: SSL certification error”). コマンドID 0027h 引数 Name Type Size 説明 hostName ASCII character Variable （★3と同じ） messageFileName ASCII character Variable （★11と同じ） headerRemoval integer 1-byte （★12と同じ） レスポンス 無し SendHTTPSSLFileByFile(hostName, messageFileName, appendFileName, headerRemoval) （★13とほぼ同じ　”SendHTTPFileByFile (hostName, messageFileName, appendFileName, headerRemoval)”） （★6と同じ） （★7と同じ） (i.e. Response Status becomes “85h: SSL certification error”). コマンドID 0028h 引数 Name Type Size 説明 hostName ASCII character Variable （★3と同じ） messageFileName ASCII character Variable （★11と同じ） appendFileName ASCII character Variable （★8と同じ） headerRemoval integer 1-byte （★12と同じ） レスポンス 無し SetCertificate(certificate) HTTPS接続のためルート認証を行います。このコマンド実行後、FlashAirは付与されたHTTPS接続の証明書を使用します。ルート認証がすでに行われている場合は、現在の証明書は無効となり、FlashAirは新しく設定されたものを使用します。 コマンドID 0029h 引数 Name Type Size 説明 certificate Binary data Variable certificateはDER (Distinguished Encoding Rules)によるX.509バイナリです。“Length of Argument”を”00 00 00 00h”に設定した場合、この値は無視できます。無視した場合は、FlashAirは現在の証明書を無効にし、デフォルトの設定に戻ります。（★14） レスポンス 無し SetCertificateByFile(certificateFileName) HTTPS接続のためNANDメモリモジュール内に保存されたファイルをルート認証に設定します。このコマンド実行後、このコマンド実行後、FlashAirは付与されたHTTPS接続の証明書を使用します。ルート認証がすでに行われている場合は、現在の証明書は無効となり、FlashAirは新しく設定されたものを使用します。 コマンドID 002Ah 引数 Name Type Size 説明 certificateFileName ASCII character Variable 接続するためのAPのSSIDです。値はNull値で終了しません。 networkKey ASCII character Variable certificateFileNameは、NANDメモリモジュール内の認証ファイルのルートディレクトリからサーバに送信されるファイル名とファイルパッチを意味します。例 “/ABCDEF.CRT” 値はNull値で終了しません。（★8と似ている） 証明ファイルはDER (Distinguished Encoding Rules)によるX.509バイナリです。(Distinguished Encoding Rules).（★14と同じ） レスポンス 無し",
    "url": "http://localhost:4000/docs/api/reference/upload.html",
    "relUrl": "/docs/api/reference/upload.html"
  },
  "99": {
    "id": "99",
    "title": "FlashAirでできること",
    "content": "FlashAirでできること FlashAirでできること FlashAirは、SDメモリカードの中に、無線LAN機能とマイコンを内蔵した、iSDIO規格に準拠した機器です。 カメラやPCなど、SDメモリカードスロットを持つ機器（SDメモリカードホスト機器）は、FlashAirをSDHC/SDXCメモリカードとして認識し、データの読み書きを行うことができます。また、iSDIOコマンドをサポートしているSDメモリカードホスト機器ならば、無線LAN機能のコントロールを行うこともできます。 FlashAirはWebサーバーを内蔵しています。無線LAN親機（アクセスポイント, AP）として動作しているFlashAirに、無線LAN子機（ステーション, STA）として動作しているPCやスマートフォンといった無線LAN機器から接続し、HTTP (HyperText Transfer Protocol) 経由で通信することができます。 無線 APモードで起動、STAモードで起動、AP+STA同時起動、無線切断、SSIDのスキャンといった無線LANの制御ができます。 HTTP 無線LAN上で、HTTP通信ができます。 Webサーバー FlashAir内のファイルにHTTP GETリクエストを発行することで、ファイルをダウンロードすることができます。また、FlashAirの情報を読み取る、設定を変更するなどの操作が行えるCGI (Common Gateway Interface) が用意されています。 スクリプト Luaスクリプトの実行ができます。 GPIO SD端子のGPIO制御ができます。 SD 内蔵フラッシュメモリのファイル読み書きができます。 その他 SRAMの読み書きができます。 アプリ作成 FlashAirアプリ作成方法は、制御する機器によって異なります。 FlashAir連携アプリの開発 HTTP制御でスマートフォンアプリやウェブブラウザを使ったインターフェースを作成したい方は、 アプリ開発の概要をご覧ください。 iOSやAndroidのスマートフォンアプリ ウェブブラウザ 組み込み機器を開発 iSDIOやLuaスクリプトを利用してデバイスを開発したい方は、組み込み機器開発の概要をご覧ください。 Arduinoでデバイス作成 FlashAir世代ごとの違い FlashAirカードには、 第1世代（W-01）、 第2世代（W-02）、 第3世代（W-03）、 第4世代（W-04）の4種類のバージョンがあり、第2世代でSDメモリーカードがClass10に、第4世代でUHSスピードクラス3に対応し高速化されている、第4世代の無線による転送速度は第3世代の約2.9倍となっている、といった違いがあります。 また、第1世代はファームウェアバージョン1.00系列、第2世代は同2.00系列、第3世代は同3.00系列、第4世代は同4.00系列の対応となっており、2.00系列ではAPI仕様が大幅に拡張されています。アプリ開発者は、ファームウェアによる挙動の違いに注意しましょう。   FlashAir W-04第4世代SD-UWA FlashAir W-03第3世代SD-WE FlashAir W-02第2世代SD-WD/WC FlashAir W-01第1世代SD-WB/WL 読み書き最大速度 読み出し: 90MB/s書き出し: 70MB/s - - - ∗1MB/秒を1,000,000バイト/秒として計算しています。最大転送速度は、東芝メモリの試験環境で特定の条件により得られた最良の値であり、ご使用機器での速度を保証するものではありません。読み出し/書き込み速度は使用する機器等の条件により異なります。従来SDインターフェースでの転送速度は、UHS-Iインターフェースに比べ低下します。 無線転送速度 約31.4Mbps 約10.8Mbps - - ∗測定値はメーカー独自で計測したものであり、実際の送信速度を保証するものではありません。使用される機材や環境によって実際の無線送信速度は異なります。 UHS UHS-IUHS Speed Class3 - - - SDHC/SDXCメモリカードで利用できるインターフェースで、対応機器と使用することで高速のパフォーマンスが得られます SDスピードクラス Class 10 Class 10 Class 10 Class 6 SDホスト機器とのデータ転送速度を定めた規格で、Class 10では、読み書き時のデータ転送速度が最低10MB/秒となっています。 対応ファームウェア 4.00系列例: F15DBW3BW4.00.00 3.00系列例: FA9CAW3AW3.00.02 2.00系列例: F19BAW3AW2.00.04 1.00系列例: F24A6W3AW1.00.04 | List.htmへのファイル一覧埋め込み方法 | JavaScriptプログラムとして | JavaScriptプログラムとして | JavaScriptプログラムとして | カンマ区切りリストとして | List.htmについてはこちらをご覧ください Eyefi Connected SDメモリカードの無線のオン・オフをカメラ側で設定したり、データ転送中の電源停止を防ぐことができる機能です FlashAirドライブ(WebDAV) FlashAirに無線LANで接続したパソコンから、FlashAir内の写真やファイルを閲覧、コピーすることができる機能です インターネット同時接続モード FlashAirを介して、他のアクセスポイントに接続することができる機能です Luaスクリプトサポート Lua言語で書かれたスクリプトファイルをFlashAirに保存することでさまざまな処理を行うことができます その他 ブラウザユーティリティのカスタマイズiSDIOサポートGPIOサポートロングファイルネーム日本語ファイル名 ブラウザユーティリティのカスタマイズiSDIOサポートGPIOサポートロングファイルネーム日本語ファイル名 ブラウザユーティリティのカスタマイズiSDIOサポートGPIOサポートロングファイルネーム日本語ファイル名 ブラウザユーティリティのカスタマイズiSDIOサポート CGIコマンド数 command.cgi: 25config.cgi: 12thumbnail.cgi: 1update.cgi: 5 command.cgi: 25config.cgi: 12thumbnail.cgi: 1update.cgi: 5 command.cgi: 23config.cgi: 9thumbnail.cgi: 1update.cgi: 5 command.cgi: 10config.cgi: 6thumbnail.cgi: 1update.cgi: 5 第4世代は、ファームウェアバージョン4.00.00の内容です。 第3世代は、ファームウェアバージョン3.00.02の内容です。 第2世代は、ファームウェアバージョン2.00.04の内容です。 第1世代は、ファームウェアバージョン1.00.04の内容です。",
    "url": "http://localhost:4000/docs/discover/usage.html",
    "relUrl": "/docs/discover/usage.html"
  },
  "100": {
    "id": "100",
    "title": "ブラウザユーティリティ",
    "content": "ブラウザユーティリティ ブラウザユーティリティは、 FlashAirのコンテンツをウェブブラウザで見る場合に表示される画面のことです。 List.htmというHTMLファイルがその実体で、 これを変更することで、コンテンツの表示方法をカスタマイズすることができます。 例えば、JavaScriptを使ったユーザーインターフェースを作ったり、 背景写真を組み合わせてフォトフレームのような見た目にすることもできます。 List.htmの編集方法については、ウェブブラウザ向けテンプレートをご覧ください。 List.htm ディレクトリパスに対するGETリクエストが発行された場合、 FlashAirはこのファイルを読み込んでレスポンスとして返します。 その際、ファイル内に&lt;!--WLANSDJLST--&gt; というタグがあった場合、 下記のような対象ディレクトリのコンテンツリストに置き換えを行います。 /DCIM,100__TSB,0,16,9944,129 /DCIM,0126_1.jpg,70408,32,17071,28040 W-02カードでは, List.htm は存在せず、 ファームウェアに内蔵されたブラウザユーティリティが使われますが、 List.htmを作成すれば上記の説明通りにカスタマイズができます。 ただし、 &lt;!--WLANSDJLST--&gt; の置き換えルールが異なります。 wlansd.push({&quot;r_uri&quot;:&quot;/DCIM&quot;, &quot;fname&quot;:&quot;100__TSB&quot;, &quot;fsize&quot;:0,&quot;attr&quot;:16,&quot;fdate&quot;:9944,&quot;ftime&quot;:129}); wlansd.push({&quot;r_uri&quot;:&quot;/DCIM&quot;, &quot;fname&quot;:&quot;0126_1.jpg&quot;, &quot;fsize&quot;:70408,&quot;attr&quot;:32,&quot;fdate&quot;:17071,&quot;ftime&quot;:28040});",
    "url": "http://localhost:4000/docs/api/utility.html",
    "relUrl": "/docs/api/utility.html"
  },
  "101": {
    "id": "101",
    "title": "ウェブブラウザ向けチュートリアル",
    "content": "ウェブブラウザ向けチュートリアル ウェブブラウザ向けのチュートリアルを紹介しています。",
    "url": "http://localhost:4000/docs/tutorials/web.html",
    "relUrl": "/docs/tutorials/web.html"
  },
  "102": {
    "id": "102",
    "title": "WLANコマンド",
    "content": "WLANコマンド コマンドID コマンド名 機能 0001h Scan() 近傍の無線LANの検索 0002h Connect(ssid, networkKey) STAモードで起動し、指定の無線LANに接続 0E401h Connect8021X(ssid) EAPモードによる接続 0003h Establish(ssid, networkKey, encMode) APモードで起動 0005h StartWPS(ssid, wpsMode, pin) STAモードでWPSを開始 0007h Disconnect() 無線LAN接続の切断 ※「0004h:WiFiDirect(wpsMode, pin)」と「0006h:StartWPSAP(wpsMode, pin)」はFlashAirでは利用不可です。 Scan() 接続可能な無線LANを検索するホストリクエストです。 接続可能なSSIDリストは、コマンドプロセスの結果でResponse Data Register Portから読み取れます。 コマンドID 0001h 引数 無し レスポンス SSIDリストはCommand Response Data（iSDIO Simplified Specification－2.2.2.3 iSDIO Command Response Data参照）のレスポンスデータから読み取れます。SSIDリストのフォーマットはWireless LAN Simplified Addendum－3.6.2 Wireless LAN SSID Listで定義されているものです。 Connect(ssid, networkKey) STAモードで起動し、指定のAPに無線LANで接続するホストリクエストです。FlashAirが完全にAPと接続したときにコマンドプロセスが終了します。 コマンドID 0002h 引数 名前 型 サイズ 説明 ssid ASCII 文字型 可変長 接続先APのSSIDです。Null値にはできません。 networkKey ASCII 文字型 可変長 SSIDに対応したネットワークキーです。Null値にはできません。無線LAN接続が暗号化されていない場合、この値は省略することができます（引数は「00 00 00 00h」にセットされます）。 レスポンス 無し Connect8021X(ssid) EAPモードによる接続を行います。PEAPモードにおいては、IDとpasswordを指定し、CertificateFileはArgument length=0、値なしと指定します。TLSモードの場合にはクライアント証明書のファイルパスをCertificateFileに設定します。 コマンドID 0E401h 引数 名前 型 サイズ 説明 ssid ASCII 文字型 可変長 接続先APのSSIDです。Null値にはできません。 Type 整数型 1バイト 接続タイプを指定します。 0 PEAPモード 1 TLSモード ID ASCII 文字型 可変長 ユーザーIDを1～32文字で設定します。 password ASCII 文字型 可変長 PEAPパスワードまたはTLS秘密キーパスワードを1～32文字で設定します。 CertificateFile ASCII 文字型 可変長 ファイルパス、TLS証明書を設定します。（.pfxまたは.p12形式）最大64文字指定できます。 レスポンス 無し Establish(ssid, networkKey, encMode) 無線LAN内でAPモードとして起動するホストリクエストです。FlashAirはDHCPサーバとなり、（ホストの命令なしに）他のSDメモリカードのレスポンスを受けてWireless LAN Simplified Addendum－D.4 Peer-to-Peer File Transfer Sequenceに従って、Wireless LAN Simplified Addendum－Appendix Cで定義されているHTTPリクエスト/レスポンスの処理を行います。APモードでの起動が成功または失敗したときにコマンドプロセスは終了します。 コマンドID 0003h 引数 名前 型 サイズ 説明 ssid ASCII 文字型 変数 SSIDです。Null値にはできません。 networkKey ASCII 文字型 変数 SSIDに対応したネットワークキーです。Null値にはできません。無線LAN接続が暗号化されていない場合、この値は省略することができます（引数は「00 00 00 00h」にセットされます）。 encMode 整数型 1バイト encModeは、ネットワーク認証とAP用のデータ暗号化方式を示します。 00h オープンシステム認証、非暗号化 01h オープンシステム認証、WEP暗号化（オプション） 03h WPA-PSK認証、TKIP暗号化（オプション） 04h WPA-PSK認証、AES暗号化（オプション） 05h WPA2-PSK認証、TKIP暗号化（オプション） 06h WPA2-PSK認証、AES暗号化（必須） SDメモリカードにより実装されているネットワーク認証とデータ暗号化、そしてホストがCapability Registerで使用する暗号化がサポートされているかを確認してください。 詳細は Wireless LAN Simplified Addendum－3.5 iSDIO Capability Register for Wireless LANを参照してください。 レスポンス 無し StartWPS(ssid, wpsMode, pin) WPS機能のPINコード方式またはプッシュボタン方式で無線LAN内のAPへ接続を開始するホストリクエストです。FlashAirがWPSプロセス後にAPへ接続完了したときにコマンドプロセスは終了します。追加の接続コマンドは必要ありません。 コマンドID 0005h 引数 名前 型 サイズ 説明 ssid ASCII 文字型 変数 接続先APのSSIDです。Null値にはできません。値は除外される可能性があります。この値は省略することができます（引数は「00 00 00 00h」にセットされます）。またプッシュボタン方式の場合は設定値は無視されます。 wpsMode 整数型 1バイト WPS機能のモードです。 01h PINコード方式 02h プッシュボタン方式 pin 実数型 4バイト または 8バイト PINコード方式のpinコードです。この値は省略することができます（引数は「00 00 00 00h」にセットされます）。またプッシュボタン方式の場合は設定値は無視されます。 レスポンス 接続先APの32バイトのSSIDと64バイトのネットワークキー（合計96バイト）は、(Wireless LAN Simplified Addendum－3.6 iSDIO Response Data for Wireless LAN)のレスポンスデータからWPSリストとして読み取れます。 Disconnect() APへの接続を切断または終了し、アプリケーション使用時はアプリケーションを終了するホストリクエストです。これに伴い、無線LAN接続を要求しているコマンドプロセスは終了します。P2P通信を行っている場合、FlashAirは終了（Wireless LAN Simplified Addendum－C.2.6 HTTP(END)を通知するHTTPリクエストメッセージを送信します。FlashAirがAPへの接続を切断または終了したときにコマンドプロセスは終了します。 コマンドID 0007h 引数 無し レスポンス 無し",
    "url": "http://localhost:4000/docs/api/reference/wlan.html",
    "relUrl": "/docs/api/reference/wlan.html"
  }
  
}
